<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="欢迎来到xieshanzhong的技术分享站~">
<meta property="og:type" content="website">
<meta property="og:title" content="XIE&#39;S BLOG">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="XIE&#39;S BLOG">
<meta property="og:description" content="欢迎来到xieshanzhong的技术分享站~">
<meta property="og:locale">
<meta property="article:author" content="xieshanzhong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>XIE'S BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="XIE'S BLOG" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XIE'S BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">xieshanzhong的博客小站</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/12/JDK%E6%BA%90%E7%A0%81%E4%B9%8BObject/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xieshanzhong">
      <meta itemprop="description" content="欢迎来到xieshanzhong的技术分享站~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XIE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/12/JDK%E6%BA%90%E7%A0%81%E4%B9%8BObject/" class="post-title-link" itemprop="url">JDK源码之Object</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-12 22:05:44" itemprop="dateCreated datePublished" datetime="2019-03-12T22:05:44+08:00">2019-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-03 16:46:51" itemprop="dateModified" datetime="2023-11-03T16:46:51+08:00">2023-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">源码篇</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、资料"><a href="#一、资料" class="headerlink" title="一、资料"></a>一、<em>资料</em></h3><h3 id="二、总知识点"><a href="#二、总知识点" class="headerlink" title="二、总知识点"></a>二、<em>总知识点</em></h3><p><img src="https://i.imgur.com/NuQM5N4.png" alt="Object类的源码"></p>
<h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><pre><code>    Object类是Java中所有类的根类，即所有的类都继承了Object类
</code></pre><h3 id="2、核心方法"><a href="#2、核心方法" class="headerlink" title="2、核心方法"></a>2、核心方法</h3><h4 id="2-1、public-boolean-equals-Object-obj"><a href="#2-1、public-boolean-equals-Object-obj" class="headerlink" title="2.1、public boolean equals(Object obj)"></a>2.1、public boolean equals(Object obj)</h4><pre><code>    equals方法的通用约定：
        自反性：对于任何非null的引用值x，x.equals(x)必须返回true。
        对称性：对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。
        传递性：对于任何非null的引用值x、y、z，如果x.equals(y)返回true，并且y.equals(z)返回true，那么x.equals(z)也必须返回ture。
        一致性：对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致的返回ture，或者一致的返回false。
        非空性：对于任何非null的引用值x，x.equals(null)必须返回false。
</code></pre><p>  重写equals()方法时，应同时重写hashCode()方法</p>
<h4 id="2-2、public-native-int-hashCode"><a href="#2-2、public-native-int-hashCode" class="headerlink" title="2.2、public native int hashCode()"></a>2.2、public native int hashCode()</h4><pre><code>    - 在程序相同执行过程中多次调用同个对象，哈希值必须返回相同。但不是相同调用过程则不必相同； 
    - 如果两个对象调用equals()方法相同，则hashCode()方法返回值必须相同； 
    - 如果两个对象调用equals()方法不相同，并不需要两个对象的哈希值不相同。但是编程的时候必须意识到，不同的对象产生不同的哈希值可以提高像HashTable这样类的性能
</code></pre><h4 id="2-3、protected-native-Object-clone-throws-CloneNotSupportedException"><a href="#2-3、protected-native-Object-clone-throws-CloneNotSupportedException" class="headerlink" title="2.3、protected native Object clone() throws CloneNotSupportedException"></a>2.3、protected native Object clone() throws CloneNotSupportedException</h4><pre><code>    创建并且返回一个对象的复制，clone()的正确调用是需要实现Cloneable接口，如果没有实现Cloneable接口，并且子类直接调用Object类的clone()方法，则会抛出CloneNotSupportedException异常。
 *    x.clone() != x 
 *    x.clone().getClass() == x.getClass();
 *    x.clone().equals(x);
 *    这些表达式一般都为true，但是并不是绝对需要的。
 *    一般而言，clone()是将这个对象复制一次，变成两个对象，都有着自己的内存空间，而不是只建立一个引用，所以x.clone() != x；为true
 *    x.clone().getClass() == x.getClass();为true说明两个对象的运行时对象相同
 *    x.clone.equals(x)；依赖于equals()方法的重写，如果只是调用Object的equals()方法，那么这个表达式返回false，因为Object的equals()
 * 方法比较的是对象的地址。
 * 
 * 深拷贝和浅拷贝：
 *    浅拷贝是将原始对象中的数据型字段拷贝到新对象中去，将引用型字段的“引用”复制到新对象中去，
 * 不把“引用的对象”复制进去，所以原始对象和新对象引用同一对象，新对象中的引用型字段发生变化会
 * 导致原始对象中的对应字段也发生变化。深拷贝是在引用方面不同，深拷贝就是创建一个新的和原始字
 * 段的内容相同的字段，是两个一样大的数据段，所以两者的引用是不同的，之后的新对象中的引用型字
 * 段发生改变，不会引起原始对象中的字段发生改变。
</code></pre><p>详细的clone的浅复制与深复制<a href="https://www.cnblogs.com/Qian123/p/5710533.html" title="浅复制与深复制">https://www.cnblogs.com/Qian123/p/5710533.html</a></p>
<h4 id="2-4、public-String-toString"><a href="#2-4、public-String-toString" class="headerlink" title="2.4、public String toString()"></a>2.4、public String toString()</h4><pre><code>public String toString() &#123;
    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
&#125;
</code></pre><h4 id="2-5、public-final-native-void-notify-public-final-native-void-notifyAll"><a href="#2-5、public-final-native-void-notify-public-final-native-void-notifyAll" class="headerlink" title="2.5、public final native void notify()/public final native void notifyAll()"></a>2.5、public final native void notify()/public final native void notifyAll()</h4><pre><code>     *唤醒正在此对象上等待的一个线程。 如果有多个线程正在等待此对象，则选择其中一个线程被唤醒。 选择是任意的，由JVM实施决定。
     * 线程通过调用&#123;@code wait&#125;方法等待获取对象。
     *在当前线程放弃对该对象的锁定之前，唤醒的线程(就绪状态)将无法继续。唤醒的线程将以普通的方式与可能正在竞争同步此对象的任何其他线程
     * 竞争; 例如，唤醒线程在成为锁定此对象的下一个线程时没有可靠的特权或劣势。
     * 这个方法只能被对象的所有者线程调用，线程以以下三种方式成为对象的所有者：
     *     1、通过执行该对象的同步实例方法
     *     2、通过执行该对象的同步代码块
     *     3、通过执行该对象的静态同步方法。
     *同一时刻只能有一个线程持有该对象的锁
</code></pre><h4 id="2-6、-wait-long-timeout-wait-long-timeout-int-nanos-wait"><a href="#2-6、-wait-long-timeout-wait-long-timeout-int-nanos-wait" class="headerlink" title="2.6、 wait(long timeout)/wait(long timeout, int nanos)/wait();"></a>2.6、 wait(long timeout)/wait(long timeout, int nanos)/wait();</h4><pre><code>     使当前线程进入等待状态，直至其他线程调用notify()或者notifyAll()方法，又或是达到指定时间
     *   当前线程必须持有该对象的锁。
     *   这个方法使得当前线程T 进入该对象的等待队列中，直到以下四件事情发生：
     *      1、有其他线程调用了notify()方法，且线程T正好被选为唤醒的线程
     *      2、有其他线程调用了notifyAll()方法
     *      3、其他线程调用了interrupt()方法中断线程T
     *      4、等待的时间超过了wait制定的时间。但是，如果&#123;@code timeout&#125;为零，则不考虑实时，线程只是等待其他线程唤醒。
     *   线程被唤醒后就从Object的等待集合中删除，并且能够被重新调度
     *   同时JDK中说明了线程可以在以上四种情况之外被唤醒，这种情况称为“伪唤醒”。
     *   解决方法是将判断条件放入while循环中：
     *              synchronized(obj)&#123;
     *                 while(condition)&#123; obj.wait(); &#125;
</code></pre><h3 id="3、其他方法"><a href="#3、其他方法" class="headerlink" title="3、其他方法"></a>3、其他方法</h3><h4 id="3-1、public-final-Class-lt-gt-getClass"><a href="#3-1、public-final-Class-lt-gt-getClass" class="headerlink" title="3.1、public final Class&lt;?&gt; getClass()"></a>3.1、public final Class&lt;?&gt; getClass()</h4><pre><code>    返回此对象运行时的类。返回的类对象是由static锁方法锁住的对象
</code></pre><h4 id="3-2、protected-void-finalize"><a href="#3-2、protected-void-finalize" class="headerlink" title="3.2、protected void finalize()"></a>3.2、protected void finalize()</h4><pre><code>    当GC（垃圾回收器）确定对象没有任何引用的时候，调用此方法。子类可以重写此方法来释放系统资源或进行其他的清理。
    JVM虚拟机不能确定哪个线程来调用对象的finalize()方法，但是能确定的是调用finalize()方法的线程不会阻塞用户线程。如果执行方法时抛出异常，则对应对象的finalize()方法终止执行。另外，每个对象都只会执行一次finalize()方法
</code></pre><h4 id="3-3、private-static-native-void-registerNatives"><a href="#3-3、private-static-native-void-registerNatives" class="headerlink" title="3.3、private static native void registerNatives()"></a>3.3、private static native void registerNatives()</h4><h3 id="三、重点知识点实例"><a href="#三、重点知识点实例" class="headerlink" title="三、重点知识点实例"></a>三、<em>重点知识点实例</em></h3><h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、<em>参考资料</em></h3><p><a href="https://blog.csdn.net/fendianli6830/article/details/81478538">https://blog.csdn.net/fendianli6830/article/details/81478538</a></p>
<p><a href="http://www.voidcn.com/article/p-amfilqsb-brv.html">http://www.voidcn.com/article/p-amfilqsb-brv.html</a></p>
<h3 id="五、思维扩展"><a href="#五、思维扩展" class="headerlink" title="五、思维扩展"></a>五、<em>思维扩展</em></h3><h3 id="六、存在疑问"><a href="#六、存在疑问" class="headerlink" title="六、存在疑问"></a>六、<em>存在疑问</em></h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/%E5%9F%BA%E7%A1%80_Linux%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xieshanzhong">
      <meta itemprop="description" content="欢迎来到xieshanzhong的技术分享站~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XIE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/06/%E5%9F%BA%E7%A1%80_Linux%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Linux学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-06 22:30:32" itemprop="dateCreated datePublished" datetime="2019-03-06T22:30:32+08:00">2019-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-03 16:46:51" itemprop="dateModified" datetime="2023-11-03T16:46:51+08:00">2023-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a>一、<em>思维导图</em></h2><h2 id="二、总知识点"><a href="#二、总知识点" class="headerlink" title="二、总知识点"></a>二、<em>总知识点</em></h2><h3 id="1、Linux系统的简介"><a href="#1、Linux系统的简介" class="headerlink" title="1、Linux系统的简介"></a>1、Linux系统的简介</h3><h3 id="2-1-Linux系统安装-VMware虚拟机安装与使用"><a href="#2-1-Linux系统安装-VMware虚拟机安装与使用" class="headerlink" title="2.1 Linux系统安装-VMware虚拟机安装与使用"></a>2.1 Linux系统安装-VMware虚拟机安装与使用</h3><h3 id="2-2-Linux系统安装-系统分区"><a href="#2-2-Linux系统安装-系统分区" class="headerlink" title="2.2 Linux系统安装-系统分区"></a>2.2 Linux系统安装-系统分区</h3><h3 id="2-3-Linux系统安装-Linux系统安装"><a href="#2-3-Linux系统安装-Linux系统安装" class="headerlink" title="2.3 Linux系统安装-Linux系统安装"></a>2.3 Linux系统安装-Linux系统安装</h3><h3 id="2-4-Linux系统安装-远程登录管理工具"><a href="#2-4-Linux系统安装-远程登录管理工具" class="headerlink" title="2.4 Linux系统安装-远程登录管理工具"></a>2.4 Linux系统安装-远程登录管理工具</h3><h3 id="3-1-给初学者的建议-注意事项"><a href="#3-1-给初学者的建议-注意事项" class="headerlink" title="3.1 给初学者的建议-注意事项"></a>3.1 给初学者的建议-注意事项</h3><h3 id="3-2-给初学者的建议-服务器管理和维护建议"><a href="#3-2-给初学者的建议-服务器管理和维护建议" class="headerlink" title="3.2 给初学者的建议-服务器管理和维护建议"></a>3.2 给初学者的建议-服务器管理和维护建议</h3><h3 id="4-1-1-Linux常用命令-文件处理命令-命令格式与目录处理命令ls"><a href="#4-1-1-Linux常用命令-文件处理命令-命令格式与目录处理命令ls" class="headerlink" title="4.1.1 Linux常用命令-文件处理命令-命令格式与目录处理命令ls"></a>4.1.1 Linux常用命令-文件处理命令-命令格式与目录处理命令ls</h3><h3 id="4-1-2-Linux常用命令-文件处理命令-目录处理命令"><a href="#4-1-2-Linux常用命令-文件处理命令-目录处理命令" class="headerlink" title="4.1.2 Linux常用命令-文件处理命令-目录处理命令"></a>4.1.2 Linux常用命令-文件处理命令-目录处理命令</h3><h3 id="4-1-3-Linux常用命令-文件处理命令-文件处理命令"><a href="#4-1-3-Linux常用命令-文件处理命令-文件处理命令" class="headerlink" title="4.1.3 Linux常用命令-文件处理命令-文件处理命令"></a>4.1.3 Linux常用命令-文件处理命令-文件处理命令</h3><h3 id="4-1-4-Linux常用命令-文件处理命令-链接命令"><a href="#4-1-4-Linux常用命令-文件处理命令-链接命令" class="headerlink" title="4.1.4 Linux常用命令-文件处理命令-链接命令"></a>4.1.4 Linux常用命令-文件处理命令-链接命令</h3><h3 id="4-2-1-Linux常用命令-权限管理命令-权限管理命令chmod"><a href="#4-2-1-Linux常用命令-权限管理命令-权限管理命令chmod" class="headerlink" title="4.2.1 Linux常用命令-权限管理命令-权限管理命令chmod"></a>4.2.1 Linux常用命令-权限管理命令-权限管理命令chmod</h3><h3 id="4-2-2-Linux常用命令-权限管理命令-其他权限管理命令"><a href="#4-2-2-Linux常用命令-权限管理命令-其他权限管理命令" class="headerlink" title="4.2.2 Linux常用命令-权限管理命令-其他权限管理命令"></a>4.2.2 Linux常用命令-权限管理命令-其他权限管理命令</h3><h3 id="4-3-1-Linux常用命令-文件搜索命令-文件搜索命令find"><a href="#4-3-1-Linux常用命令-文件搜索命令-文件搜索命令find" class="headerlink" title="4.3.1 Linux常用命令-文件搜索命令-文件搜索命令find"></a>4.3.1 Linux常用命令-文件搜索命令-文件搜索命令find</h3><h3 id="4-3-2-Linux常用命令-文件搜索命令-其他文件搜索命令"><a href="#4-3-2-Linux常用命令-文件搜索命令-其他文件搜索命令" class="headerlink" title="4.3.2 Linux常用命令-文件搜索命令-其他文件搜索命令"></a>4.3.2 Linux常用命令-文件搜索命令-其他文件搜索命令</h3><h3 id="4-4-Linux常用命令-帮助命令"><a href="#4-4-Linux常用命令-帮助命令" class="headerlink" title="4.4 Linux常用命令-帮助命令"></a>4.4 Linux常用命令-帮助命令</h3><h3 id="4-5-Linux常用命令-用户管理命令"><a href="#4-5-Linux常用命令-用户管理命令" class="headerlink" title="4.5 Linux常用命令-用户管理命令"></a>4.5 Linux常用命令-用户管理命令</h3><h3 id="4-6-Linux常用命令-压缩解压命令"><a href="#4-6-Linux常用命令-压缩解压命令" class="headerlink" title="4.6 Linux常用命令-压缩解压命令"></a>4.6 Linux常用命令-压缩解压命令</h3><h3 id="4-7-Linux常用命令-网络命令"><a href="#4-7-Linux常用命令-网络命令" class="headerlink" title="4.7 Linux常用命令-网络命令"></a>4.7 Linux常用命令-网络命令</h3><h3 id="4-8-Linux常用命令-关机重启命令"><a href="#4-8-Linux常用命令-关机重启命令" class="headerlink" title="4.8 Linux常用命令-关机重启命令"></a>4.8 Linux常用命令-关机重启命令</h3><h3 id="5-1-文本编辑器Vim-Vim常用操作"><a href="#5-1-文本编辑器Vim-Vim常用操作" class="headerlink" title="5.1 文本编辑器Vim-Vim常用操作"></a>5.1 文本编辑器Vim-Vim常用操作</h3><h3 id="5-2-文本编辑器Vim-Vim使用技巧"><a href="#5-2-文本编辑器Vim-Vim使用技巧" class="headerlink" title="5.2 文本编辑器Vim-Vim使用技巧"></a>5.2 文本编辑器Vim-Vim使用技巧</h3><h3 id="6-1-软件包管理简介"><a href="#6-1-软件包管理简介" class="headerlink" title="6.1 软件包管理简介"></a>6.1 软件包管理简介</h3><h3 id="6-2-RPM包管理-rpm命令管理"><a href="#6-2-RPM包管理-rpm命令管理" class="headerlink" title="6.2 RPM包管理-rpm命令管理"></a>6.2 RPM包管理-rpm命令管理</h3><h3 id="6-2-1-RPM包管理-rpm命令管理-包命名与依赖性"><a href="#6-2-1-RPM包管理-rpm命令管理-包命名与依赖性" class="headerlink" title="6.2.1 RPM包管理-rpm命令管理-包命名与依赖性"></a>6.2.1 RPM包管理-rpm命令管理-包命名与依赖性</h3><h3 id="6-2-2-RPM包管理-rpm命令管理-安装升级与卸载"><a href="#6-2-2-RPM包管理-rpm命令管理-安装升级与卸载" class="headerlink" title="6.2.2 RPM包管理-rpm命令管理-安装升级与卸载"></a>6.2.2 RPM包管理-rpm命令管理-安装升级与卸载</h3><h3 id="6-2-3-RPM包管理-rpm命令管理-RPM包查询"><a href="#6-2-3-RPM包管理-rpm命令管理-RPM包查询" class="headerlink" title="6.2.3 RPM包管理-rpm命令管理-RPM包查询"></a>6.2.3 RPM包管理-rpm命令管理-RPM包查询</h3><h3 id="6-2-4-RPM包管理-rpm命令管理-校验与文件提取"><a href="#6-2-4-RPM包管理-rpm命令管理-校验与文件提取" class="headerlink" title="6.2.4 RPM包管理-rpm命令管理-校验与文件提取"></a>6.2.4 RPM包管理-rpm命令管理-校验与文件提取</h3><h3 id="6-3-RPM包管理-yum在线管理"><a href="#6-3-RPM包管理-yum在线管理" class="headerlink" title="6.3 RPM包管理-yum在线管理"></a>6.3 RPM包管理-yum在线管理</h3><h3 id="6-3-1-RPM包管理-yum在线管理-IP地址配置和网络yum源"><a href="#6-3-1-RPM包管理-yum在线管理-IP地址配置和网络yum源" class="headerlink" title="6.3.1 RPM包管理-yum在线管理-IP地址配置和网络yum源"></a>6.3.1 RPM包管理-yum在线管理-IP地址配置和网络yum源</h3><h3 id="6-3-2-RPM包管理-yum在线管理-yum命令"><a href="#6-3-2-RPM包管理-yum在线管理-yum命令" class="headerlink" title="6.3.2 RPM包管理-yum在线管理-yum命令"></a>6.3.2 RPM包管理-yum在线管理-yum命令</h3><h3 id="6-3-3-RPM包管理-yum在线管理-光盘yum源"><a href="#6-3-3-RPM包管理-yum在线管理-光盘yum源" class="headerlink" title="6.3.3 RPM包管理-yum在线管理-光盘yum源"></a>6.3.3 RPM包管理-yum在线管理-光盘yum源</h3><h3 id="6-4-源码包管理"><a href="#6-4-源码包管理" class="headerlink" title="6.4 源码包管理"></a>6.4 源码包管理</h3><h3 id="6-4-1-源码包管理-源码包与RPM包的区别"><a href="#6-4-1-源码包管理-源码包与RPM包的区别" class="headerlink" title="6.4.1 源码包管理-源码包与RPM包的区别"></a>6.4.1 源码包管理-源码包与RPM包的区别</h3><h3 id="6-4-2-源码包管理-源码包安装过程"><a href="#6-4-2-源码包管理-源码包安装过程" class="headerlink" title="6.4.2 源码包管理-源码包安装过程"></a>6.4.2 源码包管理-源码包安装过程</h3><h3 id="6-5-脚本安装包"><a href="#6-5-脚本安装包" class="headerlink" title="6.5 脚本安装包"></a>6.5 脚本安装包</h3><h3 id="7-1-1-用户和用户组管理-用户配置文件-用户信息文件"><a href="#7-1-1-用户和用户组管理-用户配置文件-用户信息文件" class="headerlink" title="7.1.1 用户和用户组管理-用户配置文件-用户信息文件"></a>7.1.1 用户和用户组管理-用户配置文件-用户信息文件</h3><h3 id="7-1-2-用户和用户组管理-用户配置文件-影子文件"><a href="#7-1-2-用户和用户组管理-用户配置文件-影子文件" class="headerlink" title="7.1.2 用户和用户组管理-用户配置文件-影子文件"></a>7.1.2 用户和用户组管理-用户配置文件-影子文件</h3><h3 id="7-1-3-用户和用户组管理-用户配置文件-组信息文件"><a href="#7-1-3-用户和用户组管理-用户配置文件-组信息文件" class="headerlink" title="7.1.3 用户和用户组管理-用户配置文件-组信息文件"></a>7.1.3 用户和用户组管理-用户配置文件-组信息文件</h3><h3 id="7-2-用户和用户组管理-用户管理相关文件"><a href="#7-2-用户和用户组管理-用户管理相关文件" class="headerlink" title="7.2 用户和用户组管理-用户管理相关文件"></a>7.2 用户和用户组管理-用户管理相关文件</h3><h3 id="7-3-1-用户和用户组管理-用户管理命令-useradd"><a href="#7-3-1-用户和用户组管理-用户管理命令-useradd" class="headerlink" title="7.3.1 用户和用户组管理-用户管理命令-useradd"></a>7.3.1 用户和用户组管理-用户管理命令-useradd</h3><h3 id="7-3-2-用户和用户组管理-用户管理命令-passwd"><a href="#7-3-2-用户和用户组管理-用户管理命令-passwd" class="headerlink" title="7.3.2 用户和用户组管理-用户管理命令-passwd"></a>7.3.2 用户和用户组管理-用户管理命令-passwd</h3><h3 id="7-3-3-用户和用户组管理-用户管理命令-usermod和chage"><a href="#7-3-3-用户和用户组管理-用户管理命令-usermod和chage" class="headerlink" title="7.3.3 用户和用户组管理-用户管理命令-usermod和chage"></a>7.3.3 用户和用户组管理-用户管理命令-usermod和chage</h3><h3 id="7-3-4-用户和用户组管理-用户管理命令-userdel和su"><a href="#7-3-4-用户和用户组管理-用户管理命令-userdel和su" class="headerlink" title="7.3.4 用户和用户组管理-用户管理命令-userdel和su"></a>7.3.4 用户和用户组管理-用户管理命令-userdel和su</h3><h3 id="7-4-用户和用户组管理-用户组管理命令"><a href="#7-4-用户和用户组管理-用户组管理命令" class="headerlink" title="7.4 用户和用户组管理-用户组管理命令"></a>7.4 用户和用户组管理-用户组管理命令</h3><h3 id="8-1-1-权限管理-ACL权限-简介与开启"><a href="#8-1-1-权限管理-ACL权限-简介与开启" class="headerlink" title="8.1.1 权限管理-ACL权限-简介与开启"></a>8.1.1 权限管理-ACL权限-简介与开启</h3><h3 id="8-1-2-权限管理-ACL权限-查看与设定"><a href="#8-1-2-权限管理-ACL权限-查看与设定" class="headerlink" title="8.1.2 权限管理-ACL权限-查看与设定"></a>8.1.2 权限管理-ACL权限-查看与设定</h3><h3 id="8-1-3-权限管理-ACL权限-最大有效权限与删除"><a href="#8-1-3-权限管理-ACL权限-最大有效权限与删除" class="headerlink" title="8.1.3 权限管理-ACL权限-最大有效权限与删除"></a>8.1.3 权限管理-ACL权限-最大有效权限与删除</h3><h3 id="8-1-4-权限管理-ACL权限-默认与递归ACL权限"><a href="#8-1-4-权限管理-ACL权限-默认与递归ACL权限" class="headerlink" title="8.1.4 权限管理-ACL权限-默认与递归ACL权限"></a>8.1.4 权限管理-ACL权限-默认与递归ACL权限</h3><h3 id="8-2-1-权限管理-文件特殊权限-SetUID"><a href="#8-2-1-权限管理-文件特殊权限-SetUID" class="headerlink" title="8.2.1 权限管理-文件特殊权限-SetUID"></a>8.2.1 权限管理-文件特殊权限-SetUID</h3><h3 id="8-2-2-权限管理-文件特殊权限-SetGID"><a href="#8-2-2-权限管理-文件特殊权限-SetGID" class="headerlink" title="8.2.2 权限管理-文件特殊权限-SetGID"></a>8.2.2 权限管理-文件特殊权限-SetGID</h3><h3 id="8-2-3-权限管理-文件特殊权限-Sticky-BIT"><a href="#8-2-3-权限管理-文件特殊权限-Sticky-BIT" class="headerlink" title="8.2.3 权限管理-文件特殊权限-Sticky BIT"></a>8.2.3 权限管理-文件特殊权限-Sticky BIT</h3><h3 id="8-3-权限管理-chattr权限"><a href="#8-3-权限管理-chattr权限" class="headerlink" title="8.3 权限管理-chattr权限"></a>8.3 权限管理-chattr权限</h3><h3 id="8-4-权限管理-sudo权限"><a href="#8-4-权限管理-sudo权限" class="headerlink" title="8.4 权限管理-sudo权限"></a>8.4 权限管理-sudo权限</h3><h3 id="9-1-文件系统管理-回顾分区和文件系统"><a href="#9-1-文件系统管理-回顾分区和文件系统" class="headerlink" title="9.1 文件系统管理-回顾分区和文件系统"></a>9.1 文件系统管理-回顾分区和文件系统</h3><h3 id="9-2-1-文件系统管理-文件系统常用命令-df、du、fsck、dumpe2fs"><a href="#9-2-1-文件系统管理-文件系统常用命令-df、du、fsck、dumpe2fs" class="headerlink" title="9.2.1 文件系统管理-文件系统常用命令-df、du、fsck、dumpe2fs"></a>9.2.1 文件系统管理-文件系统常用命令-df、du、fsck、dumpe2fs</h3><h3 id="9-2-2-文件系统管理-文件系统常用命令-挂载命令"><a href="#9-2-2-文件系统管理-文件系统常用命令-挂载命令" class="headerlink" title="9.2.2 文件系统管理-文件系统常用命令-挂载命令"></a>9.2.2 文件系统管理-文件系统常用命令-挂载命令</h3><h3 id="9-2-3-文件系统管理-文件系统常用命令-挂载光盘与U盘"><a href="#9-2-3-文件系统管理-文件系统常用命令-挂载光盘与U盘" class="headerlink" title="9.2.3 文件系统管理-文件系统常用命令-挂载光盘与U盘"></a>9.2.3 文件系统管理-文件系统常用命令-挂载光盘与U盘</h3><h3 id="9-2-4-文件系统管理-文件系统常用命令-支持NTFS文件系统"><a href="#9-2-4-文件系统管理-文件系统常用命令-支持NTFS文件系统" class="headerlink" title="9.2.4 文件系统管理-文件系统常用命令-支持NTFS文件系统"></a>9.2.4 文件系统管理-文件系统常用命令-支持NTFS文件系统</h3><h3 id="9-3-1-文件系统管理-fdisk分区-分区过程"><a href="#9-3-1-文件系统管理-fdisk分区-分区过程" class="headerlink" title="9.3.1 文件系统管理-fdisk分区-分区过程"></a>9.3.1 文件系统管理-fdisk分区-分区过程</h3><h3 id="9-3-2-文件系统管理-fdisk分区-自动挂载与fstab文件修复"><a href="#9-3-2-文件系统管理-fdisk分区-自动挂载与fstab文件修复" class="headerlink" title="9.3.2 文件系统管理-fdisk分区-自动挂载与fstab文件修复"></a>9.3.2 文件系统管理-fdisk分区-自动挂载与fstab文件修复</h3><h3 id="9-4-文件系统管理-分配swap分区"><a href="#9-4-文件系统管理-分配swap分区" class="headerlink" title="9.4 文件系统管理-分配swap分区"></a>9.4 文件系统管理-分配swap分区</h3><h3 id="10-1-Shell基础-概述"><a href="#10-1-Shell基础-概述" class="headerlink" title="10.1 Shell基础-概述"></a>10.1 Shell基础-概述</h3><h3 id="10-2-Shell基础-脚本执行方式"><a href="#10-2-Shell基础-脚本执行方式" class="headerlink" title="10.2 Shell基础-脚本执行方式"></a>10.2 Shell基础-脚本执行方式</h3><h3 id="10-3-1-Shell基础-Bash基本功能-历史命令与补全"><a href="#10-3-1-Shell基础-Bash基本功能-历史命令与补全" class="headerlink" title="10.3.1 Shell基础-Bash基本功能-历史命令与补全"></a>10.3.1 Shell基础-Bash基本功能-历史命令与补全</h3><h3 id="10-3-2-Shell基础-Bash基本功能-别名与快捷键"><a href="#10-3-2-Shell基础-Bash基本功能-别名与快捷键" class="headerlink" title="10.3.2 Shell基础-Bash基本功能-别名与快捷键"></a>10.3.2 Shell基础-Bash基本功能-别名与快捷键</h3><h3 id="10-3-3-Shell基础-Bash基本功能-输入输出重定向"><a href="#10-3-3-Shell基础-Bash基本功能-输入输出重定向" class="headerlink" title="10.3.3 Shell基础-Bash基本功能-输入输出重定向"></a>10.3.3 Shell基础-Bash基本功能-输入输出重定向</h3><h3 id="10-3-4-Shell基础-Bash基本功能-多命令顺序执行与管道符"><a href="#10-3-4-Shell基础-Bash基本功能-多命令顺序执行与管道符" class="headerlink" title="10.3.4 Shell基础-Bash基本功能-多命令顺序执行与管道符"></a>10.3.4 Shell基础-Bash基本功能-多命令顺序执行与管道符</h3><h3 id="10-3-5-Shell基础-Bash基本功能-通配符和其他特殊符号"><a href="#10-3-5-Shell基础-Bash基本功能-通配符和其他特殊符号" class="headerlink" title="10.3.5 Shell基础-Bash基本功能-通配符和其他特殊符号"></a>10.3.5 Shell基础-Bash基本功能-通配符和其他特殊符号</h3><h3 id="10-4-1-Shell基础-Bash变量-用户自定义变量"><a href="#10-4-1-Shell基础-Bash变量-用户自定义变量" class="headerlink" title="10.4.1 Shell基础-Bash变量-用户自定义变量"></a>10.4.1 Shell基础-Bash变量-用户自定义变量</h3><h3 id="10-4-2-Shell基础-Bash变量-环境变量"><a href="#10-4-2-Shell基础-Bash变量-环境变量" class="headerlink" title="10.4.2 Shell基础-Bash变量-环境变量"></a>10.4.2 Shell基础-Bash变量-环境变量</h3><h3 id="10-4-3-Shell基础-Bash变量-位置参数变量"><a href="#10-4-3-Shell基础-Bash变量-位置参数变量" class="headerlink" title="10.4.3 Shell基础-Bash变量-位置参数变量"></a>10.4.3 Shell基础-Bash变量-位置参数变量</h3><h3 id="10-4-4-Shell基础-Bash变量-预定义变量"><a href="#10-4-4-Shell基础-Bash变量-预定义变量" class="headerlink" title="10.4.4 Shell基础-Bash变量-预定义变量"></a>10.4.4 Shell基础-Bash变量-预定义变量</h3><h3 id="10-5-1-Shell基础-Bash变量-数值运算与运算符"><a href="#10-5-1-Shell基础-Bash变量-数值运算与运算符" class="headerlink" title="10.5.1 Shell基础-Bash变量-数值运算与运算符"></a>10.5.1 Shell基础-Bash变量-数值运算与运算符</h3><h3 id="10-5-2-Shell基础-Bash变量-变量测试与内容替换"><a href="#10-5-2-Shell基础-Bash变量-变量测试与内容替换" class="headerlink" title="10.5.2 Shell基础-Bash变量-变量测试与内容替换"></a>10.5.2 Shell基础-Bash变量-变量测试与内容替换</h3><h3 id="10-6-1-Shell基础-环境变量配置文件-简介"><a href="#10-6-1-Shell基础-环境变量配置文件-简介" class="headerlink" title="10.6.1 Shell基础-环境变量配置文件-简介"></a>10.6.1 Shell基础-环境变量配置文件-简介</h3><h3 id="10-6-2-Shell基础-环境变量配置文件-作用"><a href="#10-6-2-Shell基础-环境变量配置文件-作用" class="headerlink" title="10.6.2 Shell基础-环境变量配置文件-作用"></a>10.6.2 Shell基础-环境变量配置文件-作用</h3><h3 id="10-6-3-Shell基础-环境变量配置文件-其他配置文件和登录信息"><a href="#10-6-3-Shell基础-环境变量配置文件-其他配置文件和登录信息" class="headerlink" title="10.6.3 Shell基础-环境变量配置文件-其他配置文件和登录信息"></a>10.6.3 Shell基础-环境变量配置文件-其他配置文件和登录信息</h3><h3 id="11-1-Shell编程-正则表达式"><a href="#11-1-Shell编程-正则表达式" class="headerlink" title="11.1 Shell编程-正则表达式"></a>11.1 Shell编程-正则表达式</h3><h3 id="11-2-1-Shell编程-字符截取命令-cut命令"><a href="#11-2-1-Shell编程-字符截取命令-cut命令" class="headerlink" title="11.2.1 Shell编程-字符截取命令-cut命令"></a>11.2.1 Shell编程-字符截取命令-cut命令</h3><h3 id="11-2-2-Shell编程-字符截取命令-printf命令"><a href="#11-2-2-Shell编程-字符截取命令-printf命令" class="headerlink" title="11.2.2 Shell编程-字符截取命令-printf命令"></a>11.2.2 Shell编程-字符截取命令-printf命令</h3><h3 id="11-2-3-Shell编程-字符截取命令-awk命令"><a href="#11-2-3-Shell编程-字符截取命令-awk命令" class="headerlink" title="11.2.3 Shell编程-字符截取命令-awk命令"></a>11.2.3 Shell编程-字符截取命令-awk命令</h3><h3 id="11-2-4-Shell编程-字符截取命令-sed命令"><a href="#11-2-4-Shell编程-字符截取命令-sed命令" class="headerlink" title="11.2.4 Shell编程-字符截取命令-sed命令"></a>11.2.4 Shell编程-字符截取命令-sed命令</h3><h3 id="11-3-Shell编程-字符处理命令"><a href="#11-3-Shell编程-字符处理命令" class="headerlink" title="11.3 Shell编程-字符处理命令"></a>11.3 Shell编程-字符处理命令</h3><h3 id="11-4-Shell编程-条件判断"><a href="#11-4-Shell编程-条件判断" class="headerlink" title="11.4 Shell编程-条件判断"></a>11.4 Shell编程-条件判断</h3><h3 id="11-5-1-Shell编程-流程控制-if语句"><a href="#11-5-1-Shell编程-流程控制-if语句" class="headerlink" title="11.5.1 Shell编程-流程控制-if语句"></a>11.5.1 Shell编程-流程控制-if语句</h3><h3 id="11-5-2-Shell编程-流程控制-case语句"><a href="#11-5-2-Shell编程-流程控制-case语句" class="headerlink" title="11.5.2 Shell编程-流程控制-case语句"></a>11.5.2 Shell编程-流程控制-case语句</h3><h3 id="11-5-3-Shell编程-流程控制-for循环"><a href="#11-5-3-Shell编程-流程控制-for循环" class="headerlink" title="11.5.3 Shell编程-流程控制-for循环"></a>11.5.3 Shell编程-流程控制-for循环</h3><h3 id="11-5-4-Shell编程-流程控制-while循环与until循环"><a href="#11-5-4-Shell编程-流程控制-while循环与until循环" class="headerlink" title="11.5.4 Shell编程-流程控制-while循环与until循环"></a>11.5.4 Shell编程-流程控制-while循环与until循环</h3><h3 id="12-1-Linux服务管理-服务分类"><a href="#12-1-Linux服务管理-服务分类" class="headerlink" title="12.1 Linux服务管理-服务分类"></a>12.1 Linux服务管理-服务分类</h3><h3 id="12-2-1-Linux服务管理-RPM服务的管理-独立服务管理"><a href="#12-2-1-Linux服务管理-RPM服务的管理-独立服务管理" class="headerlink" title="12.2.1 Linux服务管理-RPM服务的管理-独立服务管理"></a>12.2.1 Linux服务管理-RPM服务的管理-独立服务管理</h3><h3 id="12-2-2-Linux服务管理-RPM服务的管理-基于xinetd服务管理"><a href="#12-2-2-Linux服务管理-RPM服务的管理-基于xinetd服务管理" class="headerlink" title="12.2.2 Linux服务管理-RPM服务的管理-基于xinetd服务管理"></a>12.2.2 Linux服务管理-RPM服务的管理-基于xinetd服务管理</h3><h3 id="12-3-Linux服务管理-源码包服务的管理"><a href="#12-3-Linux服务管理-源码包服务的管理" class="headerlink" title="12.3 Linux服务管理-源码包服务的管理"></a>12.3 Linux服务管理-源码包服务的管理</h3><h3 id="12-4-Linux服务管理-服务管理总结"><a href="#12-4-Linux服务管理-服务管理总结" class="headerlink" title="12.4 Linux服务管理-服务管理总结"></a>12.4 Linux服务管理-服务管理总结</h3><h3 id="13-1-1-Linux系统管理-进程管理-进程查看"><a href="#13-1-1-Linux系统管理-进程管理-进程查看" class="headerlink" title="13.1.1 Linux系统管理-进程管理-进程查看"></a>13.1.1 Linux系统管理-进程管理-进程查看</h3><h3 id="13-1-2-Linux系统管理-进程管理-终止进程"><a href="#13-1-2-Linux系统管理-进程管理-终止进程" class="headerlink" title="13.1.2 Linux系统管理-进程管理-终止进程"></a>13.1.2 Linux系统管理-进程管理-终止进程</h3><h3 id="13-2-Linux系统管理-工作管理"><a href="#13-2-Linux系统管理-工作管理" class="headerlink" title="13.2 Linux系统管理-工作管理"></a>13.2 Linux系统管理-工作管理</h3><h3 id="13-3-Linux系统管理-系统资源查看"><a href="#13-3-Linux系统管理-系统资源查看" class="headerlink" title="13.3 Linux系统管理-系统资源查看"></a>13.3 Linux系统管理-系统资源查看</h3><h3 id="13-4-Linux系统管理-系统定时任务"><a href="#13-4-Linux系统管理-系统定时任务" class="headerlink" title="13.4 Linux系统管理-系统定时任务"></a>13.4 Linux系统管理-系统定时任务</h3><h3 id="14-1-日志管理-简介"><a href="#14-1-日志管理-简介" class="headerlink" title="14.1 日志管理-简介"></a>14.1 日志管理-简介</h3><h3 id="14-2-日志管理-rsyslogd服务"><a href="#14-2-日志管理-rsyslogd服务" class="headerlink" title="14.2 日志管理-rsyslogd服务"></a>14.2 日志管理-rsyslogd服务</h3><h3 id="14-3-日志管理-日志轮替"><a href="#14-3-日志管理-日志轮替" class="headerlink" title="14.3 日志管理-日志轮替"></a>14.3 日志管理-日志轮替</h3><h3 id="15-1-1-启动管理-启动流程-运行级别"><a href="#15-1-1-启动管理-启动流程-运行级别" class="headerlink" title="15.1.1 启动管理-启动流程-运行级别"></a>15.1.1 启动管理-启动流程-运行级别</h3><h3 id="15-1-2-启动管理-启动流程-启动过程"><a href="#15-1-2-启动管理-启动流程-启动过程" class="headerlink" title="15.1.2 启动管理-启动流程-启动过程"></a>15.1.2 启动管理-启动流程-启动过程</h3><h3 id="15-2-1-启动管理-启动引导程序-Grub配置文件"><a href="#15-2-1-启动管理-启动引导程序-Grub配置文件" class="headerlink" title="15.2.1 启动管理-启动引导程序-Grub配置文件"></a>15.2.1 启动管理-启动引导程序-Grub配置文件</h3><h3 id="15-2-2-启动管理-启动引导程序-Grub加密"><a href="#15-2-2-启动管理-启动引导程序-Grub加密" class="headerlink" title="15.2.2 启动管理-启动引导程序-Grub加密"></a>15.2.2 启动管理-启动引导程序-Grub加密</h3><h3 id="15-3-启动管理-系统修复模式"><a href="#15-3-启动管理-系统修复模式" class="headerlink" title="15.3 启动管理-系统修复模式"></a>15.3 启动管理-系统修复模式</h3><h3 id="16-1-备份与恢复-概述"><a href="#16-1-备份与恢复-概述" class="headerlink" title="16.1 备份与恢复-概述"></a>16.1 备份与恢复-概述</h3><h3 id="16-2-备份与恢复-备份命令"><a href="#16-2-备份与恢复-备份命令" class="headerlink" title="16.2 备份与恢复-备份命令"></a>16.2 备份与恢复-备份命令</h3><h2 id="三、重点知识点实例"><a href="#三、重点知识点实例" class="headerlink" title="三、重点知识点实例"></a>三、<em>重点知识点实例</em></h2><h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、<em>参考资料</em></h2><h2 id="五、思维扩展"><a href="#五、思维扩展" class="headerlink" title="五、思维扩展"></a>五、<em>思维扩展</em></h2><h2 id="六、存在疑问"><a href="#六、存在疑问" class="headerlink" title="六、存在疑问"></a>六、<em>存在疑问</em></h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/%E5%B8%B8%E7%94%A8IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xieshanzhong">
      <meta itemprop="description" content="欢迎来到xieshanzhong的技术分享站~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XIE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/21/%E5%B8%B8%E7%94%A8IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">常用IDEA快捷键使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-21 17:17:59" itemprop="dateCreated datePublished" datetime="2018-12-21T17:17:59+08:00">2018-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-03 16:46:51" itemprop="dateModified" datetime="2023-11-03T16:46:51+08:00">2023-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>IntelliJ IDEA 常用快捷键整理</p>
<h5 id="1、代码结构优化"><a href="#1、代码结构优化" class="headerlink" title="1、代码结构优化"></a>1、代码结构优化</h5><p>Ctrl+Alt+L：格式化代码<br>Ctrl+Alt+I：将选中的代码进行自动缩进编排，这个功能在编辑JSP文件时也可以工作</p>
<p>Ctrl+Alt+O：优化导入的类和包(去掉无用的import语句)</p>
<p>Ctrl+/或Ctrl+Shift+/：注释(//或者/**/)</p>
<p>Ctrl+Shift+J：两行合成一行，删去不必要的空格匹配代码格式</p>
<h5 id="2、跳转定位"><a href="#2、跳转定位" class="headerlink" title="2、跳转定位"></a>2、跳转定位</h5><p>Ctrl+Alt+B：跳转到方法实现处<br>Ctrl+B：快速打开光标处的类或方法</p>
<p>Ctrl+Alt+left/right(左右箭头)：返回至上次浏览的位置<br>Ctrl+Shift+Backspace：跳转到上次编辑的地方</p>
<p>F2/Shift+F2：高亮错误或警告快速定位(跳转至报错的位置)<br>Ctrl+G：定位行(跳到输入的指定行数)</p>
<p>Alt+ Up/Down(上下箭头)：在方法间快速移动定位<br>Ctrl+[ OR ]：可以跑到大括号的开头与结尾(方便if或者方法范围查看)</p>
<p>Alt+F3：逐个往下查找相同文本，并高亮显示</p>
<h5 id="3、查找定位"><a href="#3、查找定位" class="headerlink" title="3、查找定位"></a>3、查找定位</h5><p>Ctrl+N：可以快速打开类<br>Ctrl+Shift+N：可以快速打开文件<br>Ctrl+Shift+Alt+N：查找类中的方法或变量</p>
<p>Ctrl+F：查找(本文件中查找)<br>Ctrl+Shift+F：全局查找(在路径中查找)<br>Shift+Shift：全局搜索</p>
<h5 id="4、代码操作"><a href="#4、代码操作" class="headerlink" title="4、代码操作"></a>4、代码操作</h5><p>Ctrl+W：选中代码，连续按会有其他效果(选中范围越来越大)<br>Ctrl+R：在本文件替换文本<br>Ctrl+Shift+R：在路径中替换(整个路径替换)<br>Ctrl+X：删除行<br>Ctrl+D：复制行<br>Ctrl+Y：删除当前行</p>
<p>Alt+Shift+Up/Down：上/下移一行<br>Ctrl+Shift+U：大小写转化</p>
<p>Ctrl+Shift+Z：重做，即反撤销(与搜狗输入法查看字符冲突)<br>Ctrl+Shift+V：查看最近复制的多条内容，并选择需要的内容粘贴</p>
<h5 id="5、代码-方法-生成"><a href="#5、代码-方法-生成" class="headerlink" title="5、代码(方法)生成"></a>5、代码(方法)生成</h5><p>psvm/sout：main函数/System.out.println();快捷键(Ctrl+J，查看更多)</p>
<p>Alt+Insert：可以生成构造器/Getter/Setter等(建议使用lombok插件及@Data注解)</p>
<p>Ctrl+Alt+T：可以把代码包在一个块内，例如：try/catch<br>Ctrl+shift+回车：自动补全、换行<br>Ctrl+空格，代码提示（与系统输入法快捷键冲突）</p>
<h5 id="6、其他"><a href="#6、其他" class="headerlink" title="6、其他"></a>6、其他</h5><p>提示</p>
<p>Alt+F7：查找整个工程中使用地某一个类、方法或者变量的位置<br>Ctrl+F7：可以查询当前元素在当前文件中的引用，然后按 F3 可以选择<br>Ctrl+Shift+F7：高亮显示所有该文本，按 Esc 高亮消失</p>
<p>Ctrl+P：可以显示参数信息<br>Ctrl+F12：可以显示当前文件的结构<br>Ctrl+H：显示类结构图（类的继承层次）</p>
<p>代码结构</p>
<p>Alt+6：查看所有TODO<br>Alt+7：查看本类结构</p>
<p>Ctrl+”+/-“：当前方法展开、折叠<br>Ctrl+Shift+”+/-：全部展开、折叠</p>
<p>文件操作<br>Ctrl+E：显示最近操作过的文件Alt+Shift+C：显示最近的更改操作</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a><em>分类</em></h3><h5 id="1、Ctrl："><a href="#1、Ctrl：" class="headerlink" title="1、Ctrl："></a>1、Ctrl：</h5><h6 id="Ctrl-J-插入自定义动态代码模板"><a href="#Ctrl-J-插入自定义动态代码模板" class="headerlink" title="Ctrl + J    插入自定义动态代码模板"></a>Ctrl + J    插入自定义动态代码模板</h6><h6 id="Ctrl-F1-在光标所在的错误代码处显示错误信息"><a href="#Ctrl-F1-在光标所在的错误代码处显示错误信息" class="headerlink" title="Ctrl + F1  在光标所在的错误代码处显示错误信息"></a>Ctrl + F1  在光标所在的错误代码处显示错误信息</h6><h6 id="Ctrl-F3-调转到所选中的词的下一个引用位置"><a href="#Ctrl-F3-调转到所选中的词的下一个引用位置" class="headerlink" title="Ctrl + F3  调转到所选中的词的下一个引用位置"></a>Ctrl + F3  调转到所选中的词的下一个引用位置</h6><h6 id="Ctrl-F11-选中文件-文件夹，使用助记符设定-取消书签"><a href="#Ctrl-F11-选中文件-文件夹，使用助记符设定-取消书签" class="headerlink" title="Ctrl + F11  选中文件 / 文件夹，使用助记符设定 / 取消书签"></a>Ctrl + F11  选中文件 / 文件夹，使用助记符设定 / 取消书签</h6><h6 id="Ctrl-Delete-删除光标后面的单词或是中文句"><a href="#Ctrl-Delete-删除光标后面的单词或是中文句" class="headerlink" title="Ctrl + Delete  删除光标后面的单词或是中文句"></a>Ctrl + Delete  删除光标后面的单词或是中文句</h6><h6 id="Ctrl-BackSpace-删除光标前面的单词或是中文句"><a href="#Ctrl-BackSpace-删除光标前面的单词或是中文句" class="headerlink" title="Ctrl + BackSpace 删除光标前面的单词或是中文句"></a>Ctrl + BackSpace 删除光标前面的单词或是中文句</h6><h6 id="Ctrl-左键单击-在打开的文件标题上，弹出该文件路径"><a href="#Ctrl-左键单击-在打开的文件标题上，弹出该文件路径" class="headerlink" title="Ctrl + 左键单击  在打开的文件标题上，弹出该文件路径"></a>Ctrl + 左键单击  在打开的文件标题上，弹出该文件路径</h6><h6 id="Ctrl-左方向键光标跳转到当前单词-中文句的左侧开头位置-（必备）"><a href="#Ctrl-左方向键光标跳转到当前单词-中文句的左侧开头位置-（必备）" class="headerlink" title="Ctrl + 左方向键光标跳转到当前单词 / 中文句的左侧开头位置 （必备）"></a>Ctrl + 左方向键光标跳转到当前单词 / 中文句的左侧开头位置 （必备）</h6><h6 id="Ctrl-右方向键光标跳转到当前单词-中文句的右侧开头位置-（必备）"><a href="#Ctrl-右方向键光标跳转到当前单词-中文句的右侧开头位置-（必备）" class="headerlink" title="Ctrl + 右方向键光标跳转到当前单词 / 中文句的右侧开头位置 （必备）"></a>Ctrl + 右方向键光标跳转到当前单词 / 中文句的右侧开头位置 （必备）</h6><h6 id="Ctrl-前方向键等效于鼠标滚轮向前效果-（必备）"><a href="#Ctrl-前方向键等效于鼠标滚轮向前效果-（必备）" class="headerlink" title="Ctrl + 前方向键等效于鼠标滚轮向前效果 （必备）"></a>Ctrl + 前方向键等效于鼠标滚轮向前效果 （必备）</h6><h6 id="Ctrl-后方向键等效于鼠标滚轮向后效果-（必备"><a href="#Ctrl-后方向键等效于鼠标滚轮向后效果-（必备" class="headerlink" title="Ctrl + 后方向键等效于鼠标滚轮向后效果 （必备"></a>Ctrl + 后方向键等效于鼠标滚轮向后效果 （必备</h6><h5 id="2、Alt："><a href="#2、Alt：" class="headerlink" title="2、Alt："></a>2、Alt：</h5><h6 id="Alt-F1显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择-（必备）"><a href="#Alt-F1显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择-（必备）" class="headerlink" title="Alt + F1显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 （必备）"></a>Alt + F1显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 （必备）</h6><h6 id="Alt-显示版本控制常用操作菜单弹出层-（必备）"><a href="#Alt-显示版本控制常用操作菜单弹出层-（必备）" class="headerlink" title="Alt + `|显示版本控制常用操作菜单弹出层 （必备）"></a>Alt + `|显示版本控制常用操作菜单弹出层 （必备）</h6><h6 id="Alt-Enter-IntelliJ-IDEA-根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同-（必备）"><a href="#Alt-Enter-IntelliJ-IDEA-根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同-（必备）" class="headerlink" title="Alt + Enter  IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备）"></a>Alt + Enter  IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备）</h6><h5 id="3、Shift"><a href="#3、Shift" class="headerlink" title="3、Shift:"></a>3、Shift:</h5><h6 id="Shift-F11弹出书签显示层-（必备）"><a href="#Shift-F11弹出书签显示层-（必备）" class="headerlink" title="Shift + F11弹出书签显示层 （必备）"></a>Shift + F11弹出书签显示层 （必备）</h6><h6 id="Shift-Tab取消缩进-（必备）"><a href="#Shift-Tab取消缩进-（必备）" class="headerlink" title="Shift + Tab取消缩进 （必备）"></a>Shift + Tab取消缩进 （必备）</h6><h6 id="Shift-左键单击在打开的文件名上按此快捷键，可以关闭当前打开文件-（必备）"><a href="#Shift-左键单击在打开的文件名上按此快捷键，可以关闭当前打开文件-（必备）" class="headerlink" title="Shift + 左键单击在打开的文件名上按此快捷键，可以关闭当前打开文件 （必备）"></a>Shift + 左键单击在打开的文件名上按此快捷键，可以关闭当前打开文件 （必备）</h6><h6 id="Shift-滚轮前后滚动当前文件的横向滚动轴滚动-（必备）"><a href="#Shift-滚轮前后滚动当前文件的横向滚动轴滚动-（必备）" class="headerlink" title="Shift + 滚轮前后滚动当前文件的横向滚动轴滚动 （必备）"></a>Shift + 滚轮前后滚动当前文件的横向滚动轴滚动 （必备）</h6><h5 id="4、Ctrl-Alt"><a href="#4、Ctrl-Alt" class="headerlink" title="4、Ctrl + Alt:"></a>4、Ctrl + Alt:</h5><h6 id="Ctrl-Alt-L格式化代码，可以对当前文件和整个包目录使用-（必备）"><a href="#Ctrl-Alt-L格式化代码，可以对当前文件和整个包目录使用-（必备）" class="headerlink" title="Ctrl + Alt + L格式化代码，可以对当前文件和整个包目录使用 （必备）"></a>Ctrl + Alt + L格式化代码，可以对当前文件和整个包目录使用 （必备）</h6><h6 id="Ctrl-Alt-O优化导入的类，可以对当前文件和整个包目录使用-（必备）"><a href="#Ctrl-Alt-O优化导入的类，可以对当前文件和整个包目录使用-（必备）" class="headerlink" title="Ctrl + Alt + O优化导入的类，可以对当前文件和整个包目录使用 （必备）"></a>Ctrl + Alt + O优化导入的类，可以对当前文件和整个包目录使用 （必备）</h6><h6 id="Ctrl-Alt-T对选中的代码弹出环绕选项弹出层-（必备）"><a href="#Ctrl-Alt-T对选中的代码弹出环绕选项弹出层-（必备）" class="headerlink" title="Ctrl + Alt + T对选中的代码弹出环绕选项弹出层 （必备）"></a>Ctrl + Alt + T对选中的代码弹出环绕选项弹出层 （必备）</h6><h6 id="Ctrl-Alt-S打开-IntelliJ-IDEA-系统设置-（必备）"><a href="#Ctrl-Alt-S打开-IntelliJ-IDEA-系统设置-（必备）" class="headerlink" title="Ctrl + Alt + S打开 IntelliJ IDEA 系统设置 （必备）"></a>Ctrl + Alt + S打开 IntelliJ IDEA 系统设置 （必备）</h6><h6 id="Ctrl-Alt-左方向键退回到上一个操作的地方-（必备）"><a href="#Ctrl-Alt-左方向键退回到上一个操作的地方-（必备）" class="headerlink" title="Ctrl + Alt + 左方向键退回到上一个操作的地方 （必备）"></a>Ctrl + Alt + 左方向键退回到上一个操作的地方 （必备）</h6><h6 id="Ctrl-Alt-右方向键前进到上一个操作的地方-（必备）"><a href="#Ctrl-Alt-右方向键前进到上一个操作的地方-（必备）" class="headerlink" title="Ctrl + Alt + 右方向键前进到上一个操作的地方 （必备）"></a>Ctrl + Alt + 右方向键前进到上一个操作的地方 （必备）</h6><h5 id="5、Ctrl-Shift"><a href="#5、Ctrl-Shift" class="headerlink" title="5、Ctrl + Shift:"></a>5、Ctrl + Shift:</h5><h6 id="Ctrl-Shift-J自动将下一行合并到当前行末尾-（必备）"><a href="#Ctrl-Shift-J自动将下一行合并到当前行末尾-（必备）" class="headerlink" title="Ctrl + Shift + J自动将下一行合并到当前行末尾 （必备）"></a>Ctrl + Shift + J自动将下一行合并到当前行末尾 （必备）</h6><h6 id="Ctrl-Shift-W递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围-（必备）"><a href="#Ctrl-Shift-W递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围-（必备）" class="headerlink" title="Ctrl + Shift + W递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）"></a>Ctrl + Shift + W递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）</h6><h6 id="Ctrl-Shift-N通过文件名定位-打开文件-目录，打开目录需要在输入的内容后面多加一个正斜杠-（必备）"><a href="#Ctrl-Shift-N通过文件名定位-打开文件-目录，打开目录需要在输入的内容后面多加一个正斜杠-（必备）" class="headerlink" title="Ctrl + Shift + N通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）"></a>Ctrl + Shift + N通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）</h6><h6 id="Ctrl-Shift-U对选中的代码进行大-小写轮流转换-（必备）"><a href="#Ctrl-Shift-U对选中的代码进行大-小写轮流转换-（必备）" class="headerlink" title="Ctrl + Shift + U对选中的代码进行大 / 小写轮流转换 （必备）"></a>Ctrl + Shift + U对选中的代码进行大 / 小写轮流转换 （必备）</h6><h6 id="Ctrl-Shift-T对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择-（必备）"><a href="#Ctrl-Shift-T对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择-（必备）" class="headerlink" title="Ctrl + Shift + T对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 （必备）"></a>Ctrl + Shift + T对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 （必备）</h6><h6 id="Ctrl-Shift-C复制当前文件磁盘路径到剪贴板-（必备）"><a href="#Ctrl-Shift-C复制当前文件磁盘路径到剪贴板-（必备）" class="headerlink" title="Ctrl + Shift + C复制当前文件磁盘路径到剪贴板 （必备）"></a>Ctrl + Shift + C复制当前文件磁盘路径到剪贴板 （必备）</h6><h6 id="Ctrl-Shift-B跳转到类型声明处-（必备）"><a href="#Ctrl-Shift-B跳转到类型声明处-（必备）" class="headerlink" title="Ctrl + Shift + B跳转到类型声明处 （必备）"></a>Ctrl + Shift + B跳转到类型声明处 （必备）</h6><h6 id="Ctrl-Shift-代码块注释-（必备）"><a href="#Ctrl-Shift-代码块注释-（必备）" class="headerlink" title="Ctrl + Shift + /代码块注释 （必备）"></a>Ctrl + Shift + /代码块注释 （必备）</h6><h6 id="Ctrl-Shift-选中从光标所在位置到它的顶部中括号位置-（必备）"><a href="#Ctrl-Shift-选中从光标所在位置到它的顶部中括号位置-（必备）" class="headerlink" title="Ctrl + Shift + [选中从光标所在位置到它的顶部中括号位置 （必备）"></a>Ctrl + Shift + [选中从光标所在位置到它的顶部中括号位置 （必备）</h6><h6 id="Ctrl-Shift-选中从光标所在位置到它的底部中括号位置-（必备）"><a href="#Ctrl-Shift-选中从光标所在位置到它的底部中括号位置-（必备）" class="headerlink" title="Ctrl + Shift + ]选中从光标所在位置到它的底部中括号位置 （必备）"></a>Ctrl + Shift + ]选中从光标所在位置到它的底部中括号位置 （必备）</h6><h6 id="Ctrl-Shift-展开所有代码-（必备）"><a href="#Ctrl-Shift-展开所有代码-（必备）" class="headerlink" title="Ctrl + Shift + +展开所有代码 （必备）"></a>Ctrl + Shift + +展开所有代码 （必备）</h6><h6 id="Ctrl-Shift-折叠所有代码-（必备）"><a href="#Ctrl-Shift-折叠所有代码-（必备）" class="headerlink" title="Ctrl + Shift + -折叠所有代码 （必备）"></a>Ctrl + Shift + -折叠所有代码 （必备）</h6><h6 id="Ctrl-Shift-F7高亮显示所有该选中文本，按Esc高亮消失-（必备）"><a href="#Ctrl-Shift-F7高亮显示所有该选中文本，按Esc高亮消失-（必备）" class="headerlink" title="Ctrl + Shift + F7高亮显示所有该选中文本，按Esc高亮消失 （必备）"></a>Ctrl + Shift + F7高亮显示所有该选中文本，按Esc高亮消失 （必备）</h6><h6 id="Ctrl-Shift-F12编辑器最大化-（必备）"><a href="#Ctrl-Shift-F12编辑器最大化-（必备）" class="headerlink" title="Ctrl + Shift + F12编辑器最大化 （必备）"></a>Ctrl + Shift + F12编辑器最大化 （必备）</h6><h6 id="Ctrl-Shift-Enter自动结束代码，行末自动添加分号-（必备）"><a href="#Ctrl-Shift-Enter自动结束代码，行末自动添加分号-（必备）" class="headerlink" title="Ctrl + Shift + Enter自动结束代码，行末自动添加分号 （必备）"></a>Ctrl + Shift + Enter自动结束代码，行末自动添加分号 （必备）</h6><h6 id="Ctrl-Shift-Backspace退回到上次修改的地方-（必备）"><a href="#Ctrl-Shift-Backspace退回到上次修改的地方-（必备）" class="headerlink" title="Ctrl + Shift + Backspace退回到上次修改的地方 （必备）"></a>Ctrl + Shift + Backspace退回到上次修改的地方 （必备）</h6><h6 id="Ctrl-Shift-1-2-3…9快速添加指定数值的书签-（必备）"><a href="#Ctrl-Shift-1-2-3…9快速添加指定数值的书签-（必备）" class="headerlink" title="Ctrl + Shift + 1,2,3…9快速添加指定数值的书签 （必备）"></a>Ctrl + Shift + 1,2,3…9快速添加指定数值的书签 （必备）</h6><h6 id="Ctrl-Shift-左键单击把光标放在某个类变量上，按此快捷键可以直接定位到该类中-（必备）"><a href="#Ctrl-Shift-左键单击把光标放在某个类变量上，按此快捷键可以直接定位到该类中-（必备）" class="headerlink" title="Ctrl + Shift + 左键单击把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备）"></a>Ctrl + Shift + 左键单击把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备）</h6><h6 id="Ctrl-Shift-左方向键在代码文件上，光标跳转到当前单词-中文句的左侧开头位置，同时选中该单词-中文句-（必备）"><a href="#Ctrl-Shift-左方向键在代码文件上，光标跳转到当前单词-中文句的左侧开头位置，同时选中该单词-中文句-（必备）" class="headerlink" title="Ctrl + Shift + 左方向键在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 （必备）"></a>Ctrl + Shift + 左方向键在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 （必备）</h6><h6 id="Ctrl-Shift-右方向键在代码文件上，光标跳转到当前单词-中文句的右侧开头位置，同时选中该单词-中文句-（必备）"><a href="#Ctrl-Shift-右方向键在代码文件上，光标跳转到当前单词-中文句的右侧开头位置，同时选中该单词-中文句-（必备）" class="headerlink" title="Ctrl + Shift + 右方向键在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 （必备）"></a>Ctrl + Shift + 右方向键在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 （必备）</h6><h6 id="Ctrl-Shift-前方向键光标放在方法名上，将方法移动到上一个方法前面，调整方法排序-（必备）"><a href="#Ctrl-Shift-前方向键光标放在方法名上，将方法移动到上一个方法前面，调整方法排序-（必备）" class="headerlink" title="Ctrl + Shift + 前方向键光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 （必备）"></a>Ctrl + Shift + 前方向键光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 （必备）</h6><h6 id="Ctrl-Shift-后方向键光标放在方法名上，将方法移动到下一个方法前面，调整方法排序-（必备）"><a href="#Ctrl-Shift-后方向键光标放在方法名上，将方法移动到下一个方法前面，调整方法排序-（必备）" class="headerlink" title="Ctrl + Shift + 后方向键光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 （必备）"></a>Ctrl + Shift + 后方向键光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 （必备）</h6><h5 id="6、Alt-Shift"><a href="#6、Alt-Shift" class="headerlink" title="6、Alt + Shift:"></a>6、Alt + Shift:</h5><h6 id="Alt-Shift-左键双击选择被双击的单词-中文句，按住不放，可以同时选择其他单词-中文句-（必备）"><a href="#Alt-Shift-左键双击选择被双击的单词-中文句，按住不放，可以同时选择其他单词-中文句-（必备）" class="headerlink" title="Alt + Shift + 左键双击选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 （必备）"></a>Alt + Shift + 左键双击选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 （必备）</h6><h6 id="Alt-Shift-前方向键移动光标所在行向上移动-（必备）"><a href="#Alt-Shift-前方向键移动光标所在行向上移动-（必备）" class="headerlink" title="Alt + Shift + 前方向键移动光标所在行向上移动 （必备）"></a>Alt + Shift + 前方向键移动光标所在行向上移动 （必备）</h6><h6 id="Alt-Shift-后方向键移动光标所在行向下移动-（必备）"><a href="#Alt-Shift-后方向键移动光标所在行向下移动-（必备）" class="headerlink" title="Alt + Shift + 后方向键移动光标所在行向下移动 （必备）"></a>Alt + Shift + 后方向键移动光标所在行向下移动 （必备）</h6><h6 id="Alt-Shift-N选择-添加-task-（必备）"><a href="#Alt-Shift-N选择-添加-task-（必备）" class="headerlink" title="Alt + Shift + N选择 / 添加 task （必备）"></a>Alt + Shift + N选择 / 添加 task （必备）</h6>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/21/Java_9_%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7_%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xieshanzhong">
      <meta itemprop="description" content="欢迎来到xieshanzhong的技术分享站~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XIE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/21/Java_9_%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7_%E5%8F%8D%E5%B0%84/" class="post-title-link" itemprop="url">Java_高级特性_反射机制(九)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-21 21:17:59" itemprop="dateCreated datePublished" datetime="2018-11-21T21:17:59+08:00">2018-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-03 16:46:51" itemprop="dateModified" datetime="2023-11-03T16:46:51+08:00">2023-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a>一、<em>思维导图</em></h4><h5 id="1、http-naotu-baidu-com-file-466e142d3ee5bda54f97717d6b939bf8"><a href="#1、http-naotu-baidu-com-file-466e142d3ee5bda54f97717d6b939bf8" class="headerlink" title="1、http://naotu.baidu.com/file/466e142d3ee5bda54f97717d6b939bf8"></a>1、<a href="http://naotu.baidu.com/file/466e142d3ee5bda54f97717d6b939bf8">http://naotu.baidu.com/file/466e142d3ee5bda54f97717d6b939bf8</a></h5><h4 id="二、总知识点"><a href="#二、总知识点" class="headerlink" title="二、总知识点"></a>二、<em>总知识点</em></h4><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="就是把Java类结构分解，每一个部分对应着特定的反射类"><a href="#就是把Java类结构分解，每一个部分对应着特定的反射类" class="headerlink" title="就是把Java类结构分解，每一个部分对应着特定的反射类"></a>就是把Java类结构分解，每一个部分对应着特定的反射类</h3><h2 id="反射机制意义"><a href="#反射机制意义" class="headerlink" title="反射机制意义"></a>反射机制意义</h2><h3 id="程序可以加载一个运行时才得知名称的class，获悉其完整的构造，可以生成其对象的实体，或对其field设值，或唤醒其methods"><a href="#程序可以加载一个运行时才得知名称的class，获悉其完整的构造，可以生成其对象的实体，或对其field设值，或唤醒其methods" class="headerlink" title="程序可以加载一个运行时才得知名称的class，获悉其完整的构造，可以生成其对象的实体，或对其field设值，或唤醒其methods"></a>程序可以加载一个运行时才得知名称的class，获悉其完整的构造，可以生成其对象的实体，或对其field设值，或唤醒其methods</h3><h2 id="反射可以做什么"><a href="#反射可以做什么" class="headerlink" title="反射可以做什么"></a>反射可以做什么</h2><h3 id="1、java对象序列化"><a href="#1、java对象序列化" class="headerlink" title="1、java对象序列化"></a>1、java对象序列化</h3><h3 id="2、封装框架，提供通用的功能"><a href="#2、封装框架，提供通用的功能" class="headerlink" title="2、封装框架，提供通用的功能"></a>2、封装框架，提供通用的功能</h3><h3 id="3、内省就是对反射机制的应用"><a href="#3、内省就是对反射机制的应用" class="headerlink" title="3、内省就是对反射机制的应用"></a>3、内省就是对反射机制的应用</h3><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h3><h4 id="在编译时确定类型，绑定对象，即通过"><a href="#在编译时确定类型，绑定对象，即通过" class="headerlink" title="在编译时确定类型，绑定对象，即通过"></a>在编译时确定类型，绑定对象，即通过</h4><h3 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h3><h4 id="运行时确定类型，绑定对象，动态-编译最大限度发挥了java的灵活性，体现多态的应用"><a href="#运行时确定类型，绑定对象，动态-编译最大限度发挥了java的灵活性，体现多态的应用" class="headerlink" title="运行时确定类型，绑定对象，动态 编译最大限度发挥了java的灵活性，体现多态的应用"></a>运行时确定类型，绑定对象，动态 编译最大限度发挥了java的灵活性，体现多态的应用</h4><h2 id="java类结构和对应的反射类"><a href="#java类结构和对应的反射类" class="headerlink" title="java类结构和对应的反射类"></a>java类结构和对应的反射类</h2><h3 id="1、包声明——-Package"><a href="#1、包声明——-Package" class="headerlink" title="1、包声明——-Package"></a>1、包声明——-Package</h3><h3 id="2、类声明———Class"><a href="#2、类声明———Class" class="headerlink" title="2、类声明———Class"></a>2、类声明———Class</h3><h3 id="3、构造函数声明——-Constructor"><a href="#3、构造函数声明——-Constructor" class="headerlink" title="3、构造函数声明——-Constructor"></a>3、构造函数声明——-Constructor</h3><h3 id="4、字段声明——Field"><a href="#4、字段声明——Field" class="headerlink" title="4、字段声明——Field"></a>4、字段声明——Field</h3><h3 id="5、方法声明——-Method"><a href="#5、方法声明——-Method" class="headerlink" title="5、方法声明——-Method"></a>5、方法声明——-Method</h3><h3 id="6、静态代码块和代码块"><a href="#6、静态代码块和代码块" class="headerlink" title="6、静态代码块和代码块"></a>6、静态代码块和代码块</h3><h2 id="四个反射类"><a href="#四个反射类" class="headerlink" title="四个反射类"></a>四个反射类</h2><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><h4 id="Class-c1-Code-class"><a href="#Class-c1-Code-class" class="headerlink" title="Class c1 = Code.class"></a>Class c1 = Code.class</h4><h4 id="Class-c2-code1-getClass"><a href="#Class-c2-code1-getClass" class="headerlink" title="Class c2 = code1.getClass()"></a>Class c2 = code1.getClass()</h4><h4 id="Class-c3-Class-forName-“com-reflect-test”"><a href="#Class-c3-Class-forName-“com-reflect-test”" class="headerlink" title="Class c3 = Class.forName(“com.reflect.test”)"></a>Class c3 = Class.forName(“com.reflect.test”)</h4><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><h4 id="getDeclareMethod-String-name-Class-lt-gt-…parameterTypes"><a href="#getDeclareMethod-String-name-Class-lt-gt-…parameterTypes" class="headerlink" title="getDeclareMethod(String name , Class&lt;?&gt;…parameterTypes)"></a>getDeclareMethod(String name , Class&lt;?&gt;…parameterTypes)</h4><h4 id="getMethod-String-name-Class-lt-gt-…parameterTypes"><a href="#getMethod-String-name-Class-lt-gt-…parameterTypes" class="headerlink" title="getMethod(String name , Class&lt;?&gt;…parameterTypes)"></a>getMethod(String name , Class&lt;?&gt;…parameterTypes)</h4><h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><h4 id="getDeclareField-String-name"><a href="#getDeclareField-String-name" class="headerlink" title="getDeclareField(String name)"></a>getDeclareField(String name)</h4><h4 id="getDeclareField-String-name-1"><a href="#getDeclareField-String-name-1" class="headerlink" title="getDeclareField(String name)"></a>getDeclareField(String name)</h4><h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><h4 id="getDeclareConstructor-String-name-Class-lt-gt-…parameterTypes"><a href="#getDeclareConstructor-String-name-Class-lt-gt-…parameterTypes" class="headerlink" title="getDeclareConstructor(String name , Class&lt;?&gt;…parameterTypes)"></a>getDeclareConstructor(String name , Class&lt;?&gt;…parameterTypes)</h4><h4 id="getConstructor-String-name-Class-lt-gt-…parameterTypes"><a href="#getConstructor-String-name-Class-lt-gt-…parameterTypes" class="headerlink" title="getConstructor(String name , Class&lt;?&gt;…parameterTypes)"></a>getConstructor(String name , Class&lt;?&gt;…parameterTypes)</h4><h2 id="一个Modifier判断修饰符和类型"><a href="#一个Modifier判断修饰符和类型" class="headerlink" title="一个Modifier判断修饰符和类型"></a>一个Modifier判断修饰符和类型</h2><h2 id="AccessibleObject"><a href="#AccessibleObject" class="headerlink" title="AccessibleObject"></a>AccessibleObject</h2><h3 id="1、取消反射对象Constructor，Field，Method的访问限制"><a href="#1、取消反射对象Constructor，Field，Method的访问限制" class="headerlink" title="1、取消反射对象Constructor，Field，Method的访问限制"></a>1、取消反射对象Constructor，Field，Method的访问限制</h3><h3 id="2、void-setAccessible-boolean-flag"><a href="#2、void-setAccessible-boolean-flag" class="headerlink" title="2、void setAccessible(boolean flag)"></a>2、void setAccessible(boolean flag)</h3><h3 id="3、java对象的序列化会使用到此特性"><a href="#3、java对象的序列化会使用到此特性" class="headerlink" title="3、java对象的序列化会使用到此特性"></a>3、java对象的序列化会使用到此特性</h3><h4 id="三、重点知识点实例"><a href="#三、重点知识点实例" class="headerlink" title="三、重点知识点实例"></a>三、<em>重点知识点实例</em></h4><h4 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、<em>参考资料</em></h4><h4 id="五、思维扩展"><a href="#五、思维扩展" class="headerlink" title="五、思维扩展"></a>五、<em>思维扩展</em></h4><h4 id="六、存在疑问"><a href="#六、存在疑问" class="headerlink" title="六、存在疑问"></a>六、<em>存在疑问</em></h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/21/Java_91_%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xieshanzhong">
      <meta itemprop="description" content="欢迎来到xieshanzhong的技术分享站~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XIE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/21/Java_91_%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">Java_高级特性(九)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-21 20:17:59" itemprop="dateCreated datePublished" datetime="2018-11-21T20:17:59+08:00">2018-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-03 16:46:51" itemprop="dateModified" datetime="2023-11-03T16:46:51+08:00">2023-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a>一、<em>思维导图</em></h4><h5 id="1、http-naotu-baidu-com-file-60ea169f4207a4ad627cdc33f14d29f7"><a href="#1、http-naotu-baidu-com-file-60ea169f4207a4ad627cdc33f14d29f7" class="headerlink" title="1、http://naotu.baidu.com/file/60ea169f4207a4ad627cdc33f14d29f7"></a>1、<a href="http://naotu.baidu.com/file/60ea169f4207a4ad627cdc33f14d29f7">http://naotu.baidu.com/file/60ea169f4207a4ad627cdc33f14d29f7</a></h5><h4 id="二、总知识点"><a href="#二、总知识点" class="headerlink" title="二、总知识点"></a>二、<em>总知识点</em></h4><h2 id="1、泛型"><a href="#1、泛型" class="headerlink" title="1、泛型"></a>1、泛型</h2><h3 id="1、泛型基本概念"><a href="#1、泛型基本概念" class="headerlink" title="1、泛型基本概念"></a>1、泛型基本概念</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><h5 id="是对java语言类型系统的一种扩展，以支持利用类型参数创建参数化类，可以把参数类型参数看成一个占位符，就像方法的形式参数是运行时传递值得占位符一样"><a href="#是对java语言类型系统的一种扩展，以支持利用类型参数创建参数化类，可以把参数类型参数看成一个占位符，就像方法的形式参数是运行时传递值得占位符一样" class="headerlink" title="是对java语言类型系统的一种扩展，以支持利用类型参数创建参数化类，可以把参数类型参数看成一个占位符，就像方法的形式参数是运行时传递值得占位符一样"></a>是对java语言类型系统的一种扩展，以支持利用类型参数创建参数化类，可以把参数类型参数看成一个占位符，就像方法的形式参数是运行时传递值得占位符一样</h5><h4 id="2、前提"><a href="#2、前提" class="headerlink" title="2、前提"></a>2、前提</h4><h5 id="jdk1-5之后才有泛型"><a href="#jdk1-5之后才有泛型" class="headerlink" title="jdk1.5之后才有泛型"></a>jdk1.5之后才有泛型</h5><h4 id="3、使用泛型的好处"><a href="#3、使用泛型的好处" class="headerlink" title="3、使用泛型的好处"></a>3、使用泛型的好处</h4><h5 id="1、提高java程序的类型安全"><a href="#1、提高java程序的类型安全" class="headerlink" title="1、提高java程序的类型安全"></a>1、提高java程序的类型安全</h5><h5 id="2、消除源代码中许多强制类型转换，增强了代码可读性，而且减少了出错机会"><a href="#2、消除源代码中许多强制类型转换，增强了代码可读性，而且减少了出错机会" class="headerlink" title="2、消除源代码中许多强制类型转换，增强了代码可读性，而且减少了出错机会"></a>2、消除源代码中许多强制类型转换，增强了代码可读性，而且减少了出错机会</h5><h5 id="3、泛型为系统优化带来可能，在泛型的初始化实现中，编译器将强制类型转换（如果没有泛型，程序员会指定这些强制类型转换）插入生成的字节码中，编译器将发现类型异常情况"><a href="#3、泛型为系统优化带来可能，在泛型的初始化实现中，编译器将强制类型转换（如果没有泛型，程序员会指定这些强制类型转换）插入生成的字节码中，编译器将发现类型异常情况" class="headerlink" title="3、泛型为系统优化带来可能，在泛型的初始化实现中，编译器将强制类型转换（如果没有泛型，程序员会指定这些强制类型转换）插入生成的字节码中，编译器将发现类型异常情况"></a>3、泛型为系统优化带来可能，在泛型的初始化实现中，编译器将强制类型转换（如果没有泛型，程序员会指定这些强制类型转换）插入生成的字节码中，编译器将发现类型异常情况</h5><h3 id="2、泛型的使用"><a href="#2、泛型的使用" class="headerlink" title="2、泛型的使用"></a>2、泛型的使用</h3><h4 id="1、泛型类定义"><a href="#1、泛型类定义" class="headerlink" title="1、泛型类定义"></a>1、泛型类定义</h4><h5 id="class-类名-lt-泛型类型标识符-1-，泛型类型标识符-2-，-gt-泛型类型标识-数据成员名；-泛型类型标识-成员方法名称"><a href="#class-类名-lt-泛型类型标识符-1-，泛型类型标识符-2-，-gt-泛型类型标识-数据成员名；-泛型类型标识-成员方法名称" class="headerlink" title="class 类名&lt;泛型类型标识符 1 ，泛型类型标识符 2 ，.&gt;{泛型类型标识 数据成员名； 泛型类型标识 成员方法名称(){}}"></a>class 类名&lt;泛型类型标识符 1 ，泛型类型标识符 2 ，.&gt;{泛型类型标识 数据成员名； 泛型类型标识 成员方法名称(){}}</h5><h4 id="2、泛型对象定义"><a href="#2、泛型对象定义" class="headerlink" title="2、泛型对象定义"></a>2、泛型对象定义</h4><h5 id="类名称-lt-具体类-gt-对象名称-new-类名称-lt-具体类-gt-（）"><a href="#类名称-lt-具体类-gt-对象名称-new-类名称-lt-具体类-gt-（）" class="headerlink" title="类名称&lt;具体类&gt; 对象名称 = new 类名称&lt;具体类&gt;（）"></a>类名称&lt;具体类&gt; 对象名称 = new 类名称&lt;具体类&gt;（）</h5><h4 id="3、泛型中构造方法"><a href="#3、泛型中构造方法" class="headerlink" title="3、泛型中构造方法"></a>3、泛型中构造方法</h4><h5 id="访问权限-构造方法（-泛型参数-参数-）"><a href="#访问权限-构造方法（-泛型参数-参数-）" class="headerlink" title="[访问权限] 构造方法（[泛型参数 参数]）{}"></a>[访问权限] 构造方法（[泛型参数 参数]）{}</h5><h4 id="4、泛型方法的定义"><a href="#4、泛型方法的定义" class="headerlink" title="4、泛型方法的定义"></a>4、泛型方法的定义</h4><h5 id="lt-泛型标识列表-gt-泛型标识-方法名称-泛型标识1-参数名称，泛型标识-2-参数名称"><a href="#lt-泛型标识列表-gt-泛型标识-方法名称-泛型标识1-参数名称，泛型标识-2-参数名称" class="headerlink" title="&lt;泛型标识列表&gt; 泛型标识  方法名称(泛型标识1 参数名称，泛型标识 2 参数名称){}"></a>&lt;泛型标识列表&gt; 泛型标识  方法名称(泛型标识1 参数名称，泛型标识 2 参数名称){}</h5><h3 id="3、通配符"><a href="#3、通配符" class="headerlink" title="3、通配符"></a>3、通配符</h3><h4 id="泛型通配符“？”表示可以接受此类型的任意泛型对象"><a href="#泛型通配符“？”表示可以接受此类型的任意泛型对象" class="headerlink" title="泛型通配符“？”表示可以接受此类型的任意泛型对象"></a>泛型通配符“？”表示可以接受此类型的任意泛型对象</h4><h4 id="采用泛型通配符仅仅表示该泛型可以接受任意泛型对象，但是没有确定具体的对象，因此对“不可预知”的任何事物进行操作都是不允许的"><a href="#采用泛型通配符仅仅表示该泛型可以接受任意泛型对象，但是没有确定具体的对象，因此对“不可预知”的任何事物进行操作都是不允许的" class="headerlink" title="采用泛型通配符仅仅表示该泛型可以接受任意泛型对象，但是没有确定具体的对象，因此对“不可预知”的任何事物进行操作都是不允许的"></a>采用泛型通配符仅仅表示该泛型可以接受任意泛型对象，但是没有确定具体的对象，因此对“不可预知”的任何事物进行操作都是不允许的</h4><h3 id="4、泛型接口"><a href="#4、泛型接口" class="headerlink" title="4、泛型接口"></a>4、泛型接口</h3><h4 id="1、泛型接口定义格式"><a href="#1、泛型接口定义格式" class="headerlink" title="1、泛型接口定义格式"></a>1、泛型接口定义格式</h4><h5 id="interface接口名称-lt-泛型类型标识-1-，-泛型类型标识-2-，泛型类型标识-n-gt"><a href="#interface接口名称-lt-泛型类型标识-1-，-泛型类型标识-2-，泛型类型标识-n-gt" class="headerlink" title="interface接口名称&lt;泛型类型标识 1 ， 泛型类型标识 2 ，泛型类型标识 n&gt;{}"></a>interface接口名称&lt;泛型类型标识 1 ， 泛型类型标识 2 ，泛型类型标识 n&gt;{}</h5><h4 id="2、定义泛型接口"><a href="#2、定义泛型接口" class="headerlink" title="2、定义泛型接口"></a>2、定义泛型接口</h4><h5 id="interface-Informatica-public-T-getT-public-V-getV"><a href="#interface-Informatica-public-T-getT-public-V-getV" class="headerlink" title="interface Informatica{public T getT(); public V getV();}"></a>interface Informatica<T,V>{public T getT(); public V getV();}</T,V></h5><h4 id="3、在子类的定义中声明泛型类型"><a href="#3、在子类的定义中声明泛型类型" class="headerlink" title="3、在子类的定义中声明泛型类型"></a>3、在子类的定义中声明泛型类型</h4><h5 id="class-类名-lt-泛型类型标识-gt-implement-泛型类型名-lt-泛型类型标识-gt"><a href="#class-类名-lt-泛型类型标识-gt-implement-泛型类型名-lt-泛型类型标识-gt" class="headerlink" title="class 类名&lt;泛型类型标识&gt; implement 泛型类型名&lt;泛型类型标识&gt;{}"></a>class 类名&lt;泛型类型标识&gt; implement 泛型类型名&lt;泛型类型标识&gt;{}</h5><h4 id="4、在子类中给指定泛型类型"><a href="#4、在子类中给指定泛型类型" class="headerlink" title="4、在子类中给指定泛型类型"></a>4、在子类中给指定泛型类型</h4><h5 id="class-类名-implement-泛型类型名-lt-泛型具体类型-gt"><a href="#class-类名-implement-泛型类型名-lt-泛型具体类型-gt" class="headerlink" title="class 类名 implement 泛型类型名&lt;泛型具体类型&gt;{}"></a>class 类名 implement 泛型类型名&lt;泛型具体类型&gt;{}</h5><h4 id="5、泛型的限制"><a href="#5、泛型的限制" class="headerlink" title="5、泛型的限制"></a>5、泛型的限制</h4><h5 id="1、在泛型接口的子类中如果指定了具体的泛型类型，那么已确定了泛型接口中抽象方法的参数和返回值类型，因此子类的构造方法就不需要使用泛型类型"><a href="#1、在泛型接口的子类中如果指定了具体的泛型类型，那么已确定了泛型接口中抽象方法的参数和返回值类型，因此子类的构造方法就不需要使用泛型类型" class="headerlink" title="1、在泛型接口的子类中如果指定了具体的泛型类型，那么已确定了泛型接口中抽象方法的参数和返回值类型，因此子类的构造方法就不需要使用泛型类型"></a>1、在泛型接口的子类中如果指定了具体的泛型类型，那么已确定了泛型接口中抽象方法的参数和返回值类型，因此子类的构造方法就不需要使用泛型类型</h5><h5 id="2、泛型接口中不能定义泛型数据成员，因为接口中的数据都是static成员，必须进行初始化赋值，而泛型类型仅仅是占位符，不能确定类型，因此不能在接口中声明泛型数据成员"><a href="#2、泛型接口中不能定义泛型数据成员，因为接口中的数据都是static成员，必须进行初始化赋值，而泛型类型仅仅是占位符，不能确定类型，因此不能在接口中声明泛型数据成员" class="headerlink" title="2、泛型接口中不能定义泛型数据成员，因为接口中的数据都是static成员，必须进行初始化赋值，而泛型类型仅仅是占位符，不能确定类型，因此不能在接口中声明泛型数据成员"></a>2、泛型接口中不能定义泛型数据成员，因为接口中的数据都是static成员，必须进行初始化赋值，而泛型类型仅仅是占位符，不能确定类型，因此不能在接口中声明泛型数据成员</h5><h3 id="5、受限泛型"><a href="#5、受限泛型" class="headerlink" title="5、受限泛型"></a>5、受限泛型</h3><h4 id="1、泛型上限"><a href="#1、泛型上限" class="headerlink" title="1、泛型上限"></a>1、泛型上限</h4><h5 id="1、泛型上限指定了泛型只能是某种类型的子类，采用关键字extends表示"><a href="#1、泛型上限指定了泛型只能是某种类型的子类，采用关键字extends表示" class="headerlink" title="1、泛型上限指定了泛型只能是某种类型的子类，采用关键字extends表示"></a>1、泛型上限指定了泛型只能是某种类型的子类，采用关键字extends表示</h5><h5 id="2、指定泛型上限-声明对象：类名称-lt-extends-类-gt-对象名称，定义类：类名称-lt-泛型标识-extends-类-gt"><a href="#2、指定泛型上限-声明对象：类名称-lt-extends-类-gt-对象名称，定义类：类名称-lt-泛型标识-extends-类-gt" class="headerlink" title="2、指定泛型上限 声明对象：类名称&lt;? extends 类&gt; 对象名称，定义类：类名称&lt;泛型标识 extends 类&gt;"></a>2、指定泛型上限 声明对象：类名称&lt;? extends 类&gt; 对象名称，定义类：类名称&lt;泛型标识 extends 类&gt;</h5><h4 id="2、泛型下限"><a href="#2、泛型下限" class="headerlink" title="2、泛型下限"></a>2、泛型下限</h4><h5 id="1、泛型下限指定了泛型只能是某种类型的祖先类，采用关键字super表示"><a href="#1、泛型下限指定了泛型只能是某种类型的祖先类，采用关键字super表示" class="headerlink" title="1、泛型下限指定了泛型只能是某种类型的祖先类，采用关键字super表示"></a>1、泛型下限指定了泛型只能是某种类型的祖先类，采用关键字super表示</h5><h5 id="2、指定泛型下限-声明对象：类名称-lt-super-类-gt-对象名称"><a href="#2、指定泛型下限-声明对象：类名称-lt-super-类-gt-对象名称" class="headerlink" title="2、指定泛型下限 声明对象：类名称&lt;? super 类&gt; 对象名称"></a>2、指定泛型下限 声明对象：类名称&lt;? super 类&gt; 对象名称</h5><h4 id="3、泛型上限只能定义方法参数"><a href="#3、泛型上限只能定义方法参数" class="headerlink" title="3、泛型上限只能定义方法参数"></a>3、泛型上限只能定义方法参数</h4><h5 id="1、与指定泛型下限不同，不能采用类名称-lt-泛型标识-super-类-gt-来定义一个泛型的上限"><a href="#1、与指定泛型下限不同，不能采用类名称-lt-泛型标识-super-类-gt-来定义一个泛型的上限" class="headerlink" title="1、与指定泛型下限不同，不能采用类名称&lt;泛型标识 super 类&gt;{}来定义一个泛型的上限"></a>1、与指定泛型下限不同，不能采用类名称&lt;泛型标识 super 类&gt;{}来定义一个泛型的上限</h5><h5 id="2、类名称-lt-super-类-gt-对象名称-只能定义方法的参数"><a href="#2、类名称-lt-super-类-gt-对象名称-只能定义方法的参数" class="headerlink" title="2、类名称&lt;? super 类&gt;对象名称 只能定义方法的参数"></a>2、类名称&lt;? super 类&gt;对象名称 只能定义方法的参数</h5><h2 id="2、异常"><a href="#2、异常" class="headerlink" title="2、异常"></a>2、异常</h2><h3 id="1、异常种类"><a href="#1、异常种类" class="headerlink" title="1、异常种类"></a>1、异常种类</h3><h4 id="1、检查时异常"><a href="#1、检查时异常" class="headerlink" title="1、检查时异常"></a>1、检查时异常</h4><h5 id="指编译器要检查这类异常，必须处理try-catch的异常或向上抛出"><a href="#指编译器要检查这类异常，必须处理try-catch的异常或向上抛出" class="headerlink" title="指编译器要检查这类异常，必须处理try/catch的异常或向上抛出"></a>指编译器要检查这类异常，必须处理try/catch的异常或向上抛出</h5><h4 id="2、非检查时异常"><a href="#2、非检查时异常" class="headerlink" title="2、非检查时异常"></a>2、非检查时异常</h4><h5 id="编译器不会检查这类异常，可以不用捕获"><a href="#编译器不会检查这类异常，可以不用捕获" class="headerlink" title="编译器不会检查这类异常，可以不用捕获"></a>编译器不会检查这类异常，可以不用捕获</h5><h3 id="2、Throwable"><a href="#2、Throwable" class="headerlink" title="2、Throwable"></a>2、Throwable</h3><h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><h5 id="是不可捕获的，无法采取任何恢复的操作，顶多只能显示错误信息"><a href="#是不可捕获的，无法采取任何恢复的操作，顶多只能显示错误信息" class="headerlink" title="是不可捕获的，无法采取任何恢复的操作，顶多只能显示错误信息"></a>是不可捕获的，无法采取任何恢复的操作，顶多只能显示错误信息</h5><h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><h5 id="所有的异常是java-lang-Exeception类继承的子类"><a href="#所有的异常是java-lang-Exeception类继承的子类" class="headerlink" title="所有的异常是java.lang.Exeception类继承的子类"></a>所有的异常是java.lang.Exeception类继承的子类</h5><h5 id="Exception类时Throwable类的子类"><a href="#Exception类时Throwable类的子类" class="headerlink" title="Exception类时Throwable类的子类"></a>Exception类时Throwable类的子类</h5><h3 id="3、捕获异常"><a href="#3、捕获异常" class="headerlink" title="3、捕获异常"></a>3、捕获异常</h3><h4 id="try-catch-finally语句"><a href="#try-catch-finally语句" class="headerlink" title="try/catch/finally语句"></a>try/catch/finally语句</h4><h4 id="异常处理程序"><a href="#异常处理程序" class="headerlink" title="异常处理程序"></a>异常处理程序</h4><h4 id="异常处理理论两种基本模型"><a href="#异常处理理论两种基本模型" class="headerlink" title="异常处理理论两种基本模型"></a>异常处理理论两种基本模型</h4><h5 id="终止模型"><a href="#终止模型" class="headerlink" title="终止模型"></a>终止模型</h5><h6 id="一旦异常抛出，就终止"><a href="#一旦异常抛出，就终止" class="headerlink" title="一旦异常抛出，就终止"></a>一旦异常抛出，就终止</h6><h5 id="恢复模型"><a href="#恢复模型" class="headerlink" title="恢复模型"></a>恢复模型</h5><h6 id="修正错误，然后重新调用方法来修正错误"><a href="#修正错误，然后重新调用方法来修正错误" class="headerlink" title="修正错误，然后重新调用方法来修正错误"></a>修正错误，然后重新调用方法来修正错误</h6><h3 id="4、抛出异常"><a href="#4、抛出异常" class="headerlink" title="4、抛出异常"></a>4、抛出异常</h3><h4 id="throws-throw"><a href="#throws-throw" class="headerlink" title="throws/throw"></a>throws/throw</h4><h5 id="throws关键字放在方法签名2尾部"><a href="#throws关键字放在方法签名2尾部" class="headerlink" title="throws关键字放在方法签名2尾部"></a>throws关键字放在方法签名2尾部</h5><h5 id="throw在方法体中抛出异常"><a href="#throw在方法体中抛出异常" class="headerlink" title="throw在方法体中抛出异常"></a>throw在方法体中抛出异常</h5><h5 id="一个方法可以声明抛出多个异常，多个异常常用逗号隔开"><a href="#一个方法可以声明抛出多个异常，多个异常常用逗号隔开" class="headerlink" title="一个方法可以声明抛出多个异常，多个异常常用逗号隔开"></a>一个方法可以声明抛出多个异常，多个异常常用逗号隔开</h5><h3 id="5、finally"><a href="#5、finally" class="headerlink" title="5、finally"></a>5、finally</h3><h4 id="解析：finally关键字用来创建在try代码后面执行的代码块。无论是否发生异常，finally代码块的代码都会被执行"><a href="#解析：finally关键字用来创建在try代码后面执行的代码块。无论是否发生异常，finally代码块的代码都会被执行" class="headerlink" title="解析：finally关键字用来创建在try代码后面执行的代码块。无论是否发生异常，finally代码块的代码都会被执行"></a>解析：finally关键字用来创建在try代码后面执行的代码块。无论是否发生异常，finally代码块的代码都会被执行</h4><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><h5 id="如果一个方法在执行try-语句之前就return，那么finally语句执行不会执行。"><a href="#如果一个方法在执行try-语句之前就return，那么finally语句执行不会执行。" class="headerlink" title="如果一个方法在执行try{}语句之前就return，那么finally语句执行不会执行。"></a>如果一个方法在执行try{}语句之前就return，那么finally语句执行不会执行。</h5><h5 id="如果一个try语句调用System-exit-0-那么就会推出当前java虚拟机，那么finally也就没有执行机会"><a href="#如果一个try语句调用System-exit-0-那么就会推出当前java虚拟机，那么finally也就没有执行机会" class="headerlink" title="如果一个try语句调用System.exit(0),那么就会推出当前java虚拟机，那么finally也就没有执行机会"></a>如果一个try语句调用System.exit(0),那么就会推出当前java虚拟机，那么finally也就没有执行机会</h5><h2 id="3、注解"><a href="#3、注解" class="headerlink" title="3、注解"></a>3、注解</h2><h3 id="1、概念定义"><a href="#1、概念定义" class="headerlink" title="1、概念定义"></a>1、概念定义</h3><h4 id="1、注解"><a href="#1、注解" class="headerlink" title="1、注解"></a>1、注解</h4><h5 id="1、注解：提供一种为程序元素设置元数据方法"><a href="#1、注解：提供一种为程序元素设置元数据方法" class="headerlink" title="1、注解：提供一种为程序元素设置元数据方法"></a>1、注解：提供一种为程序元素设置元数据方法</h5><h5 id="2、基本原则"><a href="#2、基本原则" class="headerlink" title="2、基本原则"></a>2、基本原则</h5><h6 id="注解不知能直接干扰程序代码的运行，无论增加或者删除注解，代码都能够正常运行"><a href="#注解不知能直接干扰程序代码的运行，无论增加或者删除注解，代码都能够正常运行" class="headerlink" title="注解不知能直接干扰程序代码的运行，无论增加或者删除注解，代码都能够正常运行"></a>注解不知能直接干扰程序代码的运行，无论增加或者删除注解，代码都能够正常运行</h6><h5 id="3、注解分类"><a href="#3、注解分类" class="headerlink" title="3、注解分类"></a>3、注解分类</h5><h6 id="1、标注注解：没有元素的注解"><a href="#1、标注注解：没有元素的注解" class="headerlink" title="1、标注注解：没有元素的注解"></a>1、标注注解：没有元素的注解</h6><h6 id="单值注解"><a href="#单值注解" class="headerlink" title="单值注解"></a>单值注解</h6><h6 id="完整注解"><a href="#完整注解" class="headerlink" title="完整注解"></a>完整注解</h6><h4 id="2、元数据"><a href="#2、元数据" class="headerlink" title="2、元数据"></a>2、元数据</h4><h5 id="1、元数据"><a href="#1、元数据" class="headerlink" title="1、元数据"></a>1、元数据</h5><h6 id="就是关于数据的数据"><a href="#就是关于数据的数据" class="headerlink" title="就是关于数据的数据"></a>就是关于数据的数据</h6><h5 id="2、元数据作用"><a href="#2、元数据作用" class="headerlink" title="2、元数据作用"></a>2、元数据作用</h5><h6 id="编写文档"><a href="#编写文档" class="headerlink" title="编写文档"></a>编写文档</h6><h6 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h6><h6 id="编译检查"><a href="#编译检查" class="headerlink" title="编译检查"></a>编译检查</h6><h3 id="2、系统注解"><a href="#2、系统注解" class="headerlink" title="2、系统注解"></a>2、系统注解</h3><h4 id="1、标注注解"><a href="#1、标注注解" class="headerlink" title="1、标注注解"></a>1、标注注解</h4><h5 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h5><h6 id="保证编译时候Override函数的声明正确性"><a href="#保证编译时候Override函数的声明正确性" class="headerlink" title="保证编译时候Override函数的声明正确性"></a>保证编译时候Override函数的声明正确性</h6><h5 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h5><h6 id="作用：对不应该在使用的方法添加注释，当编程人员使用这些方法时，将会在编译时显示提示信息"><a href="#作用：对不应该在使用的方法添加注释，当编程人员使用这些方法时，将会在编译时显示提示信息" class="headerlink" title="作用：对不应该在使用的方法添加注释，当编程人员使用这些方法时，将会在编译时显示提示信息"></a>作用：对不应该在使用的方法添加注释，当编程人员使用这些方法时，将会在编译时显示提示信息</h6><h6 id="与javadoc里-deprecated标记有相同的功能"><a href="#与javadoc里-deprecated标记有相同的功能" class="headerlink" title="与javadoc里@deprecated标记有相同的功能"></a>与javadoc里@deprecated标记有相同的功能</h6><h5 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h5><h6 id="作用：关闭特性的警告信息"><a href="#作用：关闭特性的警告信息" class="headerlink" title="作用：关闭特性的警告信息"></a>作用：关闭特性的警告信息</h6><h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><h6 id="1、deprecation"><a href="#1、deprecation" class="headerlink" title="# 1、deprecation"></a># 1、deprecation</h6><h6 id="使用了过时的类或方法时的警告"><a href="#使用了过时的类或方法时的警告" class="headerlink" title="## 使用了过时的类或方法时的警告"></a>## 使用了过时的类或方法时的警告</h6><h6 id="2、unchecked"><a href="#2、unchecked" class="headerlink" title="# 2、unchecked"></a># 2、unchecked</h6><h6 id="执行了未检查的转换时的警告"><a href="#执行了未检查的转换时的警告" class="headerlink" title="## 执行了未检查的转换时的警告"></a>## 执行了未检查的转换时的警告</h6><h6 id="3、fallthrough"><a href="#3、fallthrough" class="headerlink" title="# 3、fallthrough"></a># 3、fallthrough</h6><h6 id="当Switch程序块直接通往下一种情况而没有Break时的警告"><a href="#当Switch程序块直接通往下一种情况而没有Break时的警告" class="headerlink" title="## 当Switch程序块直接通往下一种情况而没有Break时的警告"></a>## 当Switch程序块直接通往下一种情况而没有Break时的警告</h6><h6 id="4、path"><a href="#4、path" class="headerlink" title="# 4、path"></a># 4、path</h6><h6 id="在类路径、源文件路径等中不存在的路径时警告"><a href="#在类路径、源文件路径等中不存在的路径时警告" class="headerlink" title="##  在类路径、源文件路径等中不存在的路径时警告"></a>##  在类路径、源文件路径等中不存在的路径时警告</h6><h6 id="5、serial"><a href="#5、serial" class="headerlink" title="# 5、serial"></a># 5、serial</h6><h6 id="当在可序列化的类上缺少"><a href="#当在可序列化的类上缺少" class="headerlink" title="## 当在可序列化的类上缺少"></a>## 当在可序列化的类上缺少</h6><h6 id="6、serialVersionUID"><a href="#6、serialVersionUID" class="headerlink" title="# 6、serialVersionUID"></a># 6、serialVersionUID</h6><h6 id="定义时的警告"><a href="#定义时的警告" class="headerlink" title="## 定义时的警告"></a>## 定义时的警告</h6><h6 id="7、finally"><a href="#7、finally" class="headerlink" title="# 7、finally"></a># 7、finally</h6><h6 id="任何finally子句不能正常完成时警告"><a href="#任何finally子句不能正常完成时警告" class="headerlink" title="## 任何finally子句不能正常完成时警告"></a>## 任何finally子句不能正常完成时警告</h6><h6 id="8、all"><a href="#8、all" class="headerlink" title="# 8、all"></a># 8、all</h6><h6 id="关于以上所有情况的警告"><a href="#关于以上所有情况的警告" class="headerlink" title="##  关于以上所有情况的警告"></a>##  关于以上所有情况的警告</h6><h4 id="2、元注解"><a href="#2、元注解" class="headerlink" title="2、元注解"></a>2、元注解</h4><h5 id="1、作用：负责注解其他注解"><a href="#1、作用：负责注解其他注解" class="headerlink" title="1、作用：负责注解其他注解"></a>1、作用：负责注解其他注解</h5><h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><h6 id="作用：表示需要在什么级别保存该注释信息"><a href="#作用：表示需要在什么级别保存该注释信息" class="headerlink" title="作用：表示需要在什么级别保存该注释信息"></a>作用：表示需要在什么级别保存该注释信息</h6><h6 id="RetentionPoicy参数"><a href="#RetentionPoicy参数" class="headerlink" title="RetentionPoicy参数"></a>RetentionPoicy参数</h6><h6 id="Source"><a href="#Source" class="headerlink" title="# Source"></a># Source</h6><h6 id="注释将被编译器丢掉"><a href="#注释将被编译器丢掉" class="headerlink" title="##   注释将被编译器丢掉"></a>##   注释将被编译器丢掉</h6><h6 id="Class"><a href="#Class" class="headerlink" title="# Class"></a># Class</h6><h6 id="注解在class文件中可用，但会被VM丢弃，缺省"><a href="#注解在class文件中可用，但会被VM丢弃，缺省" class="headerlink" title="##   注解在class文件中可用，但会被VM丢弃，缺省"></a>##   注解在class文件中可用，但会被VM丢弃，缺省</h6><h6 id="Runtime"><a href="#Runtime" class="headerlink" title="# Runtime"></a># Runtime</h6><h6 id="VM将在运行时也保留注释，因此可通过反射机制读取注解的信息"><a href="#VM将在运行时也保留注释，因此可通过反射机制读取注解的信息" class="headerlink" title="## VM将在运行时也保留注释，因此可通过反射机制读取注解的信息"></a>## VM将在运行时也保留注释，因此可通过反射机制读取注解的信息</h6><h5 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h5><h6 id="作用：该注解可以用于什么地方"><a href="#作用：该注解可以用于什么地方" class="headerlink" title="作用：该注解可以用于什么地方"></a>作用：该注解可以用于什么地方</h6><h6 id="ElementType参数"><a href="#ElementType参数" class="headerlink" title="ElementType参数"></a>ElementType参数</h6><h6 id="Constructor"><a href="#Constructor" class="headerlink" title="# Constructor"></a># Constructor</h6><h6 id="构造器声明"><a href="#构造器声明" class="headerlink" title="## 构造器声明"></a>## 构造器声明</h6><h6 id="Field"><a href="#Field" class="headerlink" title="# Field"></a># Field</h6><h6 id="域声明"><a href="#域声明" class="headerlink" title="##  域声明"></a>##  域声明</h6><h6 id="Local-Variable"><a href="#Local-Variable" class="headerlink" title="# Local_Variable"></a># Local_Variable</h6><h6 id="局部变量声明"><a href="#局部变量声明" class="headerlink" title="## 局部变量声明"></a>## 局部变量声明</h6><h6 id="Method"><a href="#Method" class="headerlink" title="# Method"></a># Method</h6><h6 id="方法声明"><a href="#方法声明" class="headerlink" title="## 方法声明"></a>## 方法声明</h6><h6 id="package"><a href="#package" class="headerlink" title="# package"></a># package</h6><h6 id="包声明"><a href="#包声明" class="headerlink" title="##   包声明"></a>##   包声明</h6><h6 id="Parameter"><a href="#Parameter" class="headerlink" title="# Parameter"></a># Parameter</h6><h6 id="参数声明"><a href="#参数声明" class="headerlink" title="##   参数声明"></a>##   参数声明</h6><h6 id="Type"><a href="#Type" class="headerlink" title="# Type"></a># Type</h6><h6 id="类，接口（包括注解类型）"><a href="#类，接口（包括注解类型）" class="headerlink" title="##   类，接口（包括注解类型）"></a>##   类，接口（包括注解类型）</h6><h5 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h5><h5 id="Inheritied"><a href="#Inheritied" class="headerlink" title="@Inheritied"></a>@Inheritied</h5><h6 id="允许子类继承父类中的注释"><a href="#允许子类继承父类中的注释" class="headerlink" title="允许子类继承父类中的注释"></a>允许子类继承父类中的注释</h6><h3 id="3、注解元素数据类型"><a href="#3、注解元素数据类型" class="headerlink" title="3、注解元素数据类型"></a>3、注解元素数据类型</h3><h4 id="所有基本类型"><a href="#所有基本类型" class="headerlink" title="所有基本类型"></a>所有基本类型</h4><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><h4 id="Class-1"><a href="#Class-1" class="headerlink" title="Class"></a>Class</h4><h4 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h4><h3 id="4、提取注解"><a href="#4、提取注解" class="headerlink" title="4、提取注解"></a>4、提取注解</h3><h4 id="AnnotatedElement接口"><a href="#AnnotatedElement接口" class="headerlink" title="AnnotatedElement接口"></a>AnnotatedElement接口</h4><h5 id="已知实现类"><a href="#已知实现类" class="headerlink" title="已知实现类"></a>已知实现类</h5><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h2 id="4、枚举"><a href="#4、枚举" class="headerlink" title="4、枚举"></a>4、枚举</h2><h4 id="三、重点知识点实例"><a href="#三、重点知识点实例" class="headerlink" title="三、重点知识点实例"></a>三、<em>重点知识点实例</em></h4><h4 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、<em>参考资料</em></h4><h4 id="五、思维扩展"><a href="#五、思维扩展" class="headerlink" title="五、思维扩展"></a>五、<em>思维扩展</em></h4><h4 id="六、存在疑问"><a href="#六、存在疑问" class="headerlink" title="六、存在疑问"></a>六、<em>存在疑问</em></h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/21/Java_7_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xieshanzhong">
      <meta itemprop="description" content="欢迎来到xieshanzhong的技术分享站~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XIE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/21/Java_7_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Java_网络编程(八)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-21 19:17:59" itemprop="dateCreated datePublished" datetime="2018-11-21T19:17:59+08:00">2018-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-03 16:46:51" itemprop="dateModified" datetime="2023-11-03T16:46:51+08:00">2023-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a>一、<em>思维导图</em></h4><h5 id="1、http-naotu-baidu-com-file-ad7f9e6efdac80c4b0d4088a2c7b3213"><a href="#1、http-naotu-baidu-com-file-ad7f9e6efdac80c4b0d4088a2c7b3213" class="headerlink" title="1、http://naotu.baidu.com/file/ad7f9e6efdac80c4b0d4088a2c7b3213"></a>1、<a href="http://naotu.baidu.com/file/ad7f9e6efdac80c4b0d4088a2c7b3213">http://naotu.baidu.com/file/ad7f9e6efdac80c4b0d4088a2c7b3213</a></h5><h4 id="二、总知识点"><a href="#二、总知识点" class="headerlink" title="二、总知识点"></a>二、<em>总知识点</em></h4><h1 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h1><h2 id="1、网络编程概述"><a href="#1、网络编程概述" class="headerlink" title="1、网络编程概述"></a>1、网络编程概述</h2><h3 id="就是用来实现网络互连的不同计算机上运行的程序间可以进行数据的交换"><a href="#就是用来实现网络互连的不同计算机上运行的程序间可以进行数据的交换" class="headerlink" title="就是用来实现网络互连的不同计算机上运行的程序间可以进行数据的交换"></a>就是用来实现网络互连的不同计算机上运行的程序间可以进行数据的交换</h3><h2 id="2、网络模型"><a href="#2、网络模型" class="headerlink" title="2、网络模型"></a>2、网络模型</h2><h3 id="1、OSI参考模型"><a href="#1、OSI参考模型" class="headerlink" title="1、OSI参考模型"></a>1、OSI参考模型</h3><h4 id="1、应用层"><a href="#1、应用层" class="headerlink" title="1、应用层"></a>1、应用层</h4><h4 id="2、表示层"><a href="#2、表示层" class="headerlink" title="2、表示层"></a>2、表示层</h4><h4 id="3、会话层"><a href="#3、会话层" class="headerlink" title="3、会话层"></a>3、会话层</h4><h4 id="4、传输层"><a href="#4、传输层" class="headerlink" title="4、传输层"></a>4、传输层</h4><h4 id="5、网络层"><a href="#5、网络层" class="headerlink" title="5、网络层"></a>5、网络层</h4><h4 id="6、数据链路层"><a href="#6、数据链路层" class="headerlink" title="6、数据链路层"></a>6、数据链路层</h4><h4 id="7、物理层"><a href="#7、物理层" class="headerlink" title="7、物理层"></a>7、物理层</h4><h3 id="2、TCP-IP参考模型"><a href="#2、TCP-IP参考模型" class="headerlink" title="2、TCP/IP参考模型"></a>2、TCP/IP参考模型</h3><h2 id="3、网络通信三要素"><a href="#3、网络通信三要素" class="headerlink" title="3、网络通信三要素"></a>3、网络通信三要素</h2><h3 id="1、IP地址"><a href="#1、IP地址" class="headerlink" title="1、IP地址"></a>1、IP地址</h3><h4 id="ABCDE类"><a href="#ABCDE类" class="headerlink" title="ABCDE类"></a>ABCDE类</h4><h4 id="IP地址-网络号码-主机地址"><a href="#IP地址-网络号码-主机地址" class="headerlink" title="IP地址=网络号码+主机地址"></a>IP地址=网络号码+主机地址</h4><h4 id="特殊地址：广播地址"><a href="#特殊地址：广播地址" class="headerlink" title="特殊地址：广播地址"></a>特殊地址：广播地址</h4><h3 id="2、端口号"><a href="#2、端口号" class="headerlink" title="2、端口号"></a>2、端口号</h3><h4 id="每个网络程序都会至少有个一逻辑端口"><a href="#每个网络程序都会至少有个一逻辑端口" class="headerlink" title="每个网络程序都会至少有个一逻辑端口"></a>每个网络程序都会至少有个一逻辑端口</h4><h4 id="用于标识进程的逻辑地址，不同进程的标识"><a href="#用于标识进程的逻辑地址，不同进程的标识" class="headerlink" title="用于标识进程的逻辑地址，不同进程的标识"></a>用于标识进程的逻辑地址，不同进程的标识</h4><h4 id="有效端口：0-65535，其中0-1024系统使用或保留端口"><a href="#有效端口：0-65535，其中0-1024系统使用或保留端口" class="headerlink" title="有效端口：0-65535，其中0-1024系统使用或保留端口"></a>有效端口：0-65535，其中0-1024系统使用或保留端口</h4><h3 id="3、协议UDP和TCP"><a href="#3、协议UDP和TCP" class="headerlink" title="3、协议UDP和TCP"></a>3、协议UDP和TCP</h3><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><h5 id="将数据源和目的封装成数据包中，不需要建立连接；每个数据报的大小限制在64K；因无连接，是不可靠协议；不需要建立连接，速度快"><a href="#将数据源和目的封装成数据包中，不需要建立连接；每个数据报的大小限制在64K；因无连接，是不可靠协议；不需要建立连接，速度快" class="headerlink" title="将数据源和目的封装成数据包中，不需要建立连接；每个数据报的大小限制在64K；因无连接，是不可靠协议；不需要建立连接，速度快"></a>将数据源和目的封装成数据包中，不需要建立连接；每个数据报的大小限制在64K；因无连接，是不可靠协议；不需要建立连接，速度快</h5><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><h5 id="建立连接，形成传输数据通道；在连接中进行大量数据传输；通过三次握手完成连接，是可靠协议；必须建立连接，效率会稍微低"><a href="#建立连接，形成传输数据通道；在连接中进行大量数据传输；通过三次握手完成连接，是可靠协议；必须建立连接，效率会稍微低" class="headerlink" title="建立连接，形成传输数据通道；在连接中进行大量数据传输；通过三次握手完成连接，是可靠协议；必须建立连接，效率会稍微低"></a>建立连接，形成传输数据通道；在连接中进行大量数据传输；通过三次握手完成连接，是可靠协议；必须建立连接，效率会稍微低</h5><p>一、TCP/IP协议</p>
<p>　　既然是网络编程，涉及几个系统之间的交互，那么首先要考虑的是如何准确的定位到网络上的一台或几台主机，另一个是如何进行可靠高效的数据传输。这里就要使用到TCP/IP协议。</p>
<p>　　TCP/IP协议（传输控制协议）由网络层的IP协议和传输层的TCP协议组成。IP层负责网络主机的定位，数据传输的路由，由IP地址可以唯一的确定Internet上的一台主机。<br>        TCP层负责面向应用的可靠的或非可靠的数据传输机制，这是网络编程的主要对象。</p>
<p>二、TCP与UDP</p>
<p>　　TCP是一种面向连接的保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个socket之间必须建立连接，以便在TCP协议的基础上进行通信，<br>当一个socket（通常都是server socket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送或接收操作。</p>
<p>　　UDP是一种面向无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。</p>
<p>TCP与UDP区别：</p>
<p>TCP特点：</p>
<p>　　1、TCP是面向连接的协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接协议，所以只能用于点对点的通讯。而且建立连接也需要消耗时间和开销。</p>
<p>　　2、TCP传输数据无大小限制，进行大数据传输。</p>
<p>　　3、TCP是一个可靠的协议，它能保证接收方能够完整正确地接收到发送方发送的全部数据。</p>
<p>UDP特点：</p>
<p>　　1、UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。</p>
<p>　　2、UDP传输数据时有大小限制，每个被传输的数据报必须限定在64KB之内。</p>
<p>　　3、UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。</p>
<p>TCP与UDP应用：</p>
<p>　　1、TCP在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。但是可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，<br>因此TCP传输的效率不如UDP高。</p>
<p>　　2，UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，<br>只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些。</p>
<h2 id="4、Socket"><a href="#4、Socket" class="headerlink" title="4、Socket"></a>4、Socket</h2><h3 id="Socket就是为网络编程提供的一种机制"><a href="#Socket就是为网络编程提供的一种机制" class="headerlink" title="Socket就是为网络编程提供的一种机制"></a>Socket就是为网络编程提供的一种机制</h3><h3 id="通信的两端都有Socket"><a href="#通信的两端都有Socket" class="headerlink" title="通信的两端都有Socket"></a>通信的两端都有Socket</h3><h3 id="网络通信其实就是Socket间的通信"><a href="#网络通信其实就是Socket间的通信" class="headerlink" title="网络通信其实就是Socket间的通信"></a>网络通信其实就是Socket间的通信</h3><h3 id="数据在两个Socket间通过IO传输"><a href="#数据在两个Socket间通过IO传输" class="headerlink" title="数据在两个Socket间通过IO传输"></a>数据在两个Socket间通过IO传输</h3><p>一、Socket是什么</p>
<p>　　Socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。网络上的两个程序通过一个双向的通讯连接实现数据的交换，<br>这个双向链路的一端称为一个Socket，一个Socket由一个IP地址和一个端口号唯一确定。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。<br>Socket是TCP/IP协议的一个十分流行的编程界面，但是，Socket所支持的协议种类也不光TCP/IP一种，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。</p>
<p>　　Socket通讯过程：服务端监听某个端口是否有连接请求，客户端向服务端发送连接请求，服务端收到连接请求向客户端发出接收消息，这样一个连接就建立起来了。客户端和服务端都可以相互发送消息与对方进行通讯。</p>
<p>　　Socket的基本工作过程包含以下四个步骤：</p>
<p>　　1、创建Socket；</p>
<p>　　2、打开连接到Socket的输入输出流；</p>
<p>　　3、按照一定的协议对Socket进行读写操作；</p>
<p>　　4、关闭Socket。<br>二、Java中的Socket</p>
<p>　　在java.net包下有两个类：Socket和ServerSocket。ServerSocket用于服务器端，Socket是建立网络连接时使用的。<br>在连接成功时，应用程序两端都会产生一个Socket实例，操作这个实例，完成所需的会话。对于一个网络连接来说，套接字是平等的，并没有差别，不因为在服务器端或在客户端而产生不同级别。<br>不管是Socket还是ServerSocket它们的工作都是通过SocketImpl类及其子类完成的。</p>
<p>列出几个常用的构造方法：</p>
<p>Socket(InetAddress address,int port);//创建一个流套接字并将其连接到指定 IP 地址的指定端口号<br>Socket(String host,int port);//创建一个流套接字并将其连接到指定主机上的指定端口号<br>Socket(InetAddress address,int port, InetAddress localAddr,int localPort);//创建一个套接字并将其连接到指定远程地址上的指定远程端口<br>Socket(String host,int port, InetAddress localAddr,int localPort);//创建一个套接字并将其连接到指定远程主机上的指定远程端口<br>Socket(SocketImpl impl);//使用用户指定的 SocketImpl 创建一个未连接 Socket</p>
<p>ServerSocket(int port);//创建绑定到特定端口的服务器套接字<br>ServerSocket(int port,int backlog);//利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号<br>ServerSocket(int port,int backlog, InetAddress bindAddr);//使用指定的端口、侦听 backlog 和要绑定到的本地 IP地址创建服务器<br>　　构造方法的参数中，address、host和port分别是双向连接中另一方的IP地址、主机名和端 口号，stream指明socket是流socket还是数据报socket，localPort表示本地主机的端口号，localAddr和bindAddr是本地机器的地址（ServerSocket的主机地址），impl是socket的父类，既可以用来创建serverSocket又可以用来创建Socket。count则表示服务端所能支持的最大连接数。</p>
<p>注意：必须小心选择端口号。每一个端口提供一种特定的服务，只有给出正确的端口，才 能获得相应的服务。0~1023的端口号为系统所保留，例如http服务的端口号为80,telnet服务的端口号为21,ftp服务的端口号为23, 所以我们在选择端口号时，最好选择一个大于1023的数以防止发生冲突。</p>
<p>几个重要的Socke方法：</p>
<p>public InputStream getInputStream();//方法获得网络连接输入，同时返回一个IutputStream对象实例<br>public OutputStream getOutputStream();//方法连接的另一端将得到输入，同时返回一个OutputStream对象实例<br>public Socket accept();//用于产生”阻塞”，直到接受到一个连接，并且返回一个客户端的Socket对象实例。<br>“阻塞”是一个术语，它使程序运行暂时”停留”在这个地方，直到一个会话产生，然后程序继续；通常”阻塞”是由循环产生的。</p>
<p>注意：其中getInputStream和getOutputStream方法均会产生一个IOException，它必须被捕获，因为它们返回的流对象，通常都会被另一个流对象使用。</p>
<p>三、基本的Client/Server程序</p>
<p>以下是一个基本的客户端/服务器端程序代码。主要实现了服务器端一直监听某个端口，等待客户端连接请求。客户端根据IP地址和端口号连接服务器端，从键盘上输入一行信息，发送到服务器端，然后接收服务器端返回的信息，最后结束会话。这个程序一次只能接受一个客户连接。</p>
<p>ps：这个小例子写好后，服务端一直接收不到消息，调试了好长时间，才发现误使用了PrintWriter的print()方法，而BufferedReader的readLine()方法一直没有遇到换行，所以一直等待读取</p>
<p>   客户端程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketClient</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/** 创建Socket*/</span></span><br><span class="line"><span class="comment">// 创建一个流套接字并将其连接到指定 IP 地址的指定端口号(本处是本机)</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">2013</span>);</span><br><span class="line"><span class="comment">// 60s超时</span></span><br><span class="line">socket.setSoTimeout(<span class="number">60000</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 发送客户端准备传输的信息 */</span></span><br><span class="line"><span class="comment">// 由Socket对象得到输出流，并构造PrintWriter对象</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(),<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 将输入读入的字符串输出到Server</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">sysBuff</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">printWriter.println(sysBuff.readLine());</span><br><span class="line"><span class="comment">// 刷新输出流，使Server马上收到该字符串</span></span><br><span class="line">printWriter.flush();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 用于获取服务端传输来的信息 */</span></span><br><span class="line"><span class="comment">// 由Socket对象得到输入流，并构造相应的BufferedReader对象</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line"><span class="comment">// 输入读入一字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">System.out.println(<span class="string">&quot;Server say : &quot;</span> + result);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 关闭Socket*/</span></span><br><span class="line">printWriter.close();</span><br><span class="line">bufferedReader.close();</span><br><span class="line">socket.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Exception:&quot;</span> + e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器端程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sock;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/** 创建ServerSocket*/</span></span><br><span class="line"><span class="comment">// 创建一个ServerSocket在端口2013监听客户请求</span></span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">2013</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 侦听并接受到此Socket的连接,请求到来则产生一个Socket对象，并继续执行</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 获取客户端传来的信息 */</span></span><br><span class="line"><span class="comment">// 由Socket对象得到输入流，并构造相应的BufferedReader对象</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line"><span class="comment">// 获取从客户端读入的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">System.out.println(<span class="string">&quot;Client say : &quot;</span> + result);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 发送服务端准备传输的 */</span></span><br><span class="line"><span class="comment">// 由Socket对象得到输出流，并构造PrintWriter对象</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream());</span><br><span class="line">printWriter.print(<span class="string">&quot;hello Client, I am Server!&quot;</span>);</span><br><span class="line">printWriter.flush();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 关闭Socket*/</span></span><br><span class="line">printWriter.close();</span><br><span class="line">bufferedReader.close();</span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Exception:&quot;</span> + e);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//  serverSocket.close();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、UDP传输"><a href="#5、UDP传输" class="headerlink" title="5、UDP传输"></a>5、UDP传输</h2><h3 id="DatagramSocket与DatagramPacket"><a href="#DatagramSocket与DatagramPacket" class="headerlink" title="DatagramSocket与DatagramPacket"></a>DatagramSocket与DatagramPacket</h3><h3 id="建立发送端，接收端"><a href="#建立发送端，接收端" class="headerlink" title="建立发送端，接收端"></a>建立发送端，接收端</h3><h3 id="建立数据包"><a href="#建立数据包" class="headerlink" title="建立数据包"></a>建立数据包</h3><h3 id="调用Socket的发送接收方法"><a href="#调用Socket的发送接收方法" class="headerlink" title="调用Socket的发送接收方法"></a>调用Socket的发送接收方法</h3><h3 id="关闭Socket"><a href="#关闭Socket" class="headerlink" title="关闭Socket"></a>关闭Socket</h3><h3 id="分支主题"><a href="#分支主题" class="headerlink" title="分支主题"></a>分支主题</h3><h2 id="6、TCP传输"><a href="#6、TCP传输" class="headerlink" title="6、TCP传输"></a>6、TCP传输</h2><h3 id="Socket和ServerSocket"><a href="#Socket和ServerSocket" class="headerlink" title="Socket和ServerSocket"></a>Socket和ServerSocket</h3><h3 id="建立客户端和服务器端"><a href="#建立客户端和服务器端" class="headerlink" title="建立客户端和服务器端"></a>建立客户端和服务器端</h3><h3 id="建立连接后，通过Socket中的IO流进行数据的传输"><a href="#建立连接后，通过Socket中的IO流进行数据的传输" class="headerlink" title="建立连接后，通过Socket中的IO流进行数据的传输"></a>建立连接后，通过Socket中的IO流进行数据的传输</h3><h3 id="关闭socket"><a href="#关闭socket" class="headerlink" title="关闭socket"></a>关闭socket</h3><h3 id="同样，客户端与服务器端是两个独立的应用程序"><a href="#同样，客户端与服务器端是两个独立的应用程序" class="headerlink" title="同样，客户端与服务器端是两个独立的应用程序"></a>同样，客户端与服务器端是两个独立的应用程序</h3><h4 id="三、重点知识点实例"><a href="#三、重点知识点实例" class="headerlink" title="三、重点知识点实例"></a>三、<em>重点知识点实例</em></h4><h4 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、<em>参考资料</em></h4><h4 id="五、思维扩展"><a href="#五、思维扩展" class="headerlink" title="五、思维扩展"></a>五、<em>思维扩展</em></h4><h4 id="六、存在疑问"><a href="#六、存在疑问" class="headerlink" title="六、存在疑问"></a>六、<em>存在疑问</em></h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/21/Java_8_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xieshanzhong">
      <meta itemprop="description" content="欢迎来到xieshanzhong的技术分享站~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XIE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/21/Java_8_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">Java_多线程并发(七)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-21 18:17:59" itemprop="dateCreated datePublished" datetime="2018-11-21T18:17:59+08:00">2018-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-03 16:46:51" itemprop="dateModified" datetime="2023-11-03T16:46:51+08:00">2023-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a>一、<em>思维导图</em></h4><h5 id="1、http-naotu-baidu-com-file-2ab52ad502d59fdd09f26e3413f1b9d9"><a href="#1、http-naotu-baidu-com-file-2ab52ad502d59fdd09f26e3413f1b9d9" class="headerlink" title="1、http://naotu.baidu.com/file/2ab52ad502d59fdd09f26e3413f1b9d9"></a>1、<a href="http://naotu.baidu.com/file/2ab52ad502d59fdd09f26e3413f1b9d9">http://naotu.baidu.com/file/2ab52ad502d59fdd09f26e3413f1b9d9</a></h5><h4 id="二、总知识点"><a href="#二、总知识点" class="headerlink" title="二、总知识点"></a>二、<em>总知识点</em></h4><h2 id="1、多线程基础"><a href="#1、多线程基础" class="headerlink" title="1、多线程基础"></a>1、多线程基础</h2><h3 id="1、线程与进程"><a href="#1、线程与进程" class="headerlink" title="1、线程与进程"></a>1、线程与进程</h3><h4 id="进程：一个正在执行的程序"><a href="#进程：一个正在执行的程序" class="headerlink" title="进程：一个正在执行的程序"></a>进程：一个正在执行的程序</h4><h4 id="线程：进程中负责程序执行的执行单元。一个进程中至少有一个线程"><a href="#线程：进程中负责程序执行的执行单元。一个进程中至少有一个线程" class="headerlink" title="线程：进程中负责程序执行的执行单元。一个进程中至少有一个线程"></a>线程：进程中负责程序执行的执行单元。一个进程中至少有一个线程</h4><h4 id="一个进程至少包含一个线程"><a href="#一个进程至少包含一个线程" class="headerlink" title="一个进程至少包含一个线程"></a>一个进程至少包含一个线程</h4><h4 id="进程在执行过程中拥有独立内存单元，而多个线程共享内存"><a href="#进程在执行过程中拥有独立内存单元，而多个线程共享内存" class="headerlink" title="进程在执行过程中拥有独立内存单元，而多个线程共享内存"></a>进程在执行过程中拥有独立内存单元，而多个线程共享内存</h4><h3 id="2、线程的实现"><a href="#2、线程的实现" class="headerlink" title="2、线程的实现"></a>2、线程的实现</h3><h4 id="1、继承Thread类重写run方法"><a href="#1、继承Thread类重写run方法" class="headerlink" title="1、继承Thread类重写run方法"></a>1、继承Thread类重写run方法</h4><h4 id="2、实现Runnable接口重写run方法"><a href="#2、实现Runnable接口重写run方法" class="headerlink" title="2、实现Runnable接口重写run方法"></a>2、实现Runnable接口重写run方法</h4><h3 id="3、线程的状态"><a href="#3、线程的状态" class="headerlink" title="3、线程的状态"></a>3、线程的状态</h3><h4 id="1、创建（new）"><a href="#1、创建（new）" class="headerlink" title="1、创建（new）"></a>1、创建（new）</h4><h4 id="2、就绪（runnable）"><a href="#2、就绪（runnable）" class="headerlink" title="2、就绪（runnable）"></a>2、就绪（runnable）</h4><h4 id="3、运行（running）"><a href="#3、运行（running）" class="headerlink" title="3、运行（running）"></a>3、运行（running）</h4><h4 id="4、堵塞（blocked）"><a href="#4、堵塞（blocked）" class="headerlink" title="4、堵塞（blocked）"></a>4、堵塞（blocked）</h4><h4 id="5、终止（dead）"><a href="#5、终止（dead）" class="headerlink" title="5、终止（dead）"></a>5、终止（dead）</h4><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><h4 id="存储和恢复CPU状态过程，它是的线程执行能够从中断恢复执行"><a href="#存储和恢复CPU状态过程，它是的线程执行能够从中断恢复执行" class="headerlink" title="存储和恢复CPU状态过程，它是的线程执行能够从中断恢复执行"></a>存储和恢复CPU状态过程，它是的线程执行能够从中断恢复执行</h4><h3 id="4、线程中常用方法"><a href="#4、线程中常用方法" class="headerlink" title="4、线程中常用方法"></a>4、线程中常用方法</h3><h4 id="1、静态方法"><a href="#1、静态方法" class="headerlink" title="1、静态方法"></a>1、静态方法</h4><h5 id="currentThread（），获得正在执行的线程"><a href="#currentThread（），获得正在执行的线程" class="headerlink" title="currentThread（），获得正在执行的线程"></a>currentThread（），获得正在执行的线程</h5><h5 id="sleep（long）线程休眠"><a href="#sleep（long）线程休眠" class="headerlink" title="sleep（long）线程休眠"></a>sleep（long）线程休眠</h5><h5 id="yield（）让出CPU"><a href="#yield（）让出CPU" class="headerlink" title="yield（）让出CPU"></a>yield（）让出CPU</h5><h4 id="2、对象方法"><a href="#2、对象方法" class="headerlink" title="2、对象方法"></a>2、对象方法</h4><h5 id="start启动线程"><a href="#start启动线程" class="headerlink" title="start启动线程"></a>start启动线程</h5><h5 id="setPriority-int"><a href="#setPriority-int" class="headerlink" title="setPriority(int)"></a>setPriority(int)</h5><h5 id="setDaemon-boolean-设置守护线程（后台线程）"><a href="#setDaemon-boolean-设置守护线程（后台线程）" class="headerlink" title="setDaemon(boolean)设置守护线程（后台线程）"></a>setDaemon(boolean)设置守护线程（后台线程）</h5><h5 id="interrupt-中断线程"><a href="#interrupt-中断线程" class="headerlink" title="interrupt()中断线程"></a>interrupt()中断线程</h5><h5 id="join（）等待该线程结束"><a href="#join（）等待该线程结束" class="headerlink" title="join（）等待该线程结束"></a>join（）等待该线程结束</h5><h3 id="5、停止线程"><a href="#5、停止线程" class="headerlink" title="5、停止线程"></a>5、停止线程</h3><h4 id="使用退出标志"><a href="#使用退出标志" class="headerlink" title="使用退出标志"></a>使用退出标志</h4><h4 id="使用stop方法（不推荐）"><a href="#使用stop方法（不推荐）" class="headerlink" title="使用stop方法（不推荐）"></a>使用stop方法（不推荐）</h4><h4 id="使用interrupt方法中断线程，但这个不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止"><a href="#使用interrupt方法中断线程，但这个不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止" class="headerlink" title="使用interrupt方法中断线程，但这个不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止"></a>使用interrupt方法中断线程，但这个不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止</h4><h3 id="6、线程同步"><a href="#6、线程同步" class="headerlink" title="6、线程同步"></a>6、线程同步</h3><h4 id="如何同步"><a href="#如何同步" class="headerlink" title="如何同步"></a>如何同步</h4><h5 id="java5以前，synchronized"><a href="#java5以前，synchronized" class="headerlink" title="java5以前，synchronized"></a>java5以前，synchronized</h5><h6 id="在方法上添加synchronized关键字"><a href="#在方法上添加synchronized关键字" class="headerlink" title="在方法上添加synchronized关键字"></a>在方法上添加synchronized关键字</h6><h6 id="同步代码块-，synchronized（对象）"><a href="#同步代码块-，synchronized（对象）" class="headerlink" title="同步代码块 ，synchronized（对象）"></a>同步代码块 ，synchronized（对象）</h6><h5 id="java5后"><a href="#java5后" class="headerlink" title="java5后"></a>java5后</h5><h6 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h6><h6 id="lock（）加锁"><a href="#lock（）加锁" class="headerlink" title="# lock（）加锁"></a># lock（）加锁</h6><h6 id="unlock（）解锁"><a href="#unlock（）解锁" class="headerlink" title="# unlock（）解锁"></a># unlock（）解锁</h6><h6 id="tryLock（）尝试获得锁"><a href="#tryLock（）尝试获得锁" class="headerlink" title="# tryLock（）尝试获得锁"></a># tryLock（）尝试获得锁</h6><h6 id="Semaphone"><a href="#Semaphone" class="headerlink" title="Semaphone"></a>Semaphone</h6><h6 id="acquire（）获取资源"><a href="#acquire（）获取资源" class="headerlink" title="# acquire（）获取资源"></a># acquire（）获取资源</h6><h6 id="release（）尝试获取锁"><a href="#release（）尝试获取锁" class="headerlink" title="# release（）尝试获取锁"></a># release（）尝试获取锁</h6><h6 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h6><h2 id="2、多线程中级"><a href="#2、多线程中级" class="headerlink" title="2、多线程中级"></a>2、多线程中级</h2><h3 id="1、控制线程"><a href="#1、控制线程" class="headerlink" title="1、控制线程"></a>1、控制线程</h3><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><h5 id="B调用Ajoin，要等A执行完毕B才执行"><a href="#B调用Ajoin，要等A执行完毕B才执行" class="headerlink" title="B调用Ajoin，要等A执行完毕B才执行"></a>B调用Ajoin，要等A执行完毕B才执行</h5><h5 id="就是说B的线程会堵塞"><a href="#就是说B的线程会堵塞" class="headerlink" title="就是说B的线程会堵塞"></a>就是说B的线程会堵塞</h5><h5 id="可以在构造函数里面传最大堵塞时间"><a href="#可以在构造函数里面传最大堵塞时间" class="headerlink" title="可以在构造函数里面传最大堵塞时间"></a>可以在构造函数里面传最大堵塞时间</h5><h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><h5 id="任务是给其他线程提供服务"><a href="#任务是给其他线程提供服务" class="headerlink" title="任务是给其他线程提供服务"></a>任务是给其他线程提供服务</h5><h5 id="当前台进程死亡，守护进程自动死亡"><a href="#当前台进程死亡，守护进程自动死亡" class="headerlink" title="当前台进程死亡，守护进程自动死亡"></a>当前台进程死亡，守护进程自动死亡</h5><h5 id="例如：java垃圾回收线程"><a href="#例如：java垃圾回收线程" class="headerlink" title="例如：java垃圾回收线程"></a>例如：java垃圾回收线程</h5><h5 id="setDeamo设置"><a href="#setDeamo设置" class="headerlink" title="setDeamo设置"></a>setDeamo设置</h5><h4 id="线程睡眠"><a href="#线程睡眠" class="headerlink" title="线程睡眠"></a>线程睡眠</h4><h5 id="主动进入堵塞状态，调用sleep方法"><a href="#主动进入堵塞状态，调用sleep方法" class="headerlink" title="主动进入堵塞状态，调用sleep方法"></a>主动进入堵塞状态，调用sleep方法</h5><h5 id="jdk以后推荐TimeUtil类睡眠"><a href="#jdk以后推荐TimeUtil类睡眠" class="headerlink" title="jdk以后推荐TimeUtil类睡眠"></a>jdk以后推荐TimeUtil类睡眠</h5><h4 id="线程让步"><a href="#线程让步" class="headerlink" title="线程让步"></a>线程让步</h4><h5 id="执行yield方法，让当前线程设置为就绪状态"><a href="#执行yield方法，让当前线程设置为就绪状态" class="headerlink" title="执行yield方法，让当前线程设置为就绪状态"></a>执行yield方法，让当前线程设置为就绪状态</h5><h5 id="当在完成一个方法最重要的功能时候，可以将处理器控制权让出去"><a href="#当在完成一个方法最重要的功能时候，可以将处理器控制权让出去" class="headerlink" title="当在完成一个方法最重要的功能时候，可以将处理器控制权让出去"></a>当在完成一个方法最重要的功能时候，可以将处理器控制权让出去</h5><h5 id="不保证让出去后马上得到处理器控制权"><a href="#不保证让出去后马上得到处理器控制权" class="headerlink" title="不保证让出去后马上得到处理器控制权"></a>不保证让出去后马上得到处理器控制权</h5><h4 id="改变线程的优先级"><a href="#改变线程的优先级" class="headerlink" title="改变线程的优先级"></a>改变线程的优先级</h4><h5 id="SetPriority-范围1-10"><a href="#SetPriority-范围1-10" class="headerlink" title="SetPriority 范围1-10"></a>SetPriority 范围1-10</h5><h5 id="推荐使用Thread的三个静态常量"><a href="#推荐使用Thread的三个静态常量" class="headerlink" title="推荐使用Thread的三个静态常量"></a>推荐使用Thread的三个静态常量</h5><h3 id="2、线程通信"><a href="#2、线程通信" class="headerlink" title="2、线程通信"></a>2、线程通信</h3><h4 id="协调运行的控制策略"><a href="#协调运行的控制策略" class="headerlink" title="协调运行的控制策略"></a>协调运行的控制策略</h4><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><h6 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h6><h6 id="释放当前线程锁定"><a href="#释放当前线程锁定" class="headerlink" title="# 释放当前线程锁定"></a># 释放当前线程锁定</h6><h6 id="例如：如果消费完，等待生产者将其"><a href="#例如：如果消费完，等待生产者将其" class="headerlink" title="# 例如：如果消费完，等待生产者将其"></a># 例如：如果消费完，等待生产者将其</h6><h6 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h6><h6 id="唤醒当前等待的线程"><a href="#唤醒当前等待的线程" class="headerlink" title="# 唤醒当前等待的线程"></a># 唤醒当前等待的线程</h6><h5 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h5><h6 id="使用Condition代替同步监视功能"><a href="#使用Condition代替同步监视功能" class="headerlink" title="使用Condition代替同步监视功能"></a>使用Condition代替同步监视功能</h6><h6 id="lock-newCondition"><a href="#lock-newCondition" class="headerlink" title="# lock.newCondition"></a># lock.newCondition</h6><h6 id="await代替wait"><a href="#await代替wait" class="headerlink" title="# await代替wait"></a># await代替wait</h6><h6 id="signal代替"><a href="#signal代替" class="headerlink" title="# signal代替"></a># signal代替</h6><h4 id="管道流通信"><a href="#管道流通信" class="headerlink" title="管道流通信"></a>管道流通信</h4><h5 id="使用new分别创建管道输入流（Piperead）和输出流（PipeRead）"><a href="#使用new分别创建管道输入流（Piperead）和输出流（PipeRead）" class="headerlink" title="使用new分别创建管道输入流（Piperead）和输出流（PipeRead）"></a>使用new分别创建管道输入流（Piperead）和输出流（PipeRead）</h5><h5 id="使用管道输入流或者管道输出流将对象用connect连接起来"><a href="#使用管道输入流或者管道输出流将对象用connect连接起来" class="headerlink" title="使用管道输入流或者管道输出流将对象用connect连接起来"></a>使用管道输入流或者管道输出流将对象用connect连接起来</h5><h5 id="将输入输出分别传入两个线程"><a href="#将输入输出分别传入两个线程" class="headerlink" title="将输入输出分别传入两个线程"></a>将输入输出分别传入两个线程</h5><h5 id="分别依赖各自的管道输入流，管道输出流进行通信"><a href="#分别依赖各自的管道输入流，管道输出流进行通信" class="headerlink" title="分别依赖各自的管道输入流，管道输出流进行通信"></a>分别依赖各自的管道输入流，管道输出流进行通信</h5><h5 id="两个线程分别依赖自己的管道流进行通信"><a href="#两个线程分别依赖自己的管道流进行通信" class="headerlink" title="两个线程分别依赖自己的管道流进行通信"></a>两个线程分别依赖自己的管道流进行通信</h5><h3 id="3、其他工具"><a href="#3、其他工具" class="headerlink" title="3、其他工具"></a>3、其他工具</h3><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h5 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h5><h5 id="当前线程作为key，要存的值为value"><a href="#当前线程作为key，要存的值为value" class="headerlink" title="当前线程作为key，要存的值为value"></a>当前线程作为key，要存的值为value</h5><h5 id="从线程的角度看，每个线程完全拥有该变量"><a href="#从线程的角度看，每个线程完全拥有该变量" class="headerlink" title="从线程的角度看，每个线程完全拥有该变量"></a>从线程的角度看，每个线程完全拥有该变量</h5><h5 id="实例，HibernateFactory生成session"><a href="#实例，HibernateFactory生成session" class="headerlink" title="实例，HibernateFactory生成session"></a>实例，HibernateFactory生成session</h5><h5 id="每个线程独立的改变自己的副本，和其他线程不产生冲突"><a href="#每个线程独立的改变自己的副本，和其他线程不产生冲突" class="headerlink" title="每个线程独立的改变自己的副本，和其他线程不产生冲突"></a>每个线程独立的改变自己的副本，和其他线程不产生冲突</h5><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><h5 id="提供将线程不安全的集合转为线程安全"><a href="#提供将线程不安全的集合转为线程安全" class="headerlink" title="提供将线程不安全的集合转为线程安全"></a>提供将线程不安全的集合转为线程安全</h5><h5 id="Collection-synchronizedMap-new-HashMap"><a href="#Collection-synchronizedMap-new-HashMap" class="headerlink" title="Collection.synchronizedMap(new HashMap)"></a>Collection.synchronizedMap(new HashMap)</h5><h4 id="线程安全的集合类"><a href="#线程安全的集合类" class="headerlink" title="线程安全的集合类"></a>线程安全的集合类</h4><h5 id="hashtable-vector-stack"><a href="#hashtable-vector-stack" class="headerlink" title="hashtable,vector,stack"></a>hashtable,vector,stack</h5><h5 id="ConCurrentHashMap"><a href="#ConCurrentHashMap" class="headerlink" title="ConCurrentHashMap"></a>ConCurrentHashMap</h5><h3 id="4、线程同步"><a href="#4、线程同步" class="headerlink" title="4、线程同步"></a>4、线程同步</h3><h4 id="当多个线程访问同一个资源时，加synchronized对资源进行加锁"><a href="#当多个线程访问同一个资源时，加synchronized对资源进行加锁" class="headerlink" title="当多个线程访问同一个资源时，加synchronized对资源进行加锁"></a>当多个线程访问同一个资源时，加synchronized对资源进行加锁</h4><h4 id="synchronized可以修饰代码块，修饰方法"><a href="#synchronized可以修饰代码块，修饰方法" class="headerlink" title="synchronized可以修饰代码块，修饰方法"></a>synchronized可以修饰代码块，修饰方法</h4><h4 id="只对可以改变竞争资源的方法加锁"><a href="#只对可以改变竞争资源的方法加锁" class="headerlink" title="只对可以改变竞争资源的方法加锁"></a>只对可以改变竞争资源的方法加锁</h4><h4 id="只有多线程才会出现线程安全"><a href="#只有多线程才会出现线程安全" class="headerlink" title="只有多线程才会出现线程安全"></a>只有多线程才会出现线程安全</h4><h4 id="释放锁条件"><a href="#释放锁条件" class="headerlink" title="释放锁条件"></a>释放锁条件</h4><h5 id="同步方法，代码块结束"><a href="#同步方法，代码块结束" class="headerlink" title="同步方法，代码块结束"></a>同步方法，代码块结束</h5><h5 id="出现未处理的异常"><a href="#出现未处理的异常" class="headerlink" title="出现未处理的异常"></a>出现未处理的异常</h5><h5 id="调用wait，将本线程置为就绪状态"><a href="#调用wait，将本线程置为就绪状态" class="headerlink" title="调用wait，将本线程置为就绪状态"></a>调用wait，将本线程置为就绪状态</h5><h5 id="sleep或者yield-suspend不会释放同步锁"><a href="#sleep或者yield-suspend不会释放同步锁" class="headerlink" title="sleep或者yield,suspend不会释放同步锁"></a>sleep或者yield,suspend不会释放同步锁</h5><h4 id="同步锁，显示加锁，释放锁"><a href="#同步锁，显示加锁，释放锁" class="headerlink" title="同步锁，显示加锁，释放锁"></a>同步锁，显示加锁，释放锁</h4><h5 id="读写锁（readWriteLock）"><a href="#读写锁（readWriteLock）" class="headerlink" title="读写锁（readWriteLock）"></a>读写锁（readWriteLock）</h5><h5 id="可重入锁（ReentrantLock）"><a href="#可重入锁（ReentrantLock）" class="headerlink" title="可重入锁（ReentrantLock）"></a>可重入锁（ReentrantLock）</h5><h6 id="对以加锁的继续加锁"><a href="#对以加锁的继续加锁" class="headerlink" title="对以加锁的继续加锁"></a>对以加锁的继续加锁</h6><h6 id="每一个lock方法都有一个unlock方法"><a href="#每一个lock方法都有一个unlock方法" class="headerlink" title="每一个lock方法都有一个unlock方法"></a>每一个lock方法都有一个unlock方法</h6><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h5 id="A调用B方法，B调用A方法"><a href="#A调用B方法，B调用A方法" class="headerlink" title="A调用B方法，B调用A方法"></a>A调用B方法，B调用A方法</h5><h5 id="A，B要相互等待执行完之后才执行"><a href="#A，B要相互等待执行完之后才执行" class="headerlink" title="A，B要相互等待执行完之后才执行"></a>A，B要相互等待执行完之后才执行</h5><h3 id="5、线程组"><a href="#5、线程组" class="headerlink" title="5、线程组"></a>5、线程组</h3><h4 id="默认情况下父线程创建子线程就是在同一线程下"><a href="#默认情况下父线程创建子线程就是在同一线程下" class="headerlink" title="默认情况下父线程创建子线程就是在同一线程下"></a>默认情况下父线程创建子线程就是在同一线程下</h4><h3 id="6、线程池"><a href="#6、线程池" class="headerlink" title="6、线程池"></a>6、线程池</h3><h4 id="用Executor创建线程池"><a href="#用Executor创建线程池" class="headerlink" title="用Executor创建线程池"></a>用Executor创建线程池</h4><h4 id="创建Runnable或Callable实例，作为任务类"><a href="#创建Runnable或Callable实例，作为任务类" class="headerlink" title="创建Runnable或Callable实例，作为任务类"></a>创建Runnable或Callable实例，作为任务类</h4><h4 id="向线程池提交线程"><a href="#向线程池提交线程" class="headerlink" title="向线程池提交线程"></a>向线程池提交线程</h4><h5 id="submit（有返回值）"><a href="#submit（有返回值）" class="headerlink" title="submit（有返回值）"></a>submit（有返回值）</h5><h5 id="execute无返回值，方便Exception"><a href="#execute无返回值，方便Exception" class="headerlink" title="execute无返回值，方便Exception"></a>execute无返回值，方便Exception</h5><h3 id="7、Callable和Futuer"><a href="#7、Callable和Futuer" class="headerlink" title="7、Callable和Futuer"></a>7、Callable和Futuer</h3><h4 id="带有返回值的“run”方法"><a href="#带有返回值的“run”方法" class="headerlink" title="带有返回值的“run”方法"></a>带有返回值的“run”方法</h4><h4 id="使用FutureTask接受Callable"><a href="#使用FutureTask接受Callable" class="headerlink" title="使用FutureTask接受Callable"></a>使用FutureTask接受Callable</h4><h4 id="使用get堵塞方法得到返回值"><a href="#使用get堵塞方法得到返回值" class="headerlink" title="使用get堵塞方法得到返回值"></a>使用get堵塞方法得到返回值</h4><h4 id="三、重点知识点实例"><a href="#三、重点知识点实例" class="headerlink" title="三、重点知识点实例"></a>三、<em>重点知识点实例</em></h4><h4 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、<em>参考资料</em></h4><h4 id="五、思维扩展"><a href="#五、思维扩展" class="headerlink" title="五、思维扩展"></a>五、<em>思维扩展</em></h4><h4 id="六、存在疑问"><a href="#六、存在疑问" class="headerlink" title="六、存在疑问"></a>六、<em>存在疑问</em></h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/21/Java_6_IO%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xieshanzhong">
      <meta itemprop="description" content="欢迎来到xieshanzhong的技术分享站~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XIE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/21/Java_6_IO%E6%B5%81/" class="post-title-link" itemprop="url">Java_IO流(六)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-21 17:17:59" itemprop="dateCreated datePublished" datetime="2018-11-21T17:17:59+08:00">2018-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-03 16:46:51" itemprop="dateModified" datetime="2023-11-03T16:46:51+08:00">2023-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a>一、<em>思维导图</em></h4><h5 id="1、http-naotu-baidu-com-file-b930dac74f4d0908c263cc59ff21341c"><a href="#1、http-naotu-baidu-com-file-b930dac74f4d0908c263cc59ff21341c" class="headerlink" title="1、http://naotu.baidu.com/file/b930dac74f4d0908c263cc59ff21341c"></a>1、<a href="http://naotu.baidu.com/file/b930dac74f4d0908c263cc59ff21341c">http://naotu.baidu.com/file/b930dac74f4d0908c263cc59ff21341c</a></h5><h4 id="二、总知识点"><a href="#二、总知识点" class="headerlink" title="二、总知识点"></a>二、<em>总知识点</em></h4><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><h3 id="流可以被定义为一个序列的数据。输入流用来从一个源中读数据，输出流用来向一个目的地写数据"><a href="#流可以被定义为一个序列的数据。输入流用来从一个源中读数据，输出流用来向一个目的地写数据" class="headerlink" title="流可以被定义为一个序列的数据。输入流用来从一个源中读数据，输出流用来向一个目的地写数据"></a>流可以被定义为一个序列的数据。输入流用来从一个源中读数据，输出流用来向一个目的地写数据</h3><h3 id="1、用于处理设备之间的数据传输"><a href="#1、用于处理设备之间的数据传输" class="headerlink" title="1、用于处理设备之间的数据传输"></a>1、用于处理设备之间的数据传输</h3><h3 id="2、Java对数据的操作时通过流的方式"><a href="#2、Java对数据的操作时通过流的方式" class="headerlink" title="2、Java对数据的操作时通过流的方式"></a>2、Java对数据的操作时通过流的方式</h3><h3 id="3、流只能操作数据"><a href="#3、流只能操作数据" class="headerlink" title="3、流只能操作数据"></a>3、流只能操作数据</h3><h2 id="2、流对象的基本规律"><a href="#2、流对象的基本规律" class="headerlink" title="2、流对象的基本规律"></a>2、流对象的基本规律</h2><h3 id="1、-明确源和目的"><a href="#1、-明确源和目的" class="headerlink" title="1、 明确源和目的"></a>1、 明确源和目的</h3><h4 id="源：输入流"><a href="#源：输入流" class="headerlink" title="源：输入流"></a>源：输入流</h4><h5 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h5><h5 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h5><h4 id="目的：输出流"><a href="#目的：输出流" class="headerlink" title="目的：输出流"></a>目的：输出流</h4><h5 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h5><h5 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h5><h3 id="2、明确操作的数据是否为纯文本"><a href="#2、明确操作的数据是否为纯文本" class="headerlink" title="2、明确操作的数据是否为纯文本"></a>2、明确操作的数据是否为纯文本</h3><h4 id="纯文本，字符流"><a href="#纯文本，字符流" class="headerlink" title="纯文本，字符流"></a>纯文本，字符流</h4><h4 id="非纯文本，字节流"><a href="#非纯文本，字节流" class="headerlink" title="非纯文本，字节流"></a>非纯文本，字节流</h4><h3 id="3、当体系明确后，在明确要使用的那个具体对象"><a href="#3、当体系明确后，在明确要使用的那个具体对象" class="headerlink" title="3、当体系明确后，在明确要使用的那个具体对象"></a>3、当体系明确后，在明确要使用的那个具体对象</h3><h2 id="3、IO异常处理"><a href="#3、IO异常处理" class="headerlink" title="3、IO异常处理"></a>3、IO异常处理</h2><h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><h4 id="在外建立引用，在try内建立对象"><a href="#在外建立引用，在try内建立对象" class="headerlink" title="在外建立引用，在try内建立对象"></a>在外建立引用，在try内建立对象</h4><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="家人存在多个流，一定要分别去判断关闭流，不能只判断一次"><a href="#家人存在多个流，一定要分别去判断关闭流，不能只判断一次" class="headerlink" title="家人存在多个流，一定要分别去判断关闭流，不能只判断一次"></a>家人存在多个流，一定要分别去判断关闭流，不能只判断一次</h4><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="log4j-可以完成日志信息的建立"><a href="#log4j-可以完成日志信息的建立" class="headerlink" title="log4j,可以完成日志信息的建立"></a>log4j,可以完成日志信息的建立</h4><h2 id="4、分类"><a href="#4、分类" class="headerlink" title="4、分类"></a>4、分类</h2><h3 id="1、按流向分类"><a href="#1、按流向分类" class="headerlink" title="1、按流向分类"></a>1、按流向分类</h3><h4 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h4><h5 id="程序从输入流中读取数据"><a href="#程序从输入流中读取数据" class="headerlink" title="程序从输入流中读取数据"></a>程序从输入流中读取数据</h5><h4 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h4><h5 id="程序向输出流中写入数据"><a href="#程序向输出流中写入数据" class="headerlink" title="程序向输出流中写入数据"></a>程序向输出流中写入数据</h5><h3 id="2、按操作数据分类"><a href="#2、按操作数据分类" class="headerlink" title="2、按操作数据分类"></a>2、按操作数据分类</h3><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><h6 id="用于处理文字"><a href="#用于处理文字" class="headerlink" title="用于处理文字"></a>用于处理文字</h6><h5 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h5><h6 id="InputStream-1"><a href="#InputStream-1" class="headerlink" title="InputStream"></a>InputStream</h6><h6 id="是字节输入流的所有类的超类"><a href="#是字节输入流的所有类的超类" class="headerlink" title="# 是字节输入流的所有类的超类"></a># 是字节输入流的所有类的超类</h6><h6 id="已知直接子类"><a href="#已知直接子类" class="headerlink" title="# 已知直接子类"></a># 已知直接子类</h6><h6 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="## FileInputStream"></a>## FileInputStream</h6><h6 id="FillterInputStream"><a href="#FillterInputStream" class="headerlink" title="## FillterInputStream"></a>## FillterInputStream</h6><h6 id="AudioInputStream"><a href="#AudioInputStream" class="headerlink" title="## AudioInputStream"></a>## AudioInputStream</h6><h6 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="## ByteArrayInputStream"></a>## ByteArrayInputStream</h6><h6 id="操作字节数组"><a href="#操作字节数组" class="headerlink" title="### 操作字节数组"></a>### 操作字节数组</h6><h6 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="## ObjectInputStream"></a>## ObjectInputStream</h6><h6 id="PipedInputStream"><a href="#PipedInputStream" class="headerlink" title="## PipedInputStream"></a>## PipedInputStream</h6><h6 id="SequenceInputStream"><a href="#SequenceInputStream" class="headerlink" title="##   SequenceInputStream"></a>##   SequenceInputStream</h6><h6 id="OutputStream-1"><a href="#OutputStream-1" class="headerlink" title="OutputStream"></a>OutputStream</h6><h6 id="输出字节流的所有类的超类"><a href="#输出字节流的所有类的超类" class="headerlink" title="# 输出字节流的所有类的超类"></a># 输出字节流的所有类的超类</h6><h6 id="不需要刷新。一般不需要缓冲区"><a href="#不需要刷新。一般不需要缓冲区" class="headerlink" title="# 不需要刷新。一般不需要缓冲区"></a># 不需要刷新。一般不需要缓冲区</h6><h6 id="已知直接子类-1"><a href="#已知直接子类-1" class="headerlink" title="# 已知直接子类"></a># 已知直接子类</h6><h6 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="## FileOutputStream"></a>## FileOutputStream</h6><h6 id="FillteOutputStream"><a href="#FillteOutputStream" class="headerlink" title="## FillteOutputStream"></a>## FillteOutputStream</h6><h6 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="## ByteArrayOutputStream"></a>## ByteArrayOutputStream</h6><h6 id="操作字节数组-1"><a href="#操作字节数组-1" class="headerlink" title="### 操作字节数组"></a>### 操作字节数组</h6><h6 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="## ObjectOutputStream"></a>## ObjectOutputStream</h6><h6 id="PipedOutputStream"><a href="#PipedOutputStream" class="headerlink" title="## PipedOutputStream"></a>## PipedOutputStream</h6><h5 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h5><h6 id="BuffedOutputStream"><a href="#BuffedOutputStream" class="headerlink" title="BuffedOutputStream"></a>BuffedOutputStream</h6><h6 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h6><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><h5 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h5><h6 id="用于处理文字-1"><a href="#用于处理文字-1" class="headerlink" title="用于处理文字"></a>用于处理文字</h6><h5 id="2、抽象基类"><a href="#2、抽象基类" class="headerlink" title="2、抽象基类"></a>2、抽象基类</h5><h6 id="Reader-1"><a href="#Reader-1" class="headerlink" title="Reader"></a>Reader</h6><h6 id="读取字符流"><a href="#读取字符流" class="headerlink" title="# 读取字符流"></a># 读取字符流</h6><h6 id="已知直接子类-2"><a href="#已知直接子类-2" class="headerlink" title="# 已知直接子类"></a># 已知直接子类</h6><h6 id="FileReader"><a href="#FileReader" class="headerlink" title="## FileReader"></a>## FileReader</h6><h6 id="CharArrayReader"><a href="#CharArrayReader" class="headerlink" title="## CharArrayReader"></a>## CharArrayReader</h6><h6 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="## InputStreamReader"></a>## InputStreamReader</h6><h6 id="PipedReader"><a href="#PipedReader" class="headerlink" title="## PipedReader"></a>## PipedReader</h6><h6 id="PrintReader"><a href="#PrintReader" class="headerlink" title="## PrintReader"></a>## PrintReader</h6><h6 id="StringReader"><a href="#StringReader" class="headerlink" title="## StringReader"></a>## StringReader</h6><h6 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="##  BufferedReader"></a>##  BufferedReader</h6><h6 id="操作字符串"><a href="#操作字符串" class="headerlink" title="### 操作字符串"></a>### 操作字符串</h6><h6 id="Writer-1"><a href="#Writer-1" class="headerlink" title="Writer"></a>Writer</h6><h6 id="写入字符流"><a href="#写入字符流" class="headerlink" title="# 写入字符流"></a># 写入字符流</h6><h6 id="已知直接子类-3"><a href="#已知直接子类-3" class="headerlink" title="# 已知直接子类"></a># 已知直接子类</h6><h6 id="FileWriter"><a href="#FileWriter" class="headerlink" title="## FileWriter"></a>## FileWriter</h6><h6 id="继承OutputStreamWriter类"><a href="#继承OutputStreamWriter类" class="headerlink" title="###  继承OutputStreamWriter类"></a>###  继承OutputStreamWriter类</h6><h6 id="用于操作文件"><a href="#用于操作文件" class="headerlink" title="### 用于操作文件"></a>### 用于操作文件</h6><h6 id="步骤"><a href="#步骤" class="headerlink" title="### 步骤"></a>### 步骤</h6><h6 id="1、创建文件（FileWriter对象）"><a href="#1、创建文件（FileWriter对象）" class="headerlink" title="#### 1、创建文件（FileWriter对象）"></a>#### 1、创建文件（FileWriter对象）</h6><h6 id="2、调用writer方法，将字符串写入（内存）流中"><a href="#2、调用writer方法，将字符串写入（内存）流中" class="headerlink" title="#### 2、调用writer方法，将字符串写入（内存）流中"></a>#### 2、调用writer方法，将字符串写入（内存）流中</h6><h6 id="3、刷新流对象中的缓冲区数据：fw-flush"><a href="#3、刷新流对象中的缓冲区数据：fw-flush" class="headerlink" title="#### 3、刷新流对象中的缓冲区数据：fw.flush()"></a>#### 3、刷新流对象中的缓冲区数据：fw.flush()</h6><h6 id="4、关闭流资源-fw-close"><a href="#4、关闭流资源-fw-close" class="headerlink" title="#### 4、关闭流资源:fw.close()"></a>#### 4、关闭流资源:fw.close()</h6><h6 id="flush与close的区别"><a href="#flush与close的区别" class="headerlink" title="### flush与close的区别"></a>### flush与close的区别</h6><h6 id="flush刷新后，流一直存在，可以继续写入数据"><a href="#flush刷新后，流一直存在，可以继续写入数据" class="headerlink" title="#### flush刷新后，流一直存在，可以继续写入数据"></a>#### flush刷新后，流一直存在，可以继续写入数据</h6><h6 id="close刷新后会将流关闭，不能再继续写入数据，关闭资源"><a href="#close刷新后会将流关闭，不能再继续写入数据，关闭资源" class="headerlink" title="#### close刷新后会将流关闭，不能再继续写入数据，关闭资源"></a>#### close刷新后会将流关闭，不能再继续写入数据，关闭资源</h6><h6 id="CharArrayWriter"><a href="#CharArrayWriter" class="headerlink" title="## CharArrayWriter"></a>## CharArrayWriter</h6><h6 id="操作字符数组"><a href="#操作字符数组" class="headerlink" title="### 操作字符数组"></a>### 操作字符数组</h6><h6 id="不用进行close关闭"><a href="#不用进行close关闭" class="headerlink" title="### 不用进行close关闭"></a>### 不用进行close关闭</h6><h6 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="## OutputStreamWriter"></a>## OutputStreamWriter</h6><h6 id="PipedWriter"><a href="#PipedWriter" class="headerlink" title="## PipedWriter"></a>## PipedWriter</h6><h6 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="## PrintWriter"></a>## PrintWriter</h6><h6 id="StringWriter"><a href="#StringWriter" class="headerlink" title="## StringWriter"></a>## StringWriter</h6><h6 id="操作字符串-1"><a href="#操作字符串-1" class="headerlink" title="### 操作字符串"></a>### 操作字符串</h6><h6 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="## BufferedWriter"></a>## BufferedWriter</h6><h5 id="3、缓冲区"><a href="#3、缓冲区" class="headerlink" title="3、缓冲区"></a>3、缓冲区</h5><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><h6 id="将数组封装，变成对象再使用"><a href="#将数组封装，变成对象再使用" class="headerlink" title="# 将数组封装，变成对象再使用"></a># 将数组封装，变成对象再使用</h6><h6 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h6><h6 id="提高流的操作效率"><a href="#提高流的操作效率" class="headerlink" title="# 提高流的操作效率"></a># 提高流的操作效率</h6><h6 id="对应类"><a href="#对应类" class="headerlink" title="对应类"></a>对应类</h6><h6 id="BufferedReader-1"><a href="#BufferedReader-1" class="headerlink" title="# BufferedReader"></a># BufferedReader</h6><h6 id="从字符输入流中读取文本，缓冲各个字符，从而实现字符，数组和行的高效读取"><a href="#从字符输入流中读取文本，缓冲各个字符，从而实现字符，数组和行的高效读取" class="headerlink" title="## 从字符输入流中读取文本，缓冲各个字符，从而实现字符，数组和行的高效读取"></a>## 从字符输入流中读取文本，缓冲各个字符，从而实现字符，数组和行的高效读取</h6><h6 id="步骤-1"><a href="#步骤-1" class="headerlink" title="## 步骤"></a>## 步骤</h6><h6 id="1、创建一个读取流对象和文件相关联"><a href="#1、创建一个读取流对象和文件相关联" class="headerlink" title="### 1、创建一个读取流对象和文件相关联"></a>### 1、创建一个读取流对象和文件相关联</h6><h6 id="2、为了提高效率，加入缓冲技术。将字符读取流对象作为参数传递给缓冲对象函数的构造函数"><a href="#2、为了提高效率，加入缓冲技术。将字符读取流对象作为参数传递给缓冲对象函数的构造函数" class="headerlink" title="### 2、为了提高效率，加入缓冲技术。将字符读取流对象作为参数传递给缓冲对象函数的构造函数"></a>### 2、为了提高效率，加入缓冲技术。将字符读取流对象作为参数传递给缓冲对象函数的构造函数</h6><h6 id="3、读取缓冲区"><a href="#3、读取缓冲区" class="headerlink" title="### 3、读取缓冲区"></a>### 3、读取缓冲区</h6><h6 id="4、关闭缓冲区资源"><a href="#4、关闭缓冲区资源" class="headerlink" title="### 4、关闭缓冲区资源"></a>### 4、关闭缓冲区资源</h6><h6 id="子类"><a href="#子类" class="headerlink" title="## 子类"></a>## 子类</h6><h6 id="LineNumberReader"><a href="#LineNumberReader" class="headerlink" title="### LineNumberReader"></a>### LineNumberReader</h6><h6 id="跟踪行号缓冲字符输入流"><a href="#跟踪行号缓冲字符输入流" class="headerlink" title="#### 跟踪行号缓冲字符输入流"></a>#### 跟踪行号缓冲字符输入流</h6><h6 id="默认行编号从0开始"><a href="#默认行编号从0开始" class="headerlink" title="#### 默认行编号从0开始"></a>#### 默认行编号从0开始</h6><h6 id="BufferedWriter-1"><a href="#BufferedWriter-1" class="headerlink" title="# BufferedWriter"></a># BufferedWriter</h6><h6 id="字符流的缓冲区"><a href="#字符流的缓冲区" class="headerlink" title="## 字符流的缓冲区"></a>## 字符流的缓冲区</h6><h6 id="提高了对数据的读写效率"><a href="#提高了对数据的读写效率" class="headerlink" title="## 提高了对数据的读写效率"></a>## 提高了对数据的读写效率</h6><h6 id="在创建缓冲区前，必须要先用流对象"><a href="#在创建缓冲区前，必须要先用流对象" class="headerlink" title="## 在创建缓冲区前，必须要先用流对象"></a>## 在创建缓冲区前，必须要先用流对象</h6><h6 id="缓冲技术步骤"><a href="#缓冲技术步骤" class="headerlink" title="## 缓冲技术步骤"></a>## 缓冲技术步骤</h6><h5 id="4、转换类"><a href="#4、转换类" class="headerlink" title="4、转换类"></a>4、转换类</h5><h6 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h6><h6 id="字符编码转换"><a href="#字符编码转换" class="headerlink" title="# 字符编码转换"></a># 字符编码转换</h6><h6 id="字符和字节之间的桥梁"><a href="#字符和字节之间的桥梁" class="headerlink" title="# 字符和字节之间的桥梁"></a># 字符和字节之间的桥梁</h6><h6 id="字节转字符"><a href="#字节转字符" class="headerlink" title="字节转字符"></a>字节转字符</h6><h6 id="InputStreamReader-1"><a href="#InputStreamReader-1" class="headerlink" title="# InputStreamReader"></a># InputStreamReader</h6><h6 id="本身是字符流"><a href="#本身是字符流" class="headerlink" title="## 本身是字符流"></a>## 本身是字符流</h6><h6 id="为提高效率，可以在BufferedReader内包装InputStreamReader"><a href="#为提高效率，可以在BufferedReader内包装InputStreamReader" class="headerlink" title="## 为提高效率，可以在BufferedReader内包装InputStreamReader"></a>## 为提高效率，可以在BufferedReader内包装InputStreamReader</h6><h6 id="字符转字节"><a href="#字符转字节" class="headerlink" title="字符转字节"></a>字符转字节</h6><h6 id="OutputStreamWriter-1"><a href="#OutputStreamWriter-1" class="headerlink" title="# OutputStreamWriter"></a># OutputStreamWriter</h6><h6 id="本身是字符流-1"><a href="#本身是字符流-1" class="headerlink" title="## 本身是字符流"></a>## 本身是字符流</h6><h6 id="主要操作在控制台"><a href="#主要操作在控制台" class="headerlink" title="## 主要操作在控制台"></a>## 主要操作在控制台</h6><h6 id="为获取最高效率，可将OutputStreamWriter包装到BufferedWriter，避免频繁调用转换器"><a href="#为获取最高效率，可将OutputStreamWriter包装到BufferedWriter，避免频繁调用转换器" class="headerlink" title="## 为获取最高效率，可将OutputStreamWriter包装到BufferedWriter，避免频繁调用转换器"></a>## 为获取最高效率，可将OutputStreamWriter包装到BufferedWriter，避免频繁调用转换器</h6><h3 id="3、IO包其他类"><a href="#3、IO包其他类" class="headerlink" title="3、IO包其他类"></a>3、IO包其他类</h3><h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><h5 id="可以直接操作输入流和文件"><a href="#可以直接操作输入流和文件" class="headerlink" title="可以直接操作输入流和文件"></a>可以直接操作输入流和文件</h5><h5 id="PrintWriter-1"><a href="#PrintWriter-1" class="headerlink" title="PrintWriter"></a>PrintWriter</h5><h6 id="字符打印流"><a href="#字符打印流" class="headerlink" title="字符打印流"></a>字符打印流</h6><h6 id="为其他输出流添加功能"><a href="#为其他输出流添加功能" class="headerlink" title="为其他输出流添加功能"></a>为其他输出流添加功能</h6><h6 id="永远不会抛出IOException"><a href="#永远不会抛出IOException" class="headerlink" title="永远不会抛出IOException"></a>永远不会抛出IOException</h6><h6 id="在需要写入字符而不是写入字节的情况下使用"><a href="#在需要写入字符而不是写入字节的情况下使用" class="headerlink" title="在需要写入字符而不是写入字节的情况下使用"></a>在需要写入字符而不是写入字节的情况下使用</h6><h5 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h5><h6 id="字节打印流"><a href="#字节打印流" class="headerlink" title="字节打印流"></a>字节打印流</h6><h6 id="打印的所有字符都使用平台的默认字符编码转换为字节"><a href="#打印的所有字符都使用平台的默认字符编码转换为字节" class="headerlink" title="打印的所有字符都使用平台的默认字符编码转换为字节"></a>打印的所有字符都使用平台的默认字符编码转换为字节</h6><h4 id="序列流"><a href="#序列流" class="headerlink" title="序列流"></a>序列流</h4><h5 id="对多个流进行合并"><a href="#对多个流进行合并" class="headerlink" title="对多个流进行合并"></a>对多个流进行合并</h5><h5 id="SequenceInputStream-1"><a href="#SequenceInputStream-1" class="headerlink" title="SequenceInputStream"></a>SequenceInputStream</h5><h6 id="表示其他输入流的逻辑串联"><a href="#表示其他输入流的逻辑串联" class="headerlink" title="表示其他输入流的逻辑串联"></a>表示其他输入流的逻辑串联</h6><h6 id="没有对应的输出流类"><a href="#没有对应的输出流类" class="headerlink" title="没有对应的输出流类"></a>没有对应的输出流类</h6><h4 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h4><h5 id="被操作的对象需要实现Serializable（标记接口）"><a href="#被操作的对象需要实现Serializable（标记接口）" class="headerlink" title="被操作的对象需要实现Serializable（标记接口）"></a>被操作的对象需要实现Serializable（标记接口）</h5><h5 id="ObjectInputStream-1"><a href="#ObjectInputStream-1" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h5><h5 id="ObjectOutputStream-1"><a href="#ObjectOutputStream-1" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h5><h6 id="将java对象的基本类型和图形写入OutputStream"><a href="#将java对象的基本类型和图形写入OutputStream" class="headerlink" title="将java对象的基本类型和图形写入OutputStream"></a>将java对象的基本类型和图形写入OutputStream</h6><h4 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h4><h5 id="随机访问文件，自身具备读写的方法"><a href="#随机访问文件，自身具备读写的方法" class="headerlink" title="随机访问文件，自身具备读写的方法"></a>随机访问文件，自身具备读写的方法</h5><h5 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h5><h6 id="父类是Object的特殊类"><a href="#父类是Object的特殊类" class="headerlink" title="父类是Object的特殊类"></a>父类是Object的特殊类</h6><h6 id="通过skipByte（int-seek-int-x-来达到随机访问"><a href="#通过skipByte（int-seek-int-x-来达到随机访问" class="headerlink" title="通过skipByte（int),seek(int x)来达到随机访问"></a>通过skipByte（int),seek(int x)来达到随机访问</h6><h6 id="可以实现多线程下载"><a href="#可以实现多线程下载" class="headerlink" title="可以实现多线程下载"></a>可以实现多线程下载</h6><h4 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h4><h5 id="输入输出流可以直接进行连接，通过结合线程使用"><a href="#输入输出流可以直接进行连接，通过结合线程使用" class="headerlink" title="输入输出流可以直接进行连接，通过结合线程使用"></a>输入输出流可以直接进行连接，通过结合线程使用</h5><h5 id="PipedOutputStream-1"><a href="#PipedOutputStream-1" class="headerlink" title="PipedOutputStream"></a>PipedOutputStream</h5><h5 id="PipedInputStream-1"><a href="#PipedInputStream-1" class="headerlink" title="PipedInputStream"></a>PipedInputStream</h5><h4 id="操作基本数据类型"><a href="#操作基本数据类型" class="headerlink" title="操作基本数据类型"></a>操作基本数据类型</h4><h5 id="输入输出可以直接进行连接，通过结合线程使用"><a href="#输入输出可以直接进行连接，通过结合线程使用" class="headerlink" title="输入输出可以直接进行连接，通过结合线程使用"></a>输入输出可以直接进行连接，通过结合线程使用</h5><h5 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h5><h5 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h5><h4 id="三、重点知识点实例"><a href="#三、重点知识点实例" class="headerlink" title="三、重点知识点实例"></a>三、<em>重点知识点实例</em></h4><h4 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、<em>参考资料</em></h4><h4 id="五、思维扩展"><a href="#五、思维扩展" class="headerlink" title="五、思维扩展"></a>五、<em>思维扩展</em></h4><h4 id="六、存在疑问"><a href="#六、存在疑问" class="headerlink" title="六、存在疑问"></a>六、<em>存在疑问</em></h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/21/Java_5_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xieshanzhong">
      <meta itemprop="description" content="欢迎来到xieshanzhong的技术分享站~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XIE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/21/Java_5_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">Java_集合框架(五)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-21 16:17:59" itemprop="dateCreated datePublished" datetime="2018-11-21T16:17:59+08:00">2018-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-01 14:17:31" itemprop="dateModified" datetime="2024-03-01T14:17:31+08:00">2024-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a>一、思维导图</h1><p><a href="https://www.yuque.com/attachments/yuque/0/2024/xmind/227879/1709105148194-5f1d05c4-22cf-45fc-a684-f0a2c6c1ddef.xmind">Java集合框架.xmind</a></p>
<h1 id="二、知识点及实践"><a href="#二、知识点及实践" class="headerlink" title="二、知识点及实践"></a>二、知识点及实践</h1><h2 id="2-1、Collection"><a href="#2-1、Collection" class="headerlink" title="2.1、Collection"></a>2.1、Collection</h2><ol>
<li><strong>List</strong></li>
</ol>
<p>列表（元素有序并且可以重复的集合，被称为序列）</p>
<pre><code>  1. ArrayList
</code></pre><ul>
<li>排列有序，可重复</li>
<li>底层使用数组</li>
<li>查询快，增删慢</li>
<li>线程不安全</li>
<li>当容量不够时，ArrayList是当前容量*1.5+1</li>
</ul>
<p><img src="/2018/11/21/Java_5_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1709198066892-70eb7172-4d95-46bc-a5e5-ab731a13db08.png" alt="ArrayList.png"></p>
<pre><code>  2. LinkedList
</code></pre><ul>
<li>排列有序，可重复</li>
<li>底层使用双向循环链接数据结构</li>
<li>查询慢，增删快</li>
<li>线程不安全</li>
</ul>
<p><img src="/2018/11/21/Java_5_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1709198105162-755e931d-82a8-4489-a128-ca7a81cc2a95.png" alt="LinkedList.png"></p>
<pre><code>  3. Vector
</code></pre><ul>
<li>排列有序，可重复</li>
<li>底层使用数组</li>
<li>查询快，增删慢</li>
<li>线程安全，效率低</li>
<li><p>当容量不够时，Vector是当前容量1</p>
<ol>
<li>Stack</li>
</ol>
</li>
<li><p>栈是Vector的一个子类，它实现了一个标准的后进先出的栈</p>
</li>
</ul>
<ol>
<li><strong>Set</strong></li>
</ol>
<p>集合（不能加入重复元素，无序）</p>
<pre><code>  1. HashSet
</code></pre><ul>
<li>排列无序，不可重复</li>
<li>底层使用Hash表实现</li>
<li>存取速度快</li>
<li>内部是HashMap</li>
</ul>
<p><img src="/2018/11/21/Java_5_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1709198121824-d393713b-9b64-4afc-be9a-dec435d88d32.png" alt="HashSet.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetData</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; stringSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        stringSet.addAll(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出Set集合</span></span><br><span class="line">        stringSet.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        SortedSet&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Set.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>));</span><br><span class="line">        SortedSet&lt;String&gt; subSet = strings.subSet(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sub set = &quot;</span> + subSet);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; strings1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>));</span><br><span class="line">        List&lt;String&gt; immutableStrings = Collections.unmodifiableList(strings1);</span><br><span class="line">        System.out.println(immutableStrings);</span><br><span class="line">        strings.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(immutableStrings);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>  2. TreeSet
</code></pre><ul>
<li>排列无序，不可重复</li>
<li>底层使用二叉树实现</li>
<li>排序存储</li>
<li>内部是TreeMap的SortedSet</li>
</ul>
<p><img src="/2018/11/21/Java_5_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1709198189329-b8914d54-3fd8-469f-abd3-0bd0ad2a95c4.png" alt="TreeSet.png"></p>
<pre><code>  3. LinkedHashSet
</code></pre><ul>
<li>采用hash表存储，并用双向链表记录插入顺序</li>
<li>内部是LinkedHashMap</li>
</ul>
<ol>
<li>Queue</li>
</ol>
<p>在两端出入的List，所以也可以用数组或链表来实现</p>
<h2 id="2-2、Map"><a href="#2-2、Map" class="headerlink" title="2.2、Map"></a>2.2、Map</h2><ol>
<li>HashMap</li>
</ol>
<ul>
<li>Map提供了一种映射关系，其中的元素是以键值对（key-value）的形式存储的，能够实现根据key快速查找value</li>
<li>Map中的键值对以Entry类型的对象实例形式存在</li>
<li>键（key值）不可重复，value值可以</li>
<li>每个建最多只能映射到一个值</li>
<li>Map接口提供了分别返回key值集合、value值集合以及Entry（键值对）集合的方法</li>
<li>Map支持泛型，形式如：Map<K,V></K,V></li>
</ul>
<p><img src="/2018/11/21/Java_5_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1709198179671-e84da449-8d1e-42bd-b104-624a280500f7.png" alt="HashMap.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.put(<span class="number">4</span>, <span class="string">&quot;four&quot;</span>);</span><br><span class="line">map.put(<span class="number">5</span>, <span class="string">&quot;five&quot;</span>);</span><br><span class="line">map.put(<span class="number">6</span>, <span class="string">&quot;six&quot;</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; keys = map.keySet();</span><br><span class="line">System.out.println(<span class="string">&quot;keys = &quot;</span> + keys);</span><br><span class="line"></span><br><span class="line">Collection&lt;String&gt; values = map.values();</span><br><span class="line">System.out.println(<span class="string">&quot;values = &quot;</span> + values);</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">System.out.println(<span class="string">&quot;entries = &quot;</span> + entries);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda表达式写法</span></span><br><span class="line">map.forEach((k, v)-&gt; System.out.println(<span class="string">&quot;key = &quot;</span> + k + <span class="string">&quot;, value = &quot;</span> + v));</span><br><span class="line"></span><br><span class="line">map.replaceAll((k,v)-&gt;v.toUpperCase());</span><br><span class="line">map.forEach((k, v)-&gt; System.out.println(<span class="string">&quot;key = &quot;</span> + k + <span class="string">&quot;, value = &quot;</span> + v));</span><br></pre></td></tr></table></figure>
<ol>
<li>HashTable</li>
</ol>
<ul>
<li>键不可重复，值可重复</li>
<li>底层哈希表</li>
<li>线程安全</li>
<li>key、value都不允许</li>
</ul>
<ol>
<li>TreeMap</li>
</ol>
<ul>
<li>键不可重复，值可以重复</li>
<li>底层二叉树</li>
</ul>
<h2 id="2-3、工具类"><a href="#2-3、工具类" class="headerlink" title="2.3、工具类"></a>2.3、工具类</h2><ol>
<li>Iterator迭代器</li>
<li>Enumeration枚举类</li>
<li>Arrays</li>
<li>Collections</li>
</ol>
<h1 id="三、相关扩展"><a href="#三、相关扩展" class="headerlink" title="三、相关扩展"></a>三、相关扩展</h1><h2 id="3-1、HashMap工作原理及实现"><a href="#3-1、HashMap工作原理及实现" class="headerlink" title="3.1、HashMap工作原理及实现"></a>3.1、HashMap工作原理及实现</h2><h3 id="3-1-1、概述"><a href="#3-1-1、概述" class="headerlink" title="3.1.1、概述"></a>3.1.1、概述</h3><p>什么时候会使用HashMap？他有什么特点？你知道HashMap的工作原理吗？你知道get和put的原理吗？equals()和hashCode()的都有什么作用？你知道hash的实现吗？为什么要这样实现？如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;语文&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&quot;数学&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    map.put(<span class="string">&quot;英语&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    map.put(<span class="string">&quot;历史&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    map.put(<span class="string">&quot;政治&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">&quot;地理&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    map.put(<span class="string">&quot;生物&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    map.put(<span class="string">&quot;化学&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2、两个重要的参数"><a href="#3-1-2、两个重要的参数" class="headerlink" title="3.1.2、两个重要的参数"></a>3.1.2、两个重要的参数</h3><p>在HashMap中有两个很重要的参数，容量(Capacity)和负载因子(Load factor)<br>简单的说，Capacity就是bucket的大小，Load factor就是bucket填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。当bucket中的entries的数目大于capacity<em>load factor时就需要调整bucket的大小为当前的2倍。<br><strong>Initial capacity</strong> The capacity is <strong>the number of buckets</strong> in the hash table, The initial capacity is simply the capacity at the time the hash table is created.<strong>Load factor</strong> The load factor is <em>*a measure of how full the hash table is allowed to get</em></em> before its capacity is automatically increased.</p>
<h3 id="3-1-3、put函数的实现"><a href="#3-1-3、put函数的实现" class="headerlink" title="3.1.3、put函数的实现"></a>3.1.3、put函数的实现</h3><p>put函数大致的思路为：对key的hashCode()做hash，然后再计算index;如果没碰撞直接放到bucket里；<br>如果碰撞了，以链表的形式存在buckets后；如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；<br>如果节点已经存在就替换old value(保证key的唯一性)如果bucket满了(超过load factor*current capacity)，就要resize。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算index，并对null做处理</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 节点存在</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">            <span class="comment">// 该链为树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">// 该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写入</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过load factor*current capacity，resize</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-4、get函数的实现"><a href="#3-1-4、get函数的实现" class="headerlink" title="3.1.4、get函数的实现"></a>3.1.4、get函数的实现</h3><p>在理解了put之后，get就很简单了。大致思路如下：bucket里的第一个节点，直接命中；如果有冲突，则通过key.equals(k)去查找对应的entry若为树，则在树中通过key.equals(k)查找，O(logn)；若为链表，则在链表中通过key.equals(k)查找，O(n)。具体代码的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">Node&lt;K, V&gt; e;</span><br><span class="line"><span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; first, e;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接命中</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 未命中</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-5、hash函数的实现"><a href="#3-1-5、hash函数的实现" class="headerlink" title="3.1.5、hash函数的实现"></a>3.1.5、hash函数的实现</h3><p>在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示在对hashCode()计算hash时具体实现是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line"><span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前已经提过，在获取HashMap的元素时，基本分两步：首先根据hashCode()做hash，然后确定bucket的index；如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题</p>
<h3 id="3-1-6、resize的实现"><a href="#3-1-6、resize的实现" class="headerlink" title="3.1.6、resize的实现"></a>3.1.6、resize的实现</h3><p>当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的：<br>大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：<br>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：<br>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：<br>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。下面是代码的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                            <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-7、总结"><a href="#3-1-7、总结" class="headerlink" title="3.1.7、总结"></a>3.1.7、总结</h3><p>我们现在可以回答开始的几个问题，加深对HashMap的理解：<br><strong>1. 什么时候会使用HashMap？他有什么特点？</strong><br>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。<br><strong>2. 你知道HashMap的工作原理吗？</strong><br>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。<br><strong>3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</strong></p>
<p>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p>
<p><strong>4.你知道hash的实现吗？为什么要这样实现？</strong><br>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。<br><strong>5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</strong>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。<br>以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。插入元素时，如果两条Key落在同一个桶(比如哈希值1和17取模16后都属于第一个哈希桶)，Entry用一个next属性实现多个Entry以单向链表存放，后入桶的Entry将next指向桶当前的Entry。查找哈希值为17的key时，先定位到第一个哈希桶，然后以链表遍历桶里所有元素，逐个比较其key值。当Entry数量达到桶数量的75%时(很多文章说使用的桶数量达到了75%，但看代码不是)，会成倍扩容桶数组，并重新分配所有原来的Entry，所以这里也最好有个预估值。取模用位运算(hash &amp; (arrayLength-1))会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值比如17会转为32。默认第一次放入元素时的初始值是16。iterator()时顺着哈希桶数组来遍历，看起来是个乱序。在JDK8里，新增默认为8的閥值，当一个桶里的Entry超过閥值，就不以单向链表而以红黑树来存放以加快Key的查找速度。</p>
<h1 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h1><p><a href="https://dev.java/learn/api/collections-framework/">https://dev.java/learn/api/collections-framework/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/21/Java_3_%E5%B8%B8%E7%94%A8API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xieshanzhong">
      <meta itemprop="description" content="欢迎来到xieshanzhong的技术分享站~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XIE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/21/Java_3_%E5%B8%B8%E7%94%A8API/" class="post-title-link" itemprop="url">Java_常用API(四)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-21 15:17:59" itemprop="dateCreated datePublished" datetime="2018-11-21T15:17:59+08:00">2018-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-15 15:19:42" itemprop="dateModified" datetime="2024-03-15T15:19:42+08:00">2024-03-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a>一、思维导图</h1><h1 id="二、知识点及实践"><a href="#二、知识点及实践" class="headerlink" title="二、知识点及实践"></a>二、知识点及实践</h1><h2 id="2-1、关于流"><a href="#2-1、关于流" class="headerlink" title="2.1、关于流"></a>2.1、关于流</h2><h3 id="什么是流？"><a href="#什么是流？" class="headerlink" title="什么是流？"></a>什么是流？</h3><p>流是Java8引入的全新概念，它用来处理集合中的数据，暂且可以把它理解为一种高级集合。<br>众所周知，集合操作非常麻烦，若要对集合进行筛选、投影，需要写大量的代码，而流是以声明的形式操作集合，它就像SQL语句，我们只需告诉流需要对集合进行什么操作，它就会自动进行操作，并将执行结果交给你，无需我们自己手写代码。<br>因此，流的集合操作对我们来说是透明的，我们只需向流下达命令，它就会自动把我们想要的结果给我们。由于操作过程完全由Java处理，因此它可以根据当前硬件环境选择最优的方法处理，我们也无需编写复杂又容易出错的多线程代码了。</p>
<h3 id="流的特点"><a href="#流的特点" class="headerlink" title="流的特点"></a>流的特点</h3><ol>
<li>只能遍历一次<br>我们可以把流想象成一条流水线，流水线的源头是我们的数据源(一个集合)，数据源中的元素依次被输送到流水线上，我们可以在流水线上对元素进行各种操作。<br>一旦元素走到了流水线的另一头，那么这些元素就被“消费掉了”，我们无法再对这个流进行操作。当然，我们可以从数据源那里再获得一个新的流重新遍历一遍。</li>
<li>采用内部迭代方式<br>若要对集合进行处理，则需我们手写处理代码，这就叫做外部迭代。<br>而要对流进行处理，我们只需告诉流我们需要什么结果，处理过程由流自行完成，这就称为内部迭代。</li>
</ol>
<h3 id="流的操作种类"><a href="#流的操作种类" class="headerlink" title="流的操作种类"></a>流的操作种类</h3><p>流的操作分为两种，分别为中间操作和终端操作。</p>
<ol>
<li>中间操作<br>当数据源中的数据上了流水线后，这个过程对数据进行的所有操作都称为“中间操作”。<br>中间操作仍然会返回一个流对象，因此多个中间操作可以串连起来形成一个流水线。</li>
<li>终端操作<br>当所有的中间操作完成后，若要将数据从流水线上拿下来，则需要执行终端操作。<br>终端操作将返回一个执行结果，这就是你想要的数据。</li>
</ol>
<h3 id="流的操作过程"><a href="#流的操作过程" class="headerlink" title="流的操作过程"></a>流的操作过程</h3><p>使用流一共需要三步：<br>以这个Map-Filter-Reduce为主，进行变化<br>每个关键的单词对应相应的到不同的操作过程</p>
<ol>
<li>准备一个数据源</li>
<li>执行中间操作<br>中间操作可以有多个，它们可以串连起来形成流水线。</li>
<li>执行终端操作<br>执行终端操作后本次流结束，你将获得一个执行结果。</li>
</ol>
<h2 id="2-2、使用流"><a href="#2-2、使用流" class="headerlink" title="2.2、使用流"></a>2.2、使用流</h2><h3 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h3><p>在使用流之前，首先需要拥有一个数据源，并通过StreamAPI提供的一些方法获取该数据源的流对象。数据源可以有多种形式：<br><strong>1. 集合</strong><br>这种数据源较为常用，通过stream()方法即可获取流对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;(); </span><br><span class="line">Stream&lt;Person&gt; stream = list.stream();</span><br></pre></td></tr></table></figure>
<p><strong>2. 数组</strong><br>通过Arrays类提供的静态函数stream()获取数组的流对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;chaimm&quot;</span>,<span class="string">&quot;peter&quot;</span>,<span class="string">&quot;john&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(names);</span><br></pre></td></tr></table></figure>
<p><strong>3. 值</strong><br>直接将几个值变成流对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;chaimm&quot;</span>,<span class="string">&quot;peter&quot;</span>,<span class="string">&quot;john&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>4. 文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="type">Stream</span> <span class="variable">lines</span> <span class="operator">=</span> Files.lines(Paths.get(“文件路径名”),Charset.defaultCharset()))&#123;</span><br><span class="line">    <span class="comment">//可对lines做一些操作</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. iterator</strong><br><strong>创建无限流</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>)</span><br><span class="line">      .limit(<span class="number">10</span>)</span><br><span class="line">      .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：Java7简化了IO操作，把打开IO操作放在try后的括号中即可省略关闭IO的代码。</p>
</blockquote>
<h3 id="筛选-filter"><a href="#筛选-filter" class="headerlink" title="筛选 filter"></a>筛选 filter</h3><p>filter 函数接收一个Lambda表达式作为参数，该表达式返回boolean，在执行过程中，流将元素逐一输送给filter，并筛选出执行结果为true的元素。<br>如，筛选出所有学生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; result = list.stream()</span><br><span class="line">                    .filter(Person::isStudent)</span><br><span class="line">                    .collect(toList());</span><br></pre></td></tr></table></figure>
<h3 id="去重distinct"><a href="#去重distinct" class="headerlink" title="去重distinct"></a>去重distinct</h3><p>去掉重复的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; result = list.stream()</span><br><span class="line">                    .distinct()</span><br><span class="line">                    .collect(toList());</span><br></pre></td></tr></table></figure>
<h3 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h3><p>截取流的前N个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; result = list.stream()</span><br><span class="line">                    .limit(<span class="number">3</span>)</span><br><span class="line">                    .collect(toList());</span><br></pre></td></tr></table></figure>
<h3 id="跳过"><a href="#跳过" class="headerlink" title="跳过"></a>跳过</h3><p>跳过流的前n个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; result = list.stream()</span><br><span class="line">                    .skip(<span class="number">3</span>)</span><br><span class="line">                    .collect(toList());</span><br></pre></td></tr></table></figure>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>对流中的每个元素执行一个函数，使得元素转换成另一种类型输出。流会将每一个元素输送给map函数，并执行map中的Lambda表达式，最后将执行结果存入一个新的流中。<br>如，获取每个人的姓名(实则是将Perosn类型转换成String类型)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; result = list.stream()</span><br><span class="line">                    .map(Person::getName)</span><br><span class="line">                    .collect(toList());</span><br></pre></td></tr></table></figure>
<h3 id="合并多个流"><a href="#合并多个流" class="headerlink" title="合并多个流"></a>合并多个流</h3><p>例：列出List中各不相同的单词，List集合如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;I am a boy&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;I love the girl&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;But the girl loves another girl&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>思路如下：<br>首先将list变成流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream();</span><br></pre></td></tr></table></figure>
<p>按空格分词：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">            .map(line-&gt;line.split(<span class="string">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure>
<p>分完词之后，每个元素变成了一个String[]数组。<br>将每个 <code>String[]</code> 变成流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">            .map(line-&gt;line.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">            .map(Arrays::stream)</span><br></pre></td></tr></table></figure>
<p>此时一个大流里面包含了一个个小流，我们需要将这些小流合并成一个流。<br>将小流合并成一个大流：用 <code>flatMap</code> 替换刚才的 map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .map(line-&gt;line.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    .flatMap(Arrays::stream)</span><br></pre></td></tr></table></figure>
<p>去重</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .map(line-&gt;line.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    .flatMap(Arrays::stream)</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure>
<h3 id="是否匹配任一元素：anyMatch"><a href="#是否匹配任一元素：anyMatch" class="headerlink" title="是否匹配任一元素：anyMatch"></a>是否匹配任一元素：anyMatch</h3><p>anyMatch用于判断流中是否存在至少一个元素满足指定的条件，这个判断条件通过Lambda表达式传递给anyMatch，执行结果为boolean类型。<br>如，判断list中是否有学生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> list.stream()</span><br><span class="line">            .anyMatch(Person::isStudent);</span><br></pre></td></tr></table></figure>
<h3 id="是否匹配所有元素：allMatch"><a href="#是否匹配所有元素：allMatch" class="headerlink" title="是否匹配所有元素：allMatch"></a>是否匹配所有元素：allMatch</h3><p>allMatch用于判断流中的所有元素是否都满足指定条件，这个判断条件通过Lambda表达式传递给anyMatch，执行结果为boolean类型。<br>如，判断是否所有人都是学生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> list.stream()</span><br><span class="line">            .allMatch(Person::isStudent);</span><br></pre></td></tr></table></figure>
<h3 id="是否未匹配所有元素：noneMatch"><a href="#是否未匹配所有元素：noneMatch" class="headerlink" title="是否未匹配所有元素：noneMatch"></a>是否未匹配所有元素：noneMatch</h3><p>noneMatch与allMatch恰恰相反，它用于判断流中的所有元素是否都不满足指定条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> list.stream()</span><br><span class="line">            .noneMatch(Person::isStudent);</span><br></pre></td></tr></table></figure>
<h3 id="获取任一元素findAny"><a href="#获取任一元素findAny" class="headerlink" title="获取任一元素findAny"></a>获取任一元素findAny</h3><p>findAny能够从流中随便选一个元素出来，它返回一个Optional类型的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Person&gt; person = list.stream().findAny();</span><br></pre></td></tr></table></figure>
<h3 id="获取第一个元素findFirst"><a href="#获取第一个元素findFirst" class="headerlink" title="获取第一个元素findFirst"></a>获取第一个元素findFirst</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Person&gt; person = list.stream().findFirst();</span><br></pre></td></tr></table></figure>
<h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><p>归约是将集合中的所有元素经过指定运算，折叠成一个元素输出，如：求最值、平均数等，这些操作都是将一个集合的元素折叠成一个元素输出。在流中，reduce函数能实现归约。<br>reduce函数接收两个参数：</p>
<ol>
<li>初始值</li>
<li>进行归约操作的Lambda表达式</li>
</ol>
<p><strong>元素求和：自定义Lambda表达式实现求和</strong></p>
<p>例：计算所有人的年龄总和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, (person1,person2)-&gt;person1.getAge()+person2.getAge());</span><br></pre></td></tr></table></figure>
<ol>
<li>reduce的第一个参数表示初试值为0；</li>
<li>reduce的第二个参数为需要进行的归约操作，它接收一个拥有两个参数的Lambda表达式，reduce会把流中的元素两两输给Lambda表达式，最后将计算出累加之和。</li>
</ol>
<p><strong>元素求和：使用Integer.sum函数求和</strong><br>上面的方法中我们自己定义了Lambda表达式实现求和运算，如果当前流的元素为数值类型，那么可以使用Integer提供了sum函数代替自定义的Lambda表达式，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure>
<p>Integer类还提供了 <code>min</code>、<code>max</code> 等一系列数值操作，当流中元素为数值类型时可以直接使用。</p>
<h3 id="数值流的使用"><a href="#数值流的使用" class="headerlink" title="数值流的使用"></a>数值流的使用</h3><p>采用reduce进行数值操作会涉及到基本数值类型和引用数值类型之间的装箱、拆箱操作，因此效率较低。<br>当流操作为纯数值操作时，使用数值流能获得较高的效率。<br><strong>将普通流转换成数值流</strong><br>StreamAPI提供了三种数值流：IntStream、DoubleStream、LongStream，也提供了将普通流转换成数值流的三种方法：mapToInt、mapToDouble、mapToLong。<br>如，将Person中的age转换成数值流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> list.stream().mapToInt(Person::getAge);</span><br></pre></td></tr></table></figure>
<p><strong>数值计算</strong><br>每种数值流都提供了数值计算函数，如max、min、sum等。如，找出最大的年龄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OptionalInt</span> <span class="variable">maxAge</span> <span class="operator">=</span> list.stream()</span><br><span class="line">                                .mapToInt(Person::getAge)</span><br><span class="line">                                .max();</span><br></pre></td></tr></table></figure>
<p>由于数值流可能为空，并且给空的数值流计算最大值是没有意义的，因此max函数返回OptionalInt，它是Optional的一个子类，能够判断流是否为空，并对流为空的情况作相应的处理。<br>此外，mapToInt、mapToDouble、mapToLong进行数值操作后的返回结果分别为：OptionalInt、OptionalDouble、OptionalLong</p>
<h2 id="2-3、中间操作和收集操作"><a href="#2-3、中间操作和收集操作" class="headerlink" title="2.3、中间操作和收集操作"></a>2.3、中间操作和收集操作</h2><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>类型</th>
<th>返回类型</th>
<th>使用的类型/函数式接口</th>
<th>函数描述符</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filter</code></td>
<td>中间</td>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>Predicate&lt;T&gt;</code></td>
<td><code>T -&gt; boolean</code></td>
</tr>
<tr>
<td><code>distinct</code></td>
<td>中间</td>
<td><code>Stream&lt;T&gt;</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>skip</code></td>
<td>中间</td>
<td><code>Stream&lt;T&gt;</code></td>
<td>long</td>
<td></td>
</tr>
<tr>
<td><code>map</code></td>
<td>中间</td>
<td><code>Stream&lt;R&gt;</code></td>
<td><code>Function&lt;T, R&gt;</code></td>
<td><code>T -&gt; R</code></td>
</tr>
<tr>
<td><code>flatMap</code></td>
<td>中间</td>
<td><code>Stream&lt;R&gt;</code></td>
<td><code>Function&lt;T, Stream&lt;R&gt;&gt;</code></td>
<td><code>T -&gt; Stream&lt;R&gt;</code></td>
</tr>
<tr>
<td><code>limit</code></td>
<td>中间</td>
<td><code>Stream&lt;T&gt;</code></td>
<td>long</td>
<td></td>
</tr>
<tr>
<td><code>sorted</code></td>
<td>中间</td>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>Comparator&lt;T&gt;</code></td>
<td><code>(T, T) -&gt; int</code></td>
</tr>
<tr>
<td><code>anyMatch</code></td>
<td>终端</td>
<td><code>boolean</code></td>
<td><code>Predicate&lt;T&gt;</code></td>
<td><code>T -&gt; boolean</code></td>
</tr>
<tr>
<td><code>noneMatch</code></td>
<td>终端</td>
<td><code>boolean</code></td>
<td><code>Predicate&lt;T&gt;</code></td>
<td><code>T -&gt; boolean</code></td>
</tr>
<tr>
<td><code>allMatch</code></td>
<td>终端</td>
<td><code>boolean</code></td>
<td><code>Predicate&lt;T&gt;</code></td>
<td><code>T -&gt; boolean</code></td>
</tr>
<tr>
<td><code>findAny</code></td>
<td>终端</td>
<td><code>Optional&lt;T&gt;</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>findFirst</code></td>
<td>终端</td>
<td><code>Optional&lt;T&gt;</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>forEach</code></td>
<td>终端</td>
<td><code>void</code></td>
<td><code>Consumer&lt;T&gt;</code></td>
<td><code>T -&gt; void</code></td>
</tr>
<tr>
<td><code>collect</code></td>
<td>终端</td>
<td><code>R</code></td>
<td><code>Collector&lt;T, A, R&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>reduce</code></td>
<td>终端</td>
<td><code>Optional&lt;T&gt;</code></td>
<td><code>BinaryOperator&lt;T&gt;</code></td>
<td><code>(T, T) -&gt; T</code></td>
</tr>
<tr>
<td><code>count</code></td>
<td>终端</td>
<td><code>long</code></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-4、Collector"><a href="#2-4、Collector" class="headerlink" title="2.4、Collector"></a>2.4、Collector</h2><p>收集器用来将经过筛选、映射的流进行最后的整理，可以使得最后的结果以不同的形式展现。<br><code>collect</code> 方法即为收集器，它接收 <code>Collector</code> 接口的实现作为具体收集器的收集方法。<br><code>Collector</code> 接口提供了很多默认实现的方法，我们可以直接使用它们格式化流的结果；也可以自定义 <code>Collector</code> 接口的实现，从而定制自己的收集器。</p>
<h3 id="归约-1"><a href="#归约-1" class="headerlink" title="归约"></a>归约</h3><p>流由一个个元素组成，归约就是将一个个元素“折叠”成一个值，如求和、求最值、求平均值都是归约操作。</p>
<h3 id="一般性归约"><a href="#一般性归约" class="headerlink" title="一般性归约"></a>一般性归约</h3><p>若你需要自定义一个归约操作，那么需要使用 <code>Collectors.reducing</code> 函数，该函数接收三个参数：</p>
<ul>
<li>第一个参数为归约的初始值</li>
<li>第二个参数为归约操作进行的字段</li>
<li>第三个参数为归约操作的过程</li>
</ul>
<h2 id="2-5、汇总"><a href="#2-5、汇总" class="headerlink" title="2.5、汇总"></a>2.5、汇总</h2><p>Collectors类专门为汇总提供了一个工厂方法：<code>Collectors.summingInt</code>。<br>它可接受一 个把对象映射为求和所需int的函数，并返回一个收集器；该收集器在传递给普通的 <code>collect</code> 方法后即执行我们需要的汇总操作。</p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>数据分组是一种更自然的分割数据操作，分组就是将流中的元素按照指定类别进行划分，类似于SQL语句中的 <code>GROUPBY</code>。</p>
<h3 id="多级分组"><a href="#多级分组" class="headerlink" title="多级分组"></a>多级分组</h3><p>多级分组可以支持在完成一次分组后，分别对每个小组再进行分组。<br>使用具有两个参数的 <code>groupingBy</code> 重载方法即可实现多级分组。</p>
<ul>
<li>第一个参数：一级分组的条件</li>
<li>第二个参数：一个新的 <code>groupingBy</code> 函数，该函数包含二级分组的条件</li>
</ul>
<p><strong>Collectors 类的静态工厂方法</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>toList</code></td>
<td><code>List&lt;T&gt;</code></td>
<td>把流中所有项目收集到一个 List</td>
<td><code>List&lt;Project&gt; projects = projectStream.collect(toList());</code></td>
</tr>
<tr>
<td><code>toSet</code></td>
<td><code>Set&lt;T&gt;</code></td>
<td>把流中所有项目收集到一个 Set，删除重复项</td>
<td><code>Set&lt;Project&gt; projects = projectStream.collect(toSet());</code></td>
</tr>
<tr>
<td><code>toCollection</code></td>
<td><code>Collection&lt;T&gt;</code></td>
<td>把流中所有项目收集到给定的供应源创建的集合</td>
<td><code>Collection&lt;Project&gt; projects = projectStream.collect(toCollection(), ArrayList::new);</code></td>
</tr>
<tr>
<td><code>counting</code></td>
<td><code>Long</code></td>
<td>计算流中元素的个数</td>
<td><code>long howManyProjects = projectStream.collect(counting());</code></td>
</tr>
<tr>
<td><code>summingInt</code></td>
<td><code>Integer</code></td>
<td>对流中项目的一个整数属性求和</td>
<td><code>int totalStars = projectStream.collect(summingInt(Project::getStars));</code></td>
</tr>
<tr>
<td><code>averagingInt</code></td>
<td><code>Double</code></td>
<td>计算流中项目 Integer 属性的平均值</td>
<td><code>double avgStars = projectStream.collect(averagingInt(Project::getStars));</code></td>
</tr>
<tr>
<td><code>summarizingInt</code></td>
<td><code>IntSummaryStatistics</code></td>
<td>收集关于流中项目 Integer 属性的统计值，例如最大、最小、 总和与平均值</td>
<td><code>IntSummaryStatistics projectStatistics = projectStream.collect(summarizingInt(Project::getStars));</code></td>
</tr>
<tr>
<td><code>joining</code></td>
<td><code>String</code></td>
<td>连接对流中每个项目调用 toString 方法所生成的字符串</td>
<td><code>String shortProject = projectStream.map(Project::getName).collect(joining(&quot;, &quot;));</code></td>
</tr>
<tr>
<td><code>maxBy</code></td>
<td><code>Optional&lt;T&gt;</code></td>
<td>按照给定比较器选出的最大元素的 Optional， 或如果流为空则为 Optional.empty()</td>
<td><code>Optional&lt;Project&gt; fattest = projectStream.collect(maxBy(comparingInt(Project::getStars)));</code></td>
</tr>
<tr>
<td><code>minBy</code></td>
<td><code>Optional&lt;T&gt;</code></td>
<td>按照给定比较器选出的最小元素的 Optional， 或如果流为空则为 Optional.empty()</td>
<td><code>Optional&lt;Project&gt; fattest = projectStream.collect(minBy(comparingInt(Project::getStars)));</code></td>
</tr>
<tr>
<td><code>reducing</code></td>
<td>归约操作产生的类型</td>
<td>从一个作为累加器的初始值开始，利用 BinaryOperator 与流中的元素逐个结合，从而将流归约为单个值</td>
<td><code>int totalStars = projectStream.collect(reducing(0, Project::getStars, Integer::sum));</code></td>
</tr>
<tr>
<td><code>collectingAndThen</code></td>
<td>转换函数返回的类型</td>
<td>包含另一个收集器，对其结果应用转换函数</td>
<td><code>int howManyProjects = projectStream.collect(collectingAndThen(toList(), List::size));</code></td>
</tr>
<tr>
<td><code>groupingBy</code></td>
<td><code>Map&lt;K, List&lt;T&gt;&gt;</code></td>
<td>根据项目的一个属性的值对流中的项目作问组，并将属性值作 为结果 Map 的键</td>
<td><code>Map&lt;String,List&lt;Project&gt;&gt; projectByLanguage = projectStream.collect(groupingBy(Project::getLanguage));</code></td>
</tr>
<tr>
<td><code>partitioningBy</code></td>
<td><code>Map&lt;Boolean,List&lt;T&gt;&gt;</code></td>
<td>根据对流中每个项目应用断言的结果来对项目进行分区</td>
<td><code>Map&lt;Boolean,List&lt;Project&gt;&gt; vegetarianDishes = projectStream.collect(partitioningBy(Project::isVegetarian));</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="转换类型"><a href="#转换类型" class="headerlink" title="转换类型"></a>转换类型</h3><p>有一些收集器可以生成其他集合。比如前面已经见过的 <code>toList</code>，生成了 <code>java.util.List</code> 类的实例。<br>还有 <code>toSet</code> 和 <code>toCollection</code>，分别生成 <code>Set</code> 和 <code>Collection</code> 类的实例。<br>到目前为止， 我已经讲了很多流上的链式操作，但总有一些时候，需要最终生成一个集合——比如：</p>
<ul>
<li>已有代码是为集合编写的，因此需要将流转换成集合传入；</li>
<li>在集合上进行一系列链式操作后，最终希望生成一个值；</li>
<li>写单元测试时，需要对某个具体的集合做断言。</li>
</ul>
<p>使用 <code>toCollection</code>，用定制的集合收集元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.collect(toCollection(TreeSet::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>
<p>还可以利用收集器让流生成一个值。 <code>maxBy</code> 和 <code>minBy</code> 允许用户按某种特定的顺序生成一个值。</p>
<h3 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h3><p>分区是分组的特殊情况：由一个断言（返回一个布尔值的函数）作为分类函数，它称分区函数。<br>分区函数返回一个布尔值，这意味着得到的分组 <code>Map</code> 的键类型是 <code>Boolean</code>，于是它最多可以分为两组: true是一组，false是一组。<br>分区的好处在于保留了分区函数返回true或false的两套流元素列表。</p>
<h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><p>并行流就是一个把内容分成多个数据块，并用不不同的线程分别处理每个数据块的流。最后合并每个数据块的计算结果。<br>将一个顺序执行的流转变成一个并发的流只要调用 <code>parallel()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">parallelSum</span><span class="params">(<span class="type">long</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.iterate(<span class="number">1L</span>, i -&gt; i +<span class="number">1</span>).limit(n).parallel().reduce(<span class="number">0L</span>,Long::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将一个并发流转成顺序的流只要调用 <code>sequential()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.parallel().filter(...).sequential().map(...).parallel().reduce();</span><br></pre></td></tr></table></figure>
<p>这两个方法可以多次调用，只有最后一个调用决定这个流是顺序的还是并发的。<br>并发流使用的默认线程数等于你机器的处理器核心数。<br>通过这个方法可以修改这个值，这是全局属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;</span>, <span class="string">&quot;12&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>并非使用多线程并行流处理数据的性能一定高于单线程顺序流的性能，因为性能受到多种因素的影响。<br>如何高效使用并发流的一些建议：</p>
<ol>
<li>如果不确定， 就自己测试。</li>
<li>尽量使用基本类型的流 IntStream, LongStream, DoubleStream</li>
<li>有些操作使用并发流的性能会比顺序流的性能更差，比如limit，findFirst，依赖元素顺序的操作在并发流中是极其消耗性能的。findAny的性能就会好很多，应为不依赖顺序。</li>
<li>考虑流中计算的性能(Q)和操作的性能(N)的对比, Q表示单个处理所需的时间，N表示需要处理的数量，如果Q的值越大, 使用并发流的性能就会越高。</li>
<li>数据量不大时使用并发流，性能得不到提升。</li>
<li>考虑数据结构：并发流需要对数据进行分解，不同的数据结构被分解的性能时不一样的。</li>
</ol>
<p><strong>流的数据源和可分解性</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>源</th>
<th>可分解性</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ArrayList</code></td>
<td>非常好</td>
</tr>
<tr>
<td><code>LinkedList</code></td>
<td>差</td>
</tr>
<tr>
<td><code>IntStream.range</code></td>
<td>非常好</td>
</tr>
<tr>
<td><code>Stream.iterate</code></td>
<td>差</td>
</tr>
<tr>
<td><code>HashSet</code></td>
<td>好</td>
</tr>
<tr>
<td><code>TreeSet</code></td>
<td>好</td>
</tr>
</tbody>
</table>
</div>
<p>流的特性以及中间操作对流的修改都会对数据对分解性能造成影响。 比如固定大小的流在任务分解的时候就可以平均分配，但是如果有filter操作，那么流就不能预先知道在这个操作后还会剩余多少元素。<br>考虑终端操作的性能：如果终端操作在合并并发流的计算结果时的性能消耗太大，那么使用并发流提升的性能就会得不偿失。</p>
<h1 id="三、相关扩展"><a href="#三、相关扩展" class="headerlink" title="三、相关扩展"></a>三、相关扩展</h1><ol>
<li>熟悉并查看常见的类或者接口源码：<ol>
<li>Stream</li>
<li>Streams</li>
<li>BaseStream</li>
<li>IntStream</li>
<li>LongStream</li>
<li>DoubleStream</li>
<li>Collectors</li>
<li>Collector</li>
<li>Sink</li>
<li>Function</li>
<li>Consumer</li>
<li>Supplier</li>
<li>Predicate</li>
</ol>
</li>
</ol>
<h1 id="四、存在疑问"><a href="#四、存在疑问" class="headerlink" title="四、存在疑问"></a>四、存在疑问</h1><h1 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h1><ol>
<li><a href="https://dev.java/learn/api/streams/">https://dev.java/learn/api/streams/</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xieshanzhong</p>
  <div class="site-description" itemprop="description">欢迎来到xieshanzhong的技术分享站~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">95</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xie1" title="GitHub → https://github.com/xie1" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xieshanzhong66@gmail.com" title="E-Mail → mailto:xieshanzhong66@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://xie1.github.io/" title="https://xie1.github.io/" rel="noopener" target="_blank">Title</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https://www.baidu.com/" rel="noopener" target="_blank">百度搜索</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://hexo.io/" title="https://hexo.io/" rel="noopener" target="_blank">hexo</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xieshanzhong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
