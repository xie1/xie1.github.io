---
title: 算法图解
date: 2019-11-16 15:39:57
tags:
categories: 未整理
---
###1、算法简介
####1.1、介绍
####1.2、二分查找
####1.3、大O表示法
	1、一些常见的大O运行时间：
		1、O（logn）：对数时间，这样的算法包括二分查找
		2、O（n）：线性时间，这样的算法包括简单的查找
		3、O（n*logn）：包括快速排序
		4、O（n^2）:包括选择排序
		5、O（n！）
###2、选择排序
####2.1、内存的工作原理
####2.2、数组和链表
	1、数组：有序而且固定的
	2、链表：
		链表中的每个元素存储了下一个元素的地址，从而使一系列随机的内存地址串在一起
	3、操作：
		1、在中间插入
		2、删除

	数组和链表还被用来实现其他的数据结构

####2.3、选择排序
	1、时间复杂度：O（n*n）
	2、算法的思路是
###3、递归
	递归是很多算法都使用的的一种编程方式。
	将问题分成基线条件和递归条件、
####3.1、基线条件和递归条件
	每个递归函数都有两部分：基线条件和递归条件
	1、基线条件：函数不在调用自己，从而避免无限循环
	2、递归条件：函数自己调用自己
####3.2、栈
#####3.2.1、调用栈
#####3.2.2、递归调用栈
###4、快速排序
####4.1、分而治之
	工作原理：
	1、找出简单的基线条件
	2、确定如何缩小问题的规模，使其符合基线条件
####4.2、快速排序
	分区：
	1、一个由所有小于基准值的数字组成的子数组
	2、基准值
	3、一个由所有大于基准值的数组组成的子数组
	
	算法分析：
	1、如何建立多少个数组
####4.3、再谈大O表示法
	1、快速排序的平均时间复杂度：O（nlogn）,最坏时间复杂度是O（n^2）
#####4.3.1、比较合并排序和快速排序
#####4.3.2、平均情况和最糟情况
	最佳情况也是平均情况，只要你每次都随机选择一个数组元素作为基准值，快速排序的平均运行时间就将为O（nlogn）。快速排序是最快的排序算法之一，是D&C典范
###5、散列表
	学习散列表的内部机制：实现、冲突和散列函数、
####5.1、散列函数
	1、散列函数总是将同样的输入映射到相同的索引
	2、散列函数将不同的输入映射到不同的索引
	3、散列函数知道数组有多大，只返回有效的索引
	
####5.2、应用案例
#####5.2.1、将散列表用于查找
#####5.2.2、防止重复
#####5.2.3、将散列表用作缓存
####5.3、冲突
	通过拉链法的链表创建解决冲突	
####5.4、性能
#####5.4.1、填装因子
###6、广度优先搜索
	让你能够找出两样东西之间的最短距离，解决最短路径问题的算法。
####6.2、图是什么
	图由节点（node）和边（edge）组成
####6.3、广度优先搜索
#####6.3.1、查找最短路径
#####6.3.2、队列
####6.4、实现图
	1、有向图
	2、无向图
####6.5、实现算法
	1、运行时间：至少为O（边数）
	广度优先搜索的运行时间为O（人数+边数），这通常写作为O(V+E),其中V为顶点数，E为边数
###7、狄克斯特拉算法
####7.1、使用狄克斯特拉算法
	1、找出“最便宜”的节点，即可在最短时间内到达的节点
	2、更新该节点的邻居开销，检查是否有前往它们的更短路径，如果有，就更新其开销
	3、重复这个过程，直到对图中的每个节点都这样做
	4、计算最终路径
####7.2、术语
	1、权重
	要计算非加权图中的最短路径，可使用广度优先搜索
	要计算加权图中的最短路径，可使用狄克斯特拉算法
####7.3、负权边
####7.4、实现——》暂未学习
###8、贪婪算法
	1、贪婪算法寻找局部最优解，企图以这种方式获得全局最优解
	2、NP完全问题，最佳做法使用近似算法
###9、动态规划
	1、最长公共子串
		费曼算法：
		1、将问题写下来
		2、好好思考
		3、将答案写下来
###10、K最近邻算法
	1、分类：编组
	2、回归：预测结果（如一个数字）
####10.3、机器学习简介 
###11、整理
####11.1、树
	二叉树
####11.2、反向索引
####11.3、傅里叶变换
####11.4、并行算法
####11.5、MapReduce
	分布式算法
#####11.5.1、分布式算法为何很有用
	MapReduce基于两个简单的理念，映射（map）函数和归并（reduce）函数
#####11.5.2、映射函数
	它接受一个数组，并对其中的每个元素执行同样的处理