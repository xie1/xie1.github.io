---
title: 面试准备计划_面试题目
date: 2019-11-16 10:17:59
tags: 
categories: 
---
#一、*思维导图*
#*总知识点*

###1、操作系统
####1.1、整体结构
####1.2、面试题
###2、Linux系统	——》已整理
####2.1、整体结构
	1、linux系统简介
	2、文件类型与目录结构
		1、文件类型
			1、普通文件
			2、目录文件
			3、链接文件
			4、设备文件
			5、命名管道
		2、目录结构
	3、linux基本命令
		1、目录切换及增删改查操作
			cd、mkdir、ls、ll、find、mv 、cp 、rm
		2、文件的操作命令
			touch、（cat、more、less、tail）、vim、rm
		3、压缩文件命令
			tar -zvcf  打包并压缩   、 tar -xvf
		4、权限命令
			d - l /chmod
		5、用户及用户组管理命令
			useradd 、userdel、usermod、passwd
		6、其他命令
			1、grep
			2、ps -ef /ps -aux 查看当前系统的正在运行进程
			3、kill -9

####2.2、面试题
	1、查看系统负载有两个常用的命令，是哪两个？这三个数值表示什么含义呢？
		w/uptime , load average系统负载1,5,15
	2、使用top查看系统资源占用情况时，哪一列表示内存占用呢？
		mem
	3、如何实时查看网卡流量为多少？如何查看历史网卡流量？
		sar
	4、如何查看当前系统都有哪些进程？
		ps -ef /ps -aux
	5、如何查看系统都开启了哪些端口？
		netstat -lnp
	6、如何查看网络连接状况？
		netstat -an
	7、有一天你突然发现公司网站访问速度变的很慢很慢，你该怎么办呢？
		查看系统负载-》top（cpu，内存）-》sar（网卡）


###3、计算机网络基础及Java网络编程——》已整理
####3.1、整体结构
	1、概述
		1、计算机网络体系结构
			1、五层协议
				1、应用层：为特定应用提供数据传输服务
				2、传输层：为进程提供通用的数据传输服务
				3、网络层：为主机提供数据传输服务
				4、数据链路层：把网络层传下来的分组封装帧
				5、物理层：尽可能屏蔽传输媒体和通信手段的差异，使得数据链路层感觉不到差异
			2、OSI
			3、TCP/IP
	
	2、五层协议
		1、物理层
		2、数据链路层
		3、网络层
			1、IP数据报协议
		4、传输层
			1、UDP和TCP特点
				1、UDP：无连接、尽最大可能交付、没有拥塞控制、面向报文
				2、TCP：面向连接、提供可靠交付、有流量控制、拥塞控制、提供全双工，面向字节流
			2、UDP协议
				1、UDP首部格式
					首部字段只有8个字节、包括源端口、目的端口、长度、校验和
			3、TCP协议
				1、TCP首部格式
					序号、确认号、数据偏移、确认ack、同步syn、终止FIN、窗口
				2、TCP三次握手
					1、syn= 1,ack=0,初始序号x
					2、syn=1，ack=1，确认号x+1，初始序号y
					3、ack = 1 ,确认号y+1,序号x+1
				3、TCP四次挥手
					1、a发送连接释放报文，fin=1
					2、b收到之后确认，此时tcp属于半关闭状态，b能向a发送数据但a不能b发送数据
					3、当b不再需要连接时，发送连接释放报文，fin=1
					4、a收到后发送确认，进入time-wait状态，等待2msl后释放
					5、b收到a的确认后释放连接
				4、TCP可靠传输
					超时传输
				5、TCP流量控制
					流量控制是为了控制发送方发送速率，保证接收方来得及接收
				6、TCP拥塞控制
					慢开始、拥塞避免、快重传、快恢复
				7、TCP滑动窗口
		5、应用层
			1、域名系统
			2、常用协议
				1、FTP
				2、远程登录协议
				3、邮件传输协议
			3、Web页面请求过程
			
	3、HTTP
		1、基本概念
			1、URI
			2、请求和响应报文
				1、请求方法
				2、请求头参数
				3、请求头实体内容

		2、HTTP方法
			1、get
			2、head
			3、post
			4、put
		3、HTTP状态码
		4、HTTP首部
		5、具体应用
	4、Socket通信模型
####3.2、面试题
	1、OSI与TCP/IP各层的结构与功能,都有哪些协议?	
		1、应用层：
			通过应用进程之间的交互完成特定网络应用
		2、传输层：
			主要负责向两台主机进程之间的通信提供通用的数据传输服务
		3、网络层：
			选择合适网间路由和交换结点，确保数据及时传送。
		4、数据链路层
		5、物理层
		
	2、TCP三次握手和四次挥手？
	3、TCP，UDP协议的区别及特点？
	4、TCP协议如何保证可靠传输？
		1、数据会分割成适合数据块
		2、TCP对数据报进行编号
		3、校验和
		4、TCP会丢弃重复数据
		5、具备超时重传，流量控制，拥塞控制
		6、ARQ（自动重传请求）协议
		
	5、在浏览器中输入url请求至显示过程？
		1、DNS解析
		2、TCP连接
		3、发送HTTP请求
		4、服务器处理请求并返回HTTP报文
		5、浏览器解析渲染页面
		6、连接结束
		
	6、状态码？
	7、各种协议与HTTP协议之间的关系？
	8、HTTP长连接，短连接？
		一般是短连接
		如果使用长连接，http协议，会在响应头加入Connection:keep-alive
		
	9、HTTP是不保存状态协议，如何保存用户状态？
			大部分在cookie中附加一个Session ID方式跟踪
			cookie禁用，把SessionId直接附加在URL路径后面
	10、Cookie的作用是什么？和Session有什么区别？
		Cookie一般用于保存用户信息
		Session主要作用就是通过服务端记录用户状态
	11、HTTP1.0和HTTP1.1主要区别？
		1、长度连接情况
		2、状态码
		3、缓存处理
		4、带宽优化及网络连接


###4、JVM——》已整理
####4.1、整体结构
	1、JVM虚拟机的概念及作用
	2、运行时内存区域的划分
		划分几块，每一块的作用，OOM发生的地方在哪，线程共享，独享，垃圾回收是在哪块中等等
		虚拟机对象的创建过程（5步），布局及引用
	3、垃圾垃圾回收机制
		如何判断对象的存活情况，垃圾回收算法，垃圾回收器有哪些，对象分配等，
    4、性能监控工具
		有哪些常用的命令监控，有哪些常用第三方工具，垃圾回收日志如何查看，工具的使用
				JDK监控和故障处理工具：
				1、jps:显示指定系统内所有的HotSpot虚拟机进程
				2、jstat：用于收集虚拟机各方面的运行数据
				3、jinfo：显示虚拟机配置信息
				4、jmap：生成虚拟机的内存存储快照
				5、jhat：用于分析heapdump文件，它会见了一个HTTP/HTML服务器，让用户可在浏览器上查看分析结果
				6、jstack：显示虚拟机的线程快照
    5、性能调优案例实战
		如何结合日志，命令，工具进行性能调优？
    6、认识类的文件结构
		Class文件结构包含什么，字节码指令有哪些？还有javap -cslv如何判断查看class文件执行过程
    7、类加载机制
		类加载过程有几步？双亲委派原则是什么？有什么作用等等
    8、字节码执行引擎
		虚拟机栈执行系统过程，什么是栈帧，包含什么内容
    9、虚拟机编译及运行时优化
		静态绑定及动态绑定等
    10、Java线程高级部分
		1、JMM内存模型有什么？常用的关键字的JVM实现原理？线程和同步锁的内容
####4.2、面试题
		 1、JVM运行内存的分类
		 2、Java内存堆和栈区别
		 3、Java四引用
		 4、GC回收机制
		 5、GC 标记对象的死活
		 6、在Java语言里，可作为GC在Java语言里，可作为GCRoots的对象包括以下几种
		 7、GC回收算法
		 8、MinorGC&FullGC
		 9、内存分配与回收策略
		 10、GC垃圾收集器
		 11、JVM的类加载机制是什么？有哪些实现方式？
			1）命令行启动应用时候由JVM初始化加载
			2）通过Class.forName（）方法动态加载
			3）通过ClassLoader.loadClass（）方法动态加载

		 12、Java类加载器
		 13、双亲委派模型的工作过程
		 14、双亲委托机制的作用
		 15、如何打破双亲委派模型？
		 16、自定义ClassLoader
		 17、引起类加载操作的五个行为
			 遇到new、getstatic、putstatic或invokestatic这四条字节码指令
		 18、Java对象创建时机
			使用new关键字创建对象
			使用Class类的newInstance方法(反射机制)
			使用Constructor类的newInstance方法(反射机制)
			使用Clone方法创建对象
			使用(反)序列化机制创建对象
		 19、java内存模型
		 20. JVM调优的常见命令行工具有哪些？JVM常见的调优参数有哪些？
		 21、如何定义个类加载器？你使用过哪些或者你在什么场景下需要个定义的类加载器吗？
		 22、堆内存设置的参数是什么？
		 23、Perm Space中保存什么数据？会引起OutOfMemory吗？
		

		 24、你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理 过程中有哪些收获？
			1、内存加载的数据量太大：一次性从数据库取太多数据；
		    2、集合类中有对对象的引用，使用后未清空，GC不能进行回收；
		    3、代码中存在循环产生过多的重复对象；
		    4、启动参数堆内存值小

		 25、jstack是干什么的? jstat 呢？如果线上程序周期性地出现卡顿，你怀疑可能是GC导致的你会怎么来排查这个问题？线程日志一般你会看其中的什么部分？
			[详见Java jvisualvm简要说明，可参考 线上FullGC频繁的排查](https://blog.csdn.net/wilsonpeng3/article/details/70064336/)
		26、StackOverflow异常有没有遇到过？一般你猜测会在什么情况下被触发？如何指定一个线程的堆栈大小？一般你们写多少？
			栈内存溢出，一般由栈内存的局部变量过爆了，导致内存溢出。出现在递归方法，参数个数过多，递归过深，递归没有出口
		27、你知道哪些或者你们线上使用什么GC策略？它有什么优势，适用于什么场景？
		[参考 触发JVM进行Full GC的情况及应对策略](https://blog.csdn.net/chenleixing/article/details/46706039/)

###5、多线程并发——》已整理
	需要处理专题内容	
####5.1、整体结构
	一、多线程并发基础
	1、Java多线程的技能
		1、进程和线程的概念及区别？
		2、创建一个线程的方法
		3、线程的API
			1、currentThread
			2、isAlive
			3、sleep
			4、yield
			5、线程优先级
			6、守护线程
			7、停止线程的方法	
	2、对象及变量的并发访问
		1、synchronized修饰同步方法及同步代码块
		2、volatile关键字使用
	3、线程间通信
		1、等待/通知机制（wait/notity、notityAll）
			1、生产者/消费者模式实现
			2、通过管道进行字符、字节流通信
		2、方法join使用
		3、ThreadLocal的使用
	4、Lock的使用
		1、ReentrantLock类（重入锁）
			1、使用Condition实现等待/通知
			2、公平锁与非公平锁
		2、ReentrantReadWriteLock类
			1、读锁
			2、写锁				
	5、单例模式与多线程
	
	二、多线程并发进阶
	1、并发编程的挑战
		1、上下文切换
			1、什么是上下文切换（从任务的保存到载入就是一次上下文切换）
			2、如何减少上下文切换（不加锁+cas+使用最少线程+使用协程）
		2、死锁
			1、什么是死锁（相互持有对方的锁，又相互等待对方释放锁）
			2、避免死锁几个常用方法
				1、避免一个线程同时获取多个锁
				2、避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
				3、尝试使用定时锁，使用lock.try(timeout)来代替内部锁机制
				4、对于数据库锁，加锁及解锁在一个数据库连接里
		
		3、资源限制的挑战
			1、执行速度限制于计算机硬件或软件问题
			
	2、Java并发机制底层实现
			Java中所使用的并发机制依赖于JVM的实现和CPU的执行
		1、synchronized的实现原理与应用
			synchronized实现同步基础，Java中的每个对象都可以作为锁：
				1、对于普通的同步方法，锁是当前实例对象
				2、对于静态同步方法，锁的是当前类的Class对象
				3、对于同步方法块，锁的是Synchronized括号里配置的对象
			synchronized同步代码块是monitorenter和monitorexit指令实现的
			synchronized同步方法同步标识ACC_SYNCHRONIZED
		2、volatile实现原理
			底层：
				volatile的两条实现原则：
				1、Lock前缀指令会引起处理器缓存会写到内存、
				2、一个处理器的缓存会写到内存会导致其他的处理器的缓存无效
		3、原子操作的实现原理
			通过锁和循环CAS
			使用锁机制实现原子操作，除了偏向锁，JVM实现锁的方式都使用了CAS，即当一个线程进入同步块的时候使用循环CAS方式获取锁，当退出同步块的时候使用循环CAS释放锁。
			
			
	3、Java内存模型
		1、Java内存模型的基础
			线程通信+线程同步
		2、重排序
			1、编译器优化重排序
			2、指令级并行重排序
			3、内存系统的重排序
			
			happens-before（来描述操作之间内存的可见性）：
			 1、程序顺序规则
			 2、监视器锁规则（解锁在加锁之前发生）
			 3、volatile规则（对于一个volatile域的写在读之前发生）
			 4、传递性
		3、顺序一致性
			1、一个线程中的所有操作必须按照程序的顺序来执行
			2、（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序，在顺序一致性内存模型中，
				每个操作都必须原子执行而且立刻对所有线程可见
		4、volatile内存语义
			1、volatile写的内存语义：
			当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中
			2、volatile读的内存语义：
			当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。
		5、锁的内存语义
			对ReentrantLock的分析可以看出，锁释放-获取的内存语义的实现至少有下面两种方式
			1、利用volatile变量的写-读所具有内存语义
			2、利用CAS所附带的volatile读和volatile写的内存语义
					
		
	4、Java中的锁
		1、Lock接口
			1、与synchronized不同的是
				1、尝试非阻塞获取锁
				2、能被中断地获取锁
				3、超时获取锁
		2、队列同步器实现分析（AbstractQueueSynchronizer(同步器)）
			1、定义：它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作
		
		3、重入锁实现分析
		4、读写锁实现分析
		5、LockSupport工具
		6、Condition接口实现分析
		
		
	5、Java并发容器和框架
		1、ConcurrentHashMap的实现原理与使用
			1、为什么要使用ConcurrentHashMap
				1、HashMap在并发的情况下会形成环形结构，线程不安全
				2、效率低下的线程安全的Hashtable
				3、采用了分段锁技术，同时保证了安全和效率
			2、ConcurrentHashMap结构：有Segments<>组成，Segments又有多个hashEntry组成。
			3、ConcurrentHashMap初始化方法
				是通过initialCapacity、loadFactor和ConcurrencyLevel
				1、初始化segments
				2、初始化segmentShift和segmentMask
				3、初始化每个segment
				4、定位Segment
			4、ConcurrentHashMap操作
				没有加锁（采用的volatile）
				1、get操作（先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，在通过散列算法定位到元素）
				2、put操作
					1、是否需要扩容
					2、如何扩容
		2、ConcurrentLinkedQueue实现原理与使用
			实现线程安全的队列有两种：
			1、使用阻塞算法：入队和出队用同一把锁
			2、使用非阻塞算法：可以使用循环CAS的方式来实现
			ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列
		
		3、Java中阻塞队列
			是一个支持两个附加操作的队列，这两个附加的操作支持阻塞的插入和移除
			1、支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列不满
			2、支持阻塞的移除方法：在队列为空时，获取元素的线程会等待队列变为非空
			常用于生产者和消费者场景
			
			
			1、ArrayBlockingQueue：是一个用数组实现的有界阻塞队列。
			2、LinkedBlockingQueue
			3、PriorityBlockingQueue
			4、DelayQueue
			5、SynchronousQueue
			6、LinkedTransferQueue
			7、LinkedBlockingDeque
		
		4、Fork/Join框架
			Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务的结果。
		
	6、Java中13个原子操作类
		1、原子更新基本类型
			3个类：
				1、AtomicBoolean：原子更新布尔类型
				2、AtomicInteger: 原子更新整型
				3、AtomicLong ： 原子更新长整型
		2、原子更新数组
			4个类：
				1、AtomicIntegerArray：原子更新整型数组里的元素
				2、AtomicLongArray：原子更新长整型数组里的元素
				3、AtomicReferenceArray：原子更新引用类型数组里元素
				4、AtomicIntegerArray ：原子更新数组里的整型
		3、原子更新引用类型
			3个类：
				1、AtomicReference：原子更新引用类型
				2、AtomicReferenceFieldUpdater :原子更新引用类型里的字段
				3、AtomicMarkableReference ：原子更新带有标记位的引用类型
		4、原子更新字段类
			3个类：
				1、AtomicIntegerFieldUpdater :原子更新整型的字段的更新器
				2、AtomicLongFieldUpdater：原子更新长整型字段的更新器
				3、AtomicStampedReference : 原子更新带有版本号的引用类型
		
		
	7、Java中并发工具类
		1、等待多线程完成CountDownLatch
			允许一个或多个线程等待其他线程完成操作类似于join
		2、同步屏障CyclicBarrier
			可循环使用的的屏障。它要做的是，让一组线程到达一个屏障（也叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行
		3、控制并发线程数Sempaphore
			Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源
		4、线程间交换数据的Exchanger
			Exchanger（交换者）时一个用于线程间协作的工具类。用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。
	
	
	
	8、Java中线程池
		为什么要使用线程池
			1、降低资源消耗
			2、提供响应速度
			3、提供线程的可管理性
		1、线程池实现原理
			1、当提交一个新任务到线程池，线程池的处理流程：
				1、线程池判断核心线程池是否已满，没有的话，创建一个线程执行任务，如果已满，则到下一个流程
				2、判断队列是否已经满了，没有的话，将任务存储在队列中，不然转下一流程
				3、线程池是否已满，没有的话，创建工作线程执行任务，不然按照策略处理无法执行任务
			2、ThreadPoolExecutor执行流程：
				1、如果当前运行线程少于corePoolSize，则创建新线程来执行任务
				2、如果当前运行线程等于或多于corePoolSize，则将任务加入BlockingQueue
				3、如果无法加入BlockingQueue,则创建新的线程来处理任务
		2、使用
			1、线程池的创建
			2、向线程池提交任务
				1、execute，用于提交不需要返回任务，无法判断任务是否被线程池执行成功
				2、submit，用于提交需要返回值的任务
			3、关闭线程池
			4、合理配置线程池
			5、线程池的监控	
			
			
	9、Executor框架
		1、Executor框架简介
			Java的线程既是工作单元，也是执行机制。工作单元包括Runnable和Callable，而执行机制由Executor框架提供
			Executor框架有三部分组成：
			1、任务。包括被执行任务需要实现接口:Runnable接口和Callable接口
			2、任务的执行：包括任务执行机制的核心接口Executor。例如：ThreadPoolExecutor
			3、异步计算的结果：包括Future和实现FutureTask类
		2、ThreadPoolExecutor详解
			
		
####5.2、面试题
	Java并发基础面试题：
	1、什么是线程和进程?
		进程：是程序的一次执行过程，是系统运行的基本单位。
		线程：比进程更小的执行单位
	2、请简要描述线程与进程的关系,区别及优缺点？
	3、说说并发与并行的区别?
	4、为什么要使用多线程呢?
	5、使用多线程可能带来什么问题?
		内存泄漏、上下文切换、死锁、有限于硬件资源
	6、说说线程的生命周期和状态?
	7、什么是上下文切换?
		当前任务在执行完CPU时间片切换到另一个任务之前先保存自己状态，以便下次再切换回这个任务时，可以再加载这个任务状态。
	8、什么是线程死锁?如何避免死锁?
		避免死锁的几个常用方法：
		1、避免一个线程同时获取多个锁
		2、避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
		3、尝试使用定时锁，使用lock.try(timeout)来代替使用内部锁机制
		4、对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况
	9、说说 sleep() 方法和 wait() 方法区别和共同点?
    10、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？
		start()可以启动线程并使线程进入就绪状态。
		
		
		
	Java并发进阶面试题：
	1、synchronized 关键字:
		1、说一说自己对于 synchronized 关键字的了解？
			作用+修饰（底层的实现原理）
		2、说说自己是怎么使用 synchronized 关键字，在项目中用到了吗？
			修饰方法或代码块的区别
		3、讲一下 synchronized 关键字的底层原理？
			javap -csvl  字节码的执行指令分析
			
		4、说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？
			引入了大量的优化，如偏向锁、轻量级锁、（自旋锁、适应性自旋锁）、（锁消除、锁粗化）等技术来减少锁操作的开销
			
		5、谈谈 synchronized和ReentrantLock 的区别？
			ReentrantLock高级特性：等待可中断，可实现公平锁，可实现选择性通知
		
	2、volatile关键字:
		1、讲一下Java内存模型？
		2、说说 synchronized 关键字和 volatile 关键字的区别？
			修饰+原子性+可见性+阻塞情况
			
	3、 ThreadLocal:
		1、简介：
			你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。
			他们可以使用 get（） 和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题
		2、ThreadLocal原理？
			实际是ThreadLocalMap的set,get方法操作
		3、ThreadLocal的内存泄漏？
			ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。
			所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会 key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，
			在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法
	4、线程池：
		1、为什么要用线程池？
			降低资源消耗+提高响应速度+提高线程的可管理性
		2、实现Runnable接口和Callable接口的区别？
			Runnable接口不返回结果，Callable返回结果
		3、 执行execute()方法和submit()方法的区别是什么呢？
			提交不需要返回值的任务
		4、如何创建线程池？
			1、构造方法
			2、Executors工具类
			
	5、Atomic 原子类：
		1、JUC 包中的原子类是哪4类?
		2、能不能给我简单介绍一下 AtomicInteger 类的原理？
			AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升
		
	6、AQS：
		1、简介:AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的
		2、AQS原理分析？
			AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中
			
			CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配
		3、AQS组件总结？
			并发工具类




	其他面试题：
		什么是线程？
		什么是线程安全和线程不安全？
		什么是自旋锁？
		什么是Java内存模型？
		什么是CAS？
		什么是乐观锁和悲观锁？
		什么是AQS？
		什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？
		什么是Executors框架？
		什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？
		什么是Callable和Future?
		什么是FutureTask?
		什么是同步容器和并发容器的实现？
		什么是多线程？优缺点？
		什么是多线程的上下文切换？
		ThreadLocal的设计理念与作用？
		ThreadPool（线程池）用法与优势？
		Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。
		synchronized和ReentrantLock的区别？
		Semaphore（信号量）有什么作用？
		Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？
		Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？
		ConcurrentHashMap的并发度是什么？
		ReentrantReadWriteLock读写锁的使用？
		CyclicBarrier和CountDownLatch的用法及区别？
		LockSupport工具？
		Condition接口及其实现原理？
		Fork/Join框架的理解?
		wait()和sleep()的区别?
		线程的五个状态（五种状态，创建、就绪、运行、阻塞和死亡）?
		start()方法和run()方法的区别？
		Runnable接口和Callable接口的区别？
		volatile关键字的作用？
		Java中如何获取到线程dump文件？
		线程和进程有什么区别？
		线程实现的方式有几种（四种）？
		高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？
		如果你提交任务时，线程池队列已满，这时会发生什么？
		锁的等级：方法锁、对象锁、类锁?
		如果同步块内的线程抛出异常会发生什么？
		并发编程（concurrency）并行编程（parallellism）有什么区别？
		如何保证多线程下 i++ 结果正确？
		一个线程如果出现了运行时异常会怎么样?
		如何在两个线程之间共享数据?
		生产者消费者模型的作用是什么?
		怎么唤醒一个阻塞的线程?
		Java中用到的线程调度算法是什么
		单例模式的线程安全性?
		线程类的构造方法、静态块是被哪个线程调用的?
		同步方法和同步块，哪个是更好的选择?
		如何检测死锁？怎么预防死锁？



###6、IO_NIO——》已整理
####6.1、整体结构
	1、JavaIO体系
		1、IO流的分类
			1、流的方向划分
			2、操作单元划分
			3、流的角色划分为节点流和处理流
		2、常用IO流（总共40多个类）的用法
	2、Java NIO
		1、什么是NIO
		2、NIO和IO区别:
			1、面向的对象
			2、是否是阻塞
			3、Selector选择器
			4、对Channel和Buffer的输入和输出
			
		3、三大基本组成:
			1、Channels
				1、什么是Channels
				2、常见几种Channels
					1、FileChannel
					2、DatagramChannel
					3、SocketChannel
					4、ServerSocketChannel
			2、Buffers
				1、什么是Buffer，如何创建Buffer
				2、有几种类型的Bufer（7种，除了boolean外）
				3、Buffer的filp（）方法
				4、Buffer的三个属性（Capacity容量，position，limit限制）
					不同读写模式，position和limit位置不同
						1、写模式，limit和capacity相同
						2、读模式，position在起始位置
			3、Selector选择器
				1、什么是Selector：实现单线程管理多个channels
				多路复用器 。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。
		4、其他特性:
			1、Scatter、Gather
				Scatter，从Channel分到Buffer
				Gather， 从Buffer合并到Channel
	3、BIO、NIO、AIO区别
####6.2、面试题

###7、Java集合——》已整理
需要处理专题内容
####7.1、整体结构
	1、Collection
		1、List
			1、List集合基础
			2、常用子类
				1、Vector:Object数组
				2、LinkedList(源码分析):双向链表
				3、ArrayList(源码分析):Object数组
		2、Set
			1、Set集合基础
			2、常用子类
				1、HashSet：HashMap
				2、LinkedHashSet：HashMap
				3、TreeSet：红黑树
	2、Map
		1、Map基础知识
		2、Map常用子类
			1、HashMap(源码分析)：数组+链表/红黑树
			2、LinkedHashMap
			3、TreeMap：红黑树
			4、ConcurrentHashMap(源码分析)
	3、源码分析：
		1、ArrayList
			1、简介：
				底层的是动态数组
			2、核心源码/方法
			3、扩容机制
				1、当插入元素，发现数组的长度不够的时候，将进行扩容，扩容的之后的长度大小，将为原来的1.5倍
				2、将原来的数组复制到现在的数组，将新元素插入。
		2、LinedList
			1、简介：
				底层的是双向链表，有数据节点+指针节点（前驱和后继指针）
			2、核心源码/方法
			
		3、HashMap
			1、简介：
				主要存放key和value的，用哈希表实现
				底层是分两组情况
				在jdk1.8之前，数组+链表，数组是hashmap的主体，链表为了解决哈希冲突的，采用拉链式插入
				在jdk1.8之后，数组+红黑树，链表的长度大于8之后就会转换成红黑树，提高搜索时间
				
			2、实现原理
				1、HashMap通过key的hashcode值经过扰动函数（hash()）之后，计算出hash值
				2、然后通过(n-1)&hash值判断出元素的存放位置，如果当前位置存在元素，就比较
					hash值和key是否相等，如果相等直接覆盖，如果不相等的话，就通过拉链法插入元素
					
			3、几个重要方法
				1、put
				2、get
				3、reserve
					1、loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么数组中存放的数据（entry）也就越多，也就越密，也就是让链表的长度增加；loadFactor越小，也就是趋近于0，数组中存放的数据（entry）也就越少。默认值是0.75f
					2、threshold = capacity*loadFactor ，当Size>=threashold的时候，那么就要考虑对数组进行扩增。这个是衡量数组是否需要扩增的一个标准（capacity默认值是16）
					3、会经历2个阶段
						1、扩容
						2、rehash（关键是这步）
				

####7.2、面试题
	1、List，Set，Map三者区别？
	2、ArrayList与LinkedList区别？
		1、线程安全
		2、数据结构
		3、查询，插入，删除的时间复杂度
		4、是否支持快速随机访问
		5、内存占用
	3、ArrayList与Vector区别？为什么要用ArrayList取代Vector呢？
		Vector是线程安全，方法全部加锁。
	4、说一说ArrayList的扩容机制？
	
	5、HashMap和HashTable区别？
		1、线程安全
		2、效率
		3、对nullkey和null value
		4、初始容量大小和每次扩容大小
			hashMap：16，容量变为原来的2倍
			hashtable :11 ,2n+1
		5、数据结构
	6、ConcurrentHashMap 和 Hashtable 的区别？
	7、HashMap和HashSet 区别？
		HashSet底层实现是HashMap
	8、HashMap的长度为什么是2的幂次方？
	9、HashMap 多线程操作导致死循环问题？
	10、comparable 和Comparator的区别？
		comparable的compareTo（Object obj）
		comparator 的compare（Object obj ，Object obj）
###8、反射机制——》已整理
####8.1、整体结构
![Alt text](./1560310612295.png)

####8.2、面试题
	1、什么是反射？
	反射就是动态加载对象，并对对象进行剖析。在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法，这种动态获取信息以及动态调用对象方法的功能成为Java反射机制。
	
	2、反射的优缺点？
		优点：反射提高了程序的灵活性和扩展性,在底层框架中用的比较多，业务层面的开发过程中尽量少用
		缺点：性能不好 反射是一种解释操作,用于字段和方法接入时要远慢于直接代码
		
	3、反射的应用场景？
		RPC、ORM框架等


###9、数据结构及算法——》已整理10%
	一、书籍
	书籍入门：
		1、极客时间上的数据结构及算法	
		2、大话数据结构
		3、图解算法
		
	教科书书籍：
		1、数据结构及算法程序设计（java）
		
	其他的书籍：
		1、算法
	二、视频
		1、小甲鱼
	三、实践
		LeetCode
	
	对于数据结果及算法
	1、首先对常用的数据结果及算法至少理解
		1、数据结构是什么样的
		2、底层实现是怎么样的
		3、API是怎么样的
		4、时间复杂度是怎么样的
		5、应用场景是怎么样的
	
####9.1、整体结构
![Alt text](./913e0ababe43a2d57267df5c5f0832a7.jpg)


####9.2、面试题
	数据结构：
	1、数组
	2、链表
	3、栈
	4、队列
	5、散列表
	6、二叉树
	7、堆
	8、跳表
	9、图
	10、Tire树
	
	
	算法：
	1、递归
	2、排序
	3、二分查找
	4、搜索
	5、哈希算法
	6、贪心算法
	7、分治算法
	8、回溯算法
	9、动态规划
	10、字符串匹配算法

### 10、设计模式——》已整理
#### 10.1、整体结构
	要求：
	在系统的学习设计模式之后，我们需要达到3个层次
		1、能在白纸上画出所有的模式结构和时序图
		2、能用代码实现，如果模式的代码都没有实现过，是用不出来的；即所谓，看得懂，不会用
		3、灵活应用到工作中的项目中	
		
	1、设计模式6大原则
		1、单一职责原则
		2、里氏替换原则（继承关系）
		3、依赖倒置原则（面向接口）
		4、接口隔离原则
		5、迪米特法则（最少知道原则）
		6、开闭原则
		
	2、设计模式
		1、创建型
			1、简单工厂模式
			2、工厂方法模式
			3、抽象工厂模式
			4、单例模式		
		2、结构型模式
			1、适配器模式
			2、代理模式
			3、装饰模式
			4、外观模式
		3、行为型模式
			1、观察者模式
			2、策略模式
			3、命令模式
			4、模板方法模式



#### 10.2、面试题
	设计模式从以下几方面理解
		1、定义
		2、结构图
		3、时序图
		4、代码实现
		5、应用场景
		6、优缺点	
	1、JDK中有哪些设计模式？
	2、框架中有哪些设计模式？
	3、你们项目中用了哪些设计模式？



	1、准备
		1、UML图
			1、继承：空心三角形+实线
			2、实现：空心三角形+虚线
			3、组合：实心菱形+实线
			4、聚合：空心菱形+实线
			5、关联：箭头+实线
			6、依赖：箭头+虚线
			
		2、时序图
			描述对象之间的调用情况
	
	
	2、设计模式6大原则：
		1、单一职责原则
			尽量保持一个类或一个方法做一件事。
		2、里式替换原则
			主要是用来描述继承关系
		3、依赖倒置原则
			针对的面向接口编程的，抽象
		4、接口隔离原则
			接口尽量小，相互之间隔离开
		5、迪米特法则
			最少知道原则
		6、开闭原则
			对扩展开放，对修改关闭

	设计模式：
	创建型（对类的实例化过程进行了抽象，能够将软件模块中对象和应用分离）
	1、简单工厂模式
		1、定义：可以根据参数的不同返回不同的实例。
		2、模式结构图
			1、Factory 工厂角色
			2、Product 抽象产品角色
			3、ConcreteProduct 具体产品	
		3、时序图
		4、代码实现
		5、优缺点
			优点：
			1、客户端不了解对象实例创建过程
			2、对客户端是透明的
			
			缺点：
			1、工厂类集中所有产品创建逻辑
			2、系统扩展困难
		6、模式应用：
			1、JDK类库的简单工厂模式，工具类，DateFormat
			2、Java加密技术
			
	2、工厂方法模式
		1、定义：在工厂父类负责定义产品对象的公共接口，而工厂子类则负责具体的产品对象。
		
		2、模式结构图
			1、Product ：抽象产品
			2、ConcreteProduct ： 具体产品
			3、Factory ：抽象工厂
			4、ConcreteFactory：具体工厂
		3、时序图
		4、代码实现
		5、优缺点
			优点：
				1、符合开闭原则，有新产品只需扩展即可
			缺点：
				1、增加系统的难度
		6、模式应用
			1、JDBC中的工厂方法


	3、 抽象工厂模式
		1、定义：是一个超级工厂，用来创建其他的工厂
		2、模式结构图
			1、AbstractFactory：抽象工厂
			2、ConcreteFactory ： 具体工厂(2个具体工厂)
			3、AbstractProduct ： 抽象产品（2个抽象产品）
			4、Product ： 具体产品（4个具体产品）
		
			可以回忆电器的生产（要求一个具体的工厂，生产出同一品牌的不同产品（例如海尔的电视，海尔洗衣机，海尔电冰箱等））
		3、时序图
		4、代码实现
		5、优缺点
		6、模式应用
			需要更换界面主题，要求界面中的按钮，文本框，背景一起改变

	4、单例模式：
		1、定义：确保某一个类只有一个实例，而且自行实例化并向整个系统提供实例
		2、模式结构图
		3、时序图
		4、代码实现
		5、优缺点
		6、模式应用


	结构型模式
	5、适配器模式
		1、定义：
	    将一个接口转换成客户希望的另一个接口，适配器模式使不兼容的哪些类可以一起工作。包括类结构适配器，对象结构适配器
		2、模式结构图
			1、Target ：目标抽象类
			2、Adapter ： 适配器类
			3、Adaptee : 适配者类
			4、Client ： 客户端
			
			对象结构适配器图
			类结构适配器图
		3、时序图
		4、代码实现
		5、优缺点
			优点：
				1、将目标类和适配者解耦
				2、灵活性扩展性非常好
			缺点：
				类适配器不能实现多继承关系
		6、模式应用
		
	6、代理模式
		1、定义：
			给某一个对象提供一个代理，并由代理对象控制出原对象的引用，代理模式叫做Proxy，是一种对象结构型模式
		2、模式结构图
			1、Subject ： 抽象主题角色
			2、Proxy ： 代理主题角色
			3、RealSubject ： 真实主题角色
		3、时序图
		4、代码实现
		5、优缺点
			优点：
				1、代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度
				2、可以保护会真实对象的使用权限
				
			缺点：	
				1、增加了代理对象，请求处理速度变慢。
		6、模式应用
		
	7、装饰模式
		1、定义：
			动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。是一种对象结构模式
		2、模式结构图
			1、Component ：抽象构件
			2、ConcreteComponent : 具体构件
			3、Decorator ： 抽象装饰类
			4、ConcreateDecorator ： 具体装饰类
		3、时序图
		4、代码实现
		5、优缺点
			优点：1、通过使用不同装饰类以及这些装饰类的排列组合，创造出很多不同行为的组合。
			缺点：2、会生成很多小对象		
		6、模式应用
		
	8、外观模式
		1、定义：
			外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组提供一个一致界面。也称为门面模式，对象结构型模式
		2、模式结构图
			1、Facade ： 外观角色
			2、SubSystem ： 子系统角色
		3、时序图
		4、代码实现
		5、优缺点
		6、模式应用

	行为型模式
	9、观察者模式
		1、定义：
			定义对象间的一种一对多的依赖关系，使得当一个对象状态发生改变时，其依赖对象都可得到通知并自动更新。又称发布-定义模式。是一种对象行为型模式
		2、模式结构图
			1、Subject ： 目标
			2、ConcreteSubject ： 具体目标
			3、Observer ： 观察者
			4、ConcreteObserver : 具体观察者
		3、时序图
		4、代码实现
		5、优缺点
			优点
				1、观察者模式在观察目标和观察者之间建立了一个抽象的耦合
				2、实现了表示层和数据逻辑层的分离
			缺点
				
		6、模式应用
		
		
	10、策略模式
		1、定义：定义一系列的算法，将每个算法封装起来，并让它们相互替换。策略模式让算法独立于使用它的客户而变化。是一种对象行为型模式
		2、模式结构图
			1、Context ： 环境类
			2、Strategy ： 抽象策略类
			3、ConcreteStrategy:具体策略类
		3、时序图
		4、代码实现
		5、优缺点
			优点
				1、提供了管理相关算法族的办法
				2、策略模式提供了可以替换继承关系的办法
			缺点
				1、必须知道所有的策略类，自行确定使用什么策略类
		6、模式应用
		
	11、命令模式
		1、定义：
			将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化，对请求排队或者支持可撤销操作。是对象行为型模式。
		2、模式结构图
			1、Command：抽象命令类
			2、ConcreteCommand :具体命令类
			3、Invoker：调用者
			4、Receiver ： 接受者
			5、Client ： 客户类
		3、时序图
		4、代码实现
		5、优缺点
		6、模式应用
		
	12、模板方法模式


### 11、Spring——》已整理
	需要处理专题内容
#### 11.1、整体结构	
	一、基础篇
		1、Spring架构及概述
			1、概述:
			以IoC和AOP为内核，提供了展示层Spring MVC和Spring JDBC集业务层事务管理等一站式企业级应用技术
			2、Spring好处：
				1、解耦，简化开发（像IoC将对象的依赖关系交给Spring控制）
				2、AOP编程支持
				3、声明式事务支持
				4、方便测试
				5、方便集成各种优秀的框架
			3、Spring框架结构
		2、Spring子项目
			1、SpringBoot			
				Spring应用快速开发工具，用来简化Spring应用开发过程
			2、SpringCloud
				Spring为开发者提供了在分布式系统中的操作工具（如配置管理，服务发现，断路器，微代理，控制总线，一次性Token，全局锁等）
				
	二、核心篇
		1、Ioc容器基础
			1、定义
				让调用类对某给接口实现类的依赖关系由第三方（容器）注入，以便移除调用类对某一接口实现类依赖
			2、IoC基础内容：
				1、IoC的注入
					1、构造函数注入（在构造函数注入中，通过调用类的构造函数，将接口实现类通过构造函数变量传入）
					2、属性注入（setter属性）
					3、接口注入的方式
				2、涉及到的基础知识
					1、Java反射机制
					2、类加载机制
				3、IoC的类型 
					1、BeanFactory
					2、ApplicationContext
						1、ClassPathXmlApplicationContext：类路径
						2、FileSystemXmlApplicationContext:文件系统路径
							Bean的两种作用域：（Singleton，prototype）
						3、WebApplicationContext:专门为web应用准备，它允许从相应Web根目录的路径中装配配置文件完成初始化
							Bean的两种作用域：（request，session ， global session）
				4、在IoC容器中装配Bean
					1、装配描述
						1、配置类型
							1、基于XML配置
							2、基于注解方式默认采用byType自动装配
							3、基于Java类型的配置（@Configuration，@Bean）
						2、Bean的作用域
							Singleton、Prototype、request、session、globalSession
						3、装配的过程：
							Spring启动时读取应用程序提供的配置信息，并在Spring容器中生成一份相应的Bean配置注册表，然后根据这张注册表实例化Bean，装配好Bean的依赖关系，最后将这些准备就绪的Bean放到Bean缓存池中，为上层应用提供准备就绪运行环境
			
		2、Ioc容器进阶
			1、Spring容器技术内幕
				1、内部工作机制
					Spring的AbstractApplicationContext是ApplicationContext的抽象实现类，该抽象类的refresh（）方法定义了Spring容器在加载配置文件后各项处理过程，这些处理清晰刻画了Spring容器启动时所执行的各项操作。
					
		3、SpringAOP基础
			1、定义：它只是适合具有横切逻辑的应用场合，如性能检测，访问控制，事务管理及日志记录
			2、AOP的术语：
				1、连接点
				2、切点（一系列的连接点）
				3、增强（Advice）
				4、目标对象
				5、引介（特殊的增强）
				6、织入（是将增强添加到目标类的具体连接过程）
					1、编译期织入：这要求使用特殊的java编译器
					2、类装载期织入：这要求使用特殊的类加载器
					3、动态代理织入：在运行期为目标类添加增加生成子类的方式
					Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入
				7、代理类（原类+增强代理）
				8、切面（切点+增强）
				
				
				增强类型
					1、前置增强
					2、后置增强
					3、环绕增强
					4、异常抛出增强
					5、引介增强
				理解一个切面是如何创建的
				
			3、涉及到基础知识
				1、JDK的动态代理
				JDK的动态代理主要涉及java.lang.reflect包中的两个类：Proxy和InvocationHandler。其中InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起。而Proxy利用InvocationHandler动态创建一个符合某一个接口的实例，生成目标类的代理对象。
				
				理解代码实现JDK动态的过程
					1、要求目标类实现接口
					2、创建一个实现InvocationHandler的类
						1、聚合目标类并通过构造方式实例一个目标类
						2、重写invoke方法
							1、在此方法中编写需要增强的代码
							2、通过反射机制调用目标类的方法
					3、客户端使用
						1、创建目标类
						2、创建相关的增强类
						3、通过调用Proxy.newProxyInstance()方法生成目标类的代理对象
						4、调用相应的方法
					
				
				2、CGLib动态代理
					CGLib采用的是底层的字节码技术，可以为一个类创建子类，在子类中采用方法拦截技术，拦截所有父类的方法的调用并顺势织入横切逻辑
					
					
			
			4、SpringAOP的两种实现方式
				1、基于XML配置的AOP
					1、基于Schema配置切面（<aop:advisor>的方式）
					2、基于@AspectJ配置切面（<aop:aspect>的方式）
				2、基于@AspectJ注解的AOP
				选择的顺序：@AspectJ注解的AOP-》XML基于@AspectJ配置切面-》XML基于Schema配置切面
				
		4、SpringAOP进阶
				
	三、数据篇
		1、Spring事务管理
			1、数据库事务基础
				1、定义：Spring虽然提供了灵活方便的事务管理功能，但是这些功能都是基于底层数据库本身的事务处理机制
				2、何为数据库事务（ACID）一致性是最终目标
					1、数据库管理系统一般采用重执行日志来保证原子性，一致性，持久性
					2、采用数据库锁机制保证事务的隔离性
				3、数据并发问题
					1、脏读
					2、不可重复读
					3、幻读（多次统计结果不一致）
				4、数据库锁机制
					1、按锁定对象不同，一般分为表锁定或行锁定
					2、从并发事务锁定的关系上看，分为共享锁和独占锁
				5、事务的隔离级别
					1、不可提交读
					2、可提交读
					3、可重复读
					4、串行化读
					
			2、ThreadLocal
				在管理request作用域的Bean，事务管理任务调度，AOP等模块中都出现
				1、定义
				2、api
				3、实现思路：
					在ThreadLocal类中有一个Map，用于存储每个线程的变量副本，Map中元素的键为线程对象，值为对应线程的变量副本
				4、Spring中使用ThreadLocal解决线程安全
					有状态的Bean通过采用ThreadLocal进行封装，也能够以singleton方式在多线程正常工作
					
			3、Spring对事务管理的支持
				Spring为事务管理提供一致的编程模板，在高层次建立统一的事务抽象。提供了事务模板类TranscationTemplates	
				1、事务管理关键抽象
					在Spring事务管理SPI的抽象提供3个接口
					1、PlatformTranscationManager
						控制事务的提交或回滚
					2、TranscationDefinition（xml配置或注解描述，手工编程）
						1、事务的隔离级别
						2、事务的传播
						3、事务超时
						4、只读状态
					3、TranscationStatus
						代表一个事务的具体运行状态
					
					处理过程：
					PlatformTranscationManager根据TranscationDefinition提供的事务属性配置信息创建事务，并用TranscationStatus描述激活事务状态
				2、Spring的事务管理器实现类
					Spring将事务管理委托给底层具体的持久层实现框架来实现。Spring为不同的持久化框架提供了PlatformTranscationManager
					
					1、事务同步管理器
					2、事务传播行为（7种类型）
						1、propagation_required : 如果当前没有事务，则新建一个事务，如果已经存在一个事务，则加入到这个事务中
						2、propagation_supports : 支持当前事务。如果当前没有事务，则以非事务方式执行
						3、propagation_Mandatory：使用当前事务，如果没有事务，则抛出异常
						4、propagation_requires_new： 新建事务，如果当前存在事务，则把当前事务挂起
						5、propagation_not_supported :以非事务方式执行，如果当前存在事务，则把当前事务挂起
						6、propagation_never ：以非事务方式执行，如果当前存在事务，则抛出异常
						7、propagation_nested:如果当前存在事务，则在嵌套事务内执行，如果当前没有事务，则执行与propagation_required类似操作				
					3、编程式事务管理
					4、使用xml配置/注解配置声明事务（Spring AOP）
		


	四、其他
	Spring与设计模式(7种)
		1、工厂模式
			1、可以通过BeanFactory或ApplicationContext创建Bean对象
			2、IoC属于工厂模式
		2、单例模式
			1、Bean就是单例
		3、代理模式
			1、SpringAOP的使用
		4、适配器模式
			1、SpringAOP的增强或者通知使用适配器模式
			2、SpringMVC的适配器模式
		5、装饰者模式
			1、Spring配置DataSource的时候，DataSource可能有不同的数据库和数据源
		6、观察者模式
			1、事件驱动模型
		7、模板方法模式
			1、jdbcTemplate
			2、事务管理器


#### 11.1、面试题
	

### 12、SpringMVC——》已整理
#### 12.1、整体结构
		1、SpringMVC工作原理
		2、SpringMVC的相关组件
			1、dispatcherServlet：前端控制器
			2、HandleMapping：处理器映射器
			3、HandleAdapter：处理器适配器
			4、ViewResolver：视图解析器
#### 12.1、面试题
	
### 13、SpringBoot——》已整理
#### 13.1、整体结构
	1、自动配置 ：针对很多Spring应用程序常见的应用功能，SpringBoot能自动提供相关配置
		@SpringBootApplication将三个有用的注解组合在一起
	    1、@Configuration ：标明该类使用Spring基于Java的配置
	    2、@ComponetScan : 启动组件扫描
	    3、@EnableAutoConfiguration ：
	    这是一样配置开启了Spring Boot自动配置的魔力如果你的应用程序需要Spring Boot自动配置以外的其他Spring配置，一般来说，最好把它写到一个单独的@Configuration标注的类（组件扫描会发现并使用这些类）

	2、起步依赖：告诉Spring Boot需要什么功能，它就能引入需要的库
	3、命令行界面：这是Spring Boot 的可选特性，借此你只需要写代码就能完成完整的应用程序，无需传统项目构建
	4、Actuator ：让你能够深入运行中的Spring Boot应用程序
		1、Spring应用程序上下文里配置的Bean
		2、Spring Boot的自动配置做的决策
		3、应用程序取到的环境变量，系统属性，配置属性和命令行参数
		4、应用程序里线程的当期状态
		5、应用程序最近处理过的HTTP请求的追踪情况
		6、各种和内存用量，垃圾回收，Web请求以及数据源用量相关的指标
		
#### 13.1、面试题


### 14、Mybatis——》已整理 	
#### 14.1、整体结构
	1、整体框架
		1、基础支持层
			1、反射模块
				该模块对Java原生的反射进行了良好的封装，提供了更加简洁易用的API
			2、类型转换模块：
				1、Mybatis为简化配置文件提供了别名机制
				2、实现JDBC类型与Java类型之间的转换
			3、日志模块
			4、资源加载模块											
			主要是对类加载器进行封装，确定类加载器的使用顺序，并提供了加载类文件以及其他的资源文件的功能
			5、解析器模块
				1、对XPath进行封装，为Mybatis初始化时解析配置文件以及映射配置文件提供支持
				2、为了处理动态SQL语句中的占位符提供支持
			6、数据源模块
			7、事务管理
				1、Mybatis对数据库中的事务进行了抽象，其自身提供了相应的事务接口和简单实现
			8、缓存模块
			9、Binding模块
			    1、Mybatis通过Binding模块将用户自定义的Mapper接口与映射文件关联起来
		2、核心处理层
			1、配置解析
			2、SQL解析
			3、SQL执行
			4、插件
		3、接口层
			sqlSession接口
		
	理解：Mybatis执行一条SQL的大致过程
	
	2、MyBatis基础
		1、MyBatis的基本组成
			1、SqlSessionFactoryBuilder
			2、SqlSessionFactory
			3、SqlSession
			4、Sql Mapper
		2、生命周期
			1、SqlSessionFactoryBuilder（方法内）
			2、SqlSessionFactory（整个）
			3、SqlSession（请求数据处理事务过程）
			4、Mapper（请求数据处理事务过程）
			
		3、配置文件
		4、映射器（mapper）
			1、select
			2、insert
			3、delete和update
			4、参数
				1、#表示大部分情况下Mybatis会用创建预编译的语句，然后Mybatis为它设值
				2、$，传递sql语句本身
			5、sql语句
			6、resultMap结果映射集
			7、缓存
				1、系统缓存
					1、一级缓存：sqlSession 默认
					2、二级缓存：SqlSessionFactory
				2、自定义缓存
			
		5、动态SQL	
		6、插件
	
	3、MyBatis的解析和运行原理
		1、基础知识
			1、反射机制
			2、JDK动态代理
			3、CGLib动态代理
		
		2、构建SqlSessionFactory过程（重点）
		3、SqlSession运行过程（重点）
			1、SqlSession四大对象：
				Mapper执行过程是通过Executor、StatementHandler、ParameterHandler和ResultHandler来完成数据库操作和结果返回的
				1、Executor（执行器）代表执行器，由它来调度StatementHandler、ParameterHandler、ResultHandler等来执行对应的SQL
				2、StatementHandler（数据库会话器）的作用是使用数据库的Statement（PreparedStatement）执行操作
				3、parameterHandler（参数会话器）用于SQL对参数的处理
				4、ResultHandler（结果处理器）是进行最后数据集（ResultSet）的封装返回处理
				
	4、MyBatis-Spring使用		
		1、配置数据源
	    2、配置SqlSessionFactory
	    3、配置SqlSessionTemplate
	    4、配置Mapper
	    5、事务处理
	
	5、MyBatis用到的设计模式（7个）
		1、单例模式
		2、工厂模式
		3、Builder模式
		4、适配器模式
			例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现
		5、代理模式
			mapper映射器的代理MapperProxy
		6、装饰者模式
			例如Cache包中的cache.decorators子包中等各个装饰者的实现
		7、模板方法模式
			例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler
#### 14.1、面试题


### 15、MySql——》已整理 
####15.1、整体结构
	一、数据库系统原理
    1、事务（ACID）
		1、事务的定义
			1、原子性：通过回滚日志实现回滚
			2、一致性
			3、隔离性
			4、持久性:通过重做日志来保证持久性
		2、如何满足一致性（在有无并发情况）
    2、并发一致性问题
		1、数据丢失
		2、脏读
		3、不可重复读
		4、幻读
    3、锁
		MySql提供了两种锁的粒度（行级锁和表级锁）
		锁的类型：
			1、读写锁（独占和共享）
			2、意向锁（引入IX/IS都是表锁）
		
    4、隔离级别
		1、未提交读
		2、已提交读
		3、可重复读
		4、串行化
    5、多版本并发控制（MVVC）
		MVVC是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，（实现可提交读和可重复读）
		1、系统版本号
		2、事务版本号
		3、理解可重复隔离级别下实现过程。
    6、Next-Key Locks
		Next-keyLocks是Mysql的InnoDB存储引擎的一种锁实现，在可重复读隔离级别下，使用MVVC+Next-KeyLocks可以解决幻读的问题
	
	二、SQL
		1、基础   
		2、创建表
		3、修改表
		4、插入
		5、更新
		6、删除
		7、查询
		8、排序
		9、过滤
		10、通配符
		11、计算字段
		12、函数
		13、分组
		14、子查询
		15、连接
		16、组合查询
		17、视图（重点）
		18、存储过程（重点）
			对一系列SQL操作的批处理
		19、游标（重点）
			在存储过程中使用游标可以对一个结果集进行移动遍历
		20、触发器（重点）
		21、事务管理
		22、字符集
		字符集指的是一种从二进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。Mysql中每一种字符集都会对应一系列的校对规则
		23、权限管理
		
	三、MySQL
	1、mysql基础架构分析
		1、结构:
			1、server层
				1、缓存
				2、连接器
					用户信息的校验
				3、分析器
					1、词法分析
					2、语法分析
				4、优化器
					1、选择最优的执行方案去执行
				5、执行器
			2、存储引擎层（主要负责数据的存储和读取）
		2、一条sql执行过程
			所有的存储引擎都有的日志模块（binlog归档日志），redolog（重做日志）只有innoDB有
			1、查询sql语句
			2、更新sql语句(两个日志有解决事务一致性问题)理解操作过程
				更新语句执行流程如下：分析器----》权限校验----》执行器---》引擎---redo log(prepare 状态---》binlog---》redo log(commit状态)
	 2、索引
        1、B+Tree原理
			1、数据结构
				1、balance Tree ，也是平衡树，平衡树是一种查找树，而且所有叶子节点位于同一层。
			2、操作
				1、查找：对根节点进行二分法
				2、插入/删除：会破坏树的平衡性，因此在插入删除操作之后，需要对数进行一个分裂，合并，旋转操作。
			3、与红黑树比较
				1、更少的查找次数
				2、利用磁盘预读特性
        2、Mysql索引
			1、B+Tree索引
				1、主索引（聚族索引）
				2、辅助索引
			2、哈希索引
			3、全文索引
			4、空间数据索引
        3、索引优化方式
			1、独立的列
			2、多列索引
			3、索引列的顺序（选择性最强放在最前面）
			4、前缀索引（选择部分的字段查询）
			5、覆盖索引（索引包含所需要查询的字段）
		
        4、索引优点
			1、减少服务器扫描的数据行数
			2、帮助服务器避免排序和分组，以及临时表
			3、将随机IO变成顺序IO
			
        5、索引使用条件
			中到大型，索引有效
		
    3、查询性能优化
        1、使用Explain进行分析
			1、重要的字段：select_type（查询类型）,type/key（使用索引）,rows（扫描行数）
        2、优化数据访问
			1、减少请求的数据量
				1、返回必要的列
				2、返回必要的行
				3、缓存重复查询的数据
			2、减少服务器端扫描行数
				最有效方式使用索引来覆盖查询
        3、重构查询方式
			1、切分大查询
			2、分解大连接查询
			
    4、存储引擎
        1、InnoDB
		   1、是mysql默认的事务型存储引擎
           2、实现了四个标准的隔离级别，默认级别是可重复读，在可重复读的情况下，通过MVVC+间隙锁防止幻读
           3、主索引是聚族索引，索引中保持了数据，从而避免直接读取磁盘。
           4、内部做了很多优化，包括磁盘读取数据时采用可预测读，自适应哈希等
           5、支持真正的在线热备份
		
        2、MyISAM
			1、不支持事务
            2、不支持行级锁，只能对整张表进行加锁
            3、崩溃修复，恢复速度更慢 
			
        3、两者比较
			1、事务：InnoDB是事务型，
			2、并发：MyISAM只支持表级锁，而InnoDB还支持行级锁
			3、外键：InnoDB支持外键
			4、备份：InnoDB支持在线热备份
			5、崩溃恢复：MyISAM崩溃后发生损坏概率比InnoDB高很多
			6、其他特性：MyISAM 支持压缩表和空间数据索引
		
		
    5、数据类型
        1、整型
        2、浮点型
        3、字符串
        4、时间和日期
		
		
    6、切分
        1、水平切分
			切分的数据记录，将数据分布到集群不同节点
        2、垂直切分
			把一个表切分到多张表（常用字段和不常用字段分别放在不同的表中）
        3、Sharding策略
			1、哈希取模
			2、范围（ID和时间）
			3、映射表：使用单独的一个数控来存储映射关系
				
		4、Sharding存在问题（重点理解）
			1、事务问题：使用分布式事务来解决，比如XA接口
			2、连接：可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接
			3、ID唯一性
				1、使用全局唯一ID
				2、为每个分片指定一个ID范围
				3、分布式ID生成器
			
    7、复制
        1、主从复制
			主要涉及三个线程：binlog线程，I/O线程和SQL线程
			1、binlog线程：负责将主服务器上的数据更改写入到二进制日志（Binary log）
			2、I/O线程：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）
			3、Sql线程:负责读取中继日志，解析出主服务器以及执行的数据更改并在从服务器上执行
		
		
        2、读写分离
			1、主从服务器负责各自的读和写，极大程度缓解了锁的作用
			2、从服务器可以使用MyISAM，提升查询性能以及节约系开销
			3、增加冗余，提高可用性
		

####15.2、面试题
### 16、Redis及缓存系统——》已整理
####16.1、整体结构
	1、概述
		Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射
		1、键的类型只能是字符串，值支持五种字符串、列表、散列表、集合、有序集合
		2、可以持久化到硬盘、使用复制扩展读性能、使用分片来扩展写性能
	
	2、数据类型及数据结构理解
		1、String
			1、数据结构：简单动态字符串
			2、常用命令: set,get,decr,incr,mget 等
		2、List
			1、数据结构：压缩表或者双向链表
			2、常用命令: lpush,rpush,lpop,rpop,lrange等
		3、Hash
			数据结构：压缩表或者字典
			1、dictht是一个散列表结构，使用拉链法解决哈希冲突
			2、常用命令： hget,hset,hgetall 等
		4、Set
			1、数据结构：整数集合
			2、常用命令： sadd,spop,smembers,sunion 等
		5、ZSet（有序集合）
			1、数据结构：跳跃表
			2、常用命令： zadd,zrange,zrem,zcard等
			
	3、数据结构
		1、简单动态字符串SDS
			1、定义：
				1、free记录buf中未使用字节的数量
				2、len记录buf数组中已使用的字节的数量
				3、buf，字节数组，用于保存字符串
			
		2、链表
			链表和链表节点的实现
			1、链表节点
				1、前置节点
				2、后置节点
				3、节点的值
			2、list结构
				1、表头指针head
				2、表尾指针tail
				3、链表长度计数器len
				4、dup、free和match成员用于实现多态链表所需的特定函数
				
				
		3、字典
			哈希键底层实现是字典，字典底层实现又是哈希表
			Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有很多的哈希节点就保存了字典中的一个键值对。
			1、哈希表
				1、table哈希表数组
				2、size哈希表大小
				3、sizemask哈希表大小掩码，用于计算索引值
				4、used表示哈希表已有节点数量
			2、哈希表节点（使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对）
				1、key属性保存着键值对中的键，而v属性则保存键值对中的值
				2、next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以解决键冲突问题
			3、字典	
				1、type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的
				2、ht属性是一个包含两个项的数组，数组中每个项都是一个dictht哈希表，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用
				3、rehashidx:它记录了rehash目前的进度
				4、哈希算法--》待定
				5、解决哈希冲突--》待定
				6、rehash--》待定
				7、渐近rehash--》待定	
				
		4、跳跃表
			是一种有序数据结构，它通过在每个节点中维持多个执向其他节点的指针，从而达到快速访问节点
			1、如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合的底层实现。
			2、跳跃表有两个部分组成，跳跃表节点和用于保存跳跃表节点的相关信息
				1、zskiplist结构：
					1、header：指向跳跃表的表头节点
					2、tail：指向跳跃表的表尾节点
					3、level：记录目前跳跃表内，层数最大的那个节点的层数
					4、length：记录跳跃表的长度
				2、zskiplistNode结构：
					1、层level
					2、后退bw
					3、分值score
					4、成员对象
					
		5、整数集合
			是集合键的底层实现之一
		6、压缩列表
			是列表键和哈希键的底层实现之前。
			
			
	4、使用场景
		1、计数器：
			可以对String进行自增自减运算，从而实现计数器功能
		2、缓存：
			将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存命中率
		3、消息队列：
			List是双向链表，可以通过lpush和rpop写入和读取消息
		4、会话缓存：
			统一存储多台应用服务器的会话信息。
		5、分布式锁实现：
			可用使用Redis自带的Sent命令实现分布式锁，还可用RedLock分布式锁实现
			
	5、Redis与Memcached
		1、数据类型： memchached 仅支持字符串类型，而redis支持五种不同的数据类型
		2、数据持久化：Redis支持两种持久化策略，RDB快照和AOF日志。而Memcached不支持持久化
		3、分布式：redis cluster实现了分布式支持
		4、内存管理机制
			1、Redis中，并不是所有数据都一直存储在内存中，会把一些没有用的数据交换到磁盘中，memchached的数据会一直保存在内存中
			2、memchached将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但会导致利用率不高
			
	6、reids设置过期时间(过期策略)
		注意：对于散列表这种容器，只能为整个键设置过期时间，不能为键里面的单个元素设置过期时间。
		1、定时删除
			每一段时间随机抽取一些设置了过期时间的key
		2、惰性删除
			使用的时候，再去判断key的时间，才会被redis删除掉
	
	7、数据淘汰策略
		1、6种淘汰策略
			1、volatile-lru:从已设置过期时间的数据中集中挑选最近最少使用的数据淘汰
			2、volatile-ttl:从已设置过期时间的数据中集中挑选将要过期的数据淘汰
			3、volatile-random:从已设置过期时间的数据集中任意选择数据淘汰
			4、allkeys-lru: 从所有数据中挑选最少使用的数据淘汰
			5、allkeys-random ： 从所有数据集中任意选择数据进行淘汰
			6、noeviction ： 禁止驱逐数据
		
		
	8、持久化
		1、RDB持久化（通过加载RDB文件）
			1、可以将快照复制到其他服务器从而创建具有相同的服务器副本
		2、AOF持久化（加载命令）
			1、将写命令添加到AOF文件的末尾
			2、使用AOF持久化需要设置同步选项，确保写命令什么时候同步到磁盘文件
		
		
		
	9、事务
		Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来
		
	10、事件（重点）
		Redis服务器是一个事件驱动的程序
		1、文件事件
			1、服务器通过套接字与客户端或者其他服务器进行通信，文件事件就是对套接字操作的抽象
			2、Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器
			
		2、时间事件
			需要在给定的时间点执行，时间事件是对这类定时操作的抽象
		
	11、复制（重点）
		1、通过使用slaveof host port命令来让一个服务器成为另一个服务器的从服务器。一个从服务器只能有一个主服务器，而且不支持主主复制。
		2、连接过程
			1、主服务创建快照，并发送给从服务器，发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令
			2、从服务器丢弃所有旧数据，载入快照，接受主服务器的写命令
			3、主服务器每执行一次写命令，就向从服务器发送相同的写命令
	
	12、Sentinel
		哨兵可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。
		
	13、分片（重点）
		1、分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面。
		根据执行分片的位置，可以分为三种分片方式：
			客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。
			代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。
			服务器分片：Redis Cluster。
####16.2、面试题

### 17、消息队列及消息系统——》已整理
####17.1、整体结构
	1、RabbitMQ简介
		1、消息中间件
			两种传递模式：
			1、点对点（P2P）
			2、发布/订阅 模式（Pub/Sub）
				消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息，在消息一对多广播时使用
		2、消息中间件作用
			1、解耦
			2、异步
			3、削峰
			4、冗余（存储）：有些情况下，处理数据的过程会失败，消息中间件可以吧数据进持久化直到它们已经被完全处理。
			5、扩展性
			6、可恢复性：当系统一部分组件失效时，不会影响到整个系统。
			7、顺序保证：在大多数使用场景下，数据处理的顺序很重要
			8、缓冲
			
		3、RabbitMQ特点
		4、RabbitMQ安装及简单使用
		
	2、RabbitMQ入门
		可以想象成（由邮局、邮箱、邮递员组成的一个系统）
		1、基本概念：
			1、Producer生产者
			2、Consumer消费者
			3、broker消息中间件服务节点（RabbitMQ服务器）
			4、队列：消息只能存储在队列中
			5、Exchange交换器：生产者将消息发送到Exchange，由交换器将消息路由到一个或者多个队列中
			6、RoutingKey：路由键，生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用于来指定这个消息的路由器规则，而这个RoutingKey需要与交换器类型和绑定键联合使用才能最终生效。
			7、Binding ：绑定，RabbitMQ中通过绑定将交换器与队列关联起来，在绑定的时候一般会制定一个绑定键。
			8、交换器类型
				1、fanout：它会把所有发送到该交换器的消息路由到所有与该交换器绑定队列中
				2、direct：它会把消息路由到那些Bindingkey和RoutingKey完全匹配的队列中
				3、topic: 路由到相互匹配的队列中
				4、heads:headers类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容的heads顺序拧进行匹配
		2、RabbitMQ运转流程
			1、生产者发送消息的过程
				1、生产者连接到RabbitMQ Broker，建立一个连接（Connection）开启一个信道（Channel）
				2、生产者声明一个交换器，并设置相关属性，比如交换机类型，是否持久化
				3、生产者声明一个队列并设置属性
				4、生产者通过路由键将交换器和队列绑定起来
				5、生产者发送消息至RabbitMQ Broker，其中包含路由键，交换器等信息
				6、相应的交换器根据接收到的路由键找相应的匹配的队列
				7、如果找到，存入队列，没有找到的，退回生产者。
				8、关闭信道
				9、关闭连接
			2、消息者接收消息的过程
				1、消费者连接到RabbitMQ Broker，建立一个连接（Connection）开启一个信道（Channel）
				2、消费者向RabbitMQ Broker请求消费相应队列中的消息，可能设置相应的回调函数，以及一些准备工作
				3、等待RabbitMQ Broker 回应并投递相应的队列中的消息，消费者接收消息
				4、消费者确认ack接收到的消息
				5、RabbitMQ从队列中删除相应已被确认的消息
				6、关闭信道
		
			3、AQMP协议介绍
		
	3、RabbitMQ进阶	
	

####17.2、面试题

### 18、Dubbo及ZooKeeper——》已整理
	1、dubbo 工作原理：服务注册、注册中心、消费者、代理通信、负载均衡；
    2、网络通信、序列化：dubbo 协议、长连接、NIO、hessian 序列化协议；
    3、负载均衡策略、集群容错策略、动态代理策略：dubbo 跑起来的时候一些功能是如何运转的？怎么做负载均衡？怎么做集群容错？怎么生成动态代理？
    4、dubbo SPI 机制：你了解不了解 dubbo 的 SPI 机制？如何基于 SPI 机制对 dubbo 进行扩展？

####18.1、整体结构
	一、Dubbo
	1、重要概念
		1、什么是Dubbo？
		是一款高性能、轻量级开源RPC框架，它提供了三大核心能力：面向接口远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。
		2、声明式RPC、RPC原理是什么？
			1、概念：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术协议。
			2、原理过程：
				1、服务消费方（client）调用以本地调用方式调用服务
				2、client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体
				3、client stub 找到服务地址，并将消息发送到服务端
				4、server stub 收到消息后进行解码
				5、server stub 根据解码结果调用本地的服务
				6、本地服务执行并将结果返回给server stub
				7、server stub将返回结果打包成消息并发送至消费方
				8、client stub接收到消息，并进行解码
				9、服务消费方得到最终结果
		3、为什么要用Dubbo（SOA面向服务架构）
			1、负载均衡
			2、服务调用链路生成
			3、服务访问压力以及时长统计、资源调度和治理
			4、服务降级
		4、什么是分布式系统？
			有多个节点组成，节点可以理解计算机，节点之间不是独立，是相互连接，在这些节点上面又部署我们的组件，组件之间又相互连接着
		5、为什么要分布式?
			系统业务太过于庞大，不利于开发，维护，快速迭代，不易测试，不易扩展等问题，无法提高系统的性能。
			
	2、Dubbo的架构
		1、Dubbo的架构图解
			上述节点简单说明：
			Provider： 暴露服务的服务提供方
			Consumer： 调用远程服务的服务消费方
			Registry： 服务注册与发现的注册中心
			Monitor： 统计服务的调用次数和调用时间的监控中心
			Container： 服务运行容器
			
			调用关系说明：
	
			1、服务容器负责启动，加载，运行服务提供者。
			2、服务提供者在启动时，向注册中心注册自己提供的服务。
			3、服务消费者在启动时，向注册中心订阅自己所需的服务。
			4、注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
			5、服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
			6、服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。
			
			重要知识点总结：
			1、注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小
			2、监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示
			3、注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外
			4、注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者
			5、注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表
			6、注册中心和监控中心都是可选的，服务消费者可以直连服务提供者
			7、服务提供者无状态，任意一台宕掉后，不影响使用
			8、服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复
		2、Dubbo工作原理--》理解记忆
			各层说明：
			第一层：service层，接口层，给服务提供者和消费者来实现的
			第二层：config层，配置层，主要是对dubbo进行各种配置的
			第三层：proxy层，服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton
			第四层：registry层，服务注册层，负责服务的注册与发现
			第五层：cluster层，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务
			第六层：monitor层，监控层，对rpc接口的调用次数和调用时间进行监控
			第七层：protocol层，远程调用层，封装rpc调用
			第八层：exchange层，信息交换层，封装请求响应模式，同步转异步
			第九层：transport层，网络传输层，抽象mina和netty为统一接口
			第十层：serialize层，数据序列化层，网络传输需要
		
		
		
	3、Dubbo的负载均衡策略
		1、什么是负载均衡？
		2、Dubbo提供的负载均衡策略
			1 Random LoadBalance(默认，基于权重的随机负载均衡机制)
			2 RoundRobin LoadBalance(不推荐，基于权重的轮询负载均衡机制)
			3、LeastActive LoadBalance
			4、ConsistentHash LoadBalance
				一致性Hash，相同参数的请求总是发到同一提供者。(如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性hash策略
		3、配置方式
			1、xml方式
			2、注解配置方式
		
		
	4、Zookeeper宕机与dubbo直连的情况
		dubbo的健壮性表现：
		1、监控中心宕掉不影响使用，只是丢失部分采样数据
		2、数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务
		3、注册中心对等集群，任意一台宕掉后，将自动切换到另一台
		4、注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯
		5、服务提供者无状态，任意一台宕掉后，不影响使用
		6、服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复

	二、Zookeeper
	1、什么是ZooKeeper
		1、Zookeeper概览
			1、Zookeeper的设计目标是将那些复杂而且容易出错的分布式一致性服务封装起来，构成一个高效的原语集，并以一系列简单易用的接口提供给用户使用
			2、Zookeeper是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于Zookeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知，集群管理、Master选举、分布式锁和分布式队列等功能。
			3、应用场景
				1、注册中心（提供发布订阅服务）
				
		2、介绍下Zookeeper
			2n和2n-1的容忍度是一样的，3台和4台最大允许宕机的只有一台
		
	2、关于Zookeeper的一些重要概念
		1、zookeeper重要概念总结
			1、Zookeeper本身是一个分布式程序（只要半数以上节点存活，zookeeper就能正常服务）
			2、为了保证高可用，最好以集群形态部署
			3、Zookeeper将数据保存在内存中，这也是保证了高吞吐和低延迟
			4、Zookeeper是高性能的。
			5、Zookeeper有临时节点的概念
			6、Zookeeper底层其实只提供了两个功能，
				1、管理（存储、读取）用户提交的数据
				2、为用户程序提供数据节点监听服务
				
		2、会话（Session）：Zookeeper服务器与客户端会话。
			作用：通过这个连接，客户端能够通过心跳检测与服务器保存有效会话，也能够向Zookeeper服务器发送请求并
				接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。
				
		3、Znode
			在Zookeeper中，节点分为两类：
			第一类同样是指构成集群的机器，成为机器节点
			第二类是数据模型中的数据单元，数据节点Znode
			node分为持久节点和临时节点两类，节点有个特殊属性（SQUENTIAL）
			1、持久节点：一旦这个Znode被创建了，除非主动进行Znode的移除操作，否则这个Znode将一直保存在Zookeeper上。
			2、临时节点：它的生命周期和客户端会话绑定，一旦客户端会话消失，临时节点也被移除掉。
			
			
		4、版本
			对于每个ZNode，Zookeeper都为其维护一个Stat数据结构，Stat中记录ZNode的三个数据版本，
			1、version：当前Znode的版本
			2、cversion：当前Znode子节点的版本
			3、aversion：当前ZNode的ACL版本
			
		5、watcher(事件监听器)
			允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，zookeeper服务端
			会将事件通知到感兴趣的客户端上去，该机制是Zookeeper实现分布式协调服务的重要特性
			
			
		6、ACL
			采用了ACL策略来进行权限控制，类似于unix文件系统的权限控制
			1、create ：创建子节点权限
			2、read ：获取节点数据和子节点列表的权限
			3、write ： 更新节点数据的权限
			4、delete ： 删除子节点的权限
			5、admin ：设置节点acl的权限
			
	3、Zookeeper特点
		1、顺序一致性：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。
		2、原子性： 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。
		3、单一系统映像 ： 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。
		4、可靠性： 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。
			
	4、Zookeeper设计目标
		1、简单的数据模型		
		2、可构建集群
			集群间通过Zab协议来保持数据的一致性
		3、顺序访问
			1、对于来自客户端的每个更新请求，Zookeeper都会分配一个全局唯一的递增编号，这个
				编号反应了所有事物操作的先后顺序。
			
		4、高性能
			适合读多写少的场景
			
	5、zookeeper集群角色介绍
		1、Master/Slave 模式（主备模式）
		在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了Leader、Follower 和 Observer 三种角色	
		ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 “Leader” 的机器，Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，Follower 和 Observer 都只能提供读服务。Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能	
			
			
		当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的Leader服务器。
		这个过程大致是这样的：
		1、Leader election（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。
		2、Discovery（发现阶段）：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。
		3、Synchronization（同步阶段）:同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本同步完成之后 准 leader 才会成为真正的 leader。
		4、Broadcast（广播阶段） 到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步	
			
			
	6、ZooKeeper &ZAB 协议&Paxos算法
		1、ZAB协议介绍
			ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性
			
		2、ZAB 协议两种基本的模式：崩溃恢复和消息广播
			ZAB协议包括两种基本的模式，分别是 崩溃恢复和消息广播。当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的Leader服务器。当选举产生了新的 Leader服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。
	
			当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。 当一台同样遵守ZAB协议的服务器启动后加人到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加人的服务器就会自觉地进入数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。正如上文介绍中所说的，ZooKeeper设计成只允许唯一的一个Leader服务器来进行事务请求的处理。Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器
		
		

####18.2、面试题


### 19、分布式系统及中间件——》已整理
####19.1、整体结构
	1、分布式系统
		1、概念及意义
			1、概念：
				首先分布式系统一定是由多个节点组成系统，一般来说一个节点就是我们一台计算机，然后这些节点不是孤立的，而是相互连通，最后这些连通的节点部署了我们的组件，而且相互之间的操作有协同。
			2、意义：
				1、升级单机处理能力
				2、单机处理能力存在瓶颈
				3、出于稳定性和可用性的考虑
		2、基础知识
			1、组成计算机5大要素（CPU，内存，外设，输入设备，输出设备）
			2、线程与进程的执行模式
			3、网络通信知识
				1、OSI和TCP/IP网络模型
				2、网络IO实现方式
					1、BIO
					2、NIO
						基于事件驱动思想，采用的Rector模式，一个Socket可以管理多个线程
					3、AIO
			4、如何把应用从单机扩展到分布式
				1、输入设备的变化
				2、输出设备的变化
				3、控制器的变化
					1、使用硬件负载均衡的请求调用
					2、使用LVS的请求调用，也称为透明代理
					3、采用名称服务的直连方式的请求调用
					4、采用规则服务器控制路由的请求直接调用
					5、通过Master+Worker的方式
				4、运算器的变化
				5、存储器的变化
					1、使用代理的多及Key-Value服务
					2、使用名称服务的key-Value服务
					3、使用规则服务器的key-value服务
			5、分布式系统的难点
				1、缺乏全局时钟
				2、面对故障独立性
				3、处理单点故障
					1、给这个单点做好备份
					2、降低单点故障的影响范围
				4、事务的挑战
	
	
	2、大型网站及其架构演进
		1、什么是大型网站
			大型网站是一种常见的分布式系统，高并发，大数据量
		2、架构演进过程（重点理解）
			1、Java技术和单机来构建网站
			2、单机负载告警，数据库和应用分离
			3、应用服务器负载告警，应用服务器走向集群
				带来问题：
				1、最终用户对两个服务器访问选择问题（DNS和负载均衡设备解决）？
				2、解决应用服务器变成集群后的Session问题？
					1、Session Sticky：
						在负载均衡上做手脚，让同样的Session请求每次都发送到同一个服务器上。
						带来问题：
							1、如果有一台web服务器宕机或者重启，数据都会丢失。
							2、负载均衡器变成了一个有状态的节点，要将会话保持到具体的Web服务器的映射
							
					2、Session Replication：
						在服务器之间增加了数据的同步，保证Session一致性。
						带来问题：
							1、同步Session数据造成了网络带宽的开销，只要Session有变化，就需要数据同步
							2、每台web服务器都保存所有的Session数据，占内存严重			
					3、Session 数据集中存储
						把Session数据集中存储起来，然后不同的web服务器从同样地方来获取Session
						带来问题：
							1、引入了网络操作问题
							2、如果集中存储Session的机器或者集群有问题，会影响我们的应用
					4、Cookie Based
						cookie包含Session数据（类似我们带碗去吃饭）
						带来问题：
							1、Cookie长度限制
							2、安全性
							3、带宽消耗
							4、性能影响
			4、数据读压力变大，读写分离
				1、采用数据库作为读库
					带来问题：
						1、数据复制问题
						2、应用对数据源的选择问题
				2、搜索引擎其实一个读库
				3、加速数据读取的利器-缓存
			5、弥补关系型数据不足，引入分布式存储系统
			6、读写分离后，数据库又遇到瓶颈
				1、专库专用，数据垂直拆分（不同表拆分到不同数据库）
				2、垂直拆分后，水平拆分
					带来问题：
						1、SQL路由问题
						2、分页问题
			7、数据库问题解决后，应用面对新挑战
				1、拆分应用
				2、走服务化的路
					1、分成三层
				3、认识消息中间件
					1、解耦
					2、异步
					3、削峰
						
	3、构建Java中间件	
		1、Java中间件的定义
			1、远程过程调用和对象访问中间件，主要解决分布式环境下应用相互访问问题
			2、消息中间件
			3、数据库访问中间件
		2、中间件的基础知识
			1、JVM
			2、Java并发编程
				1、线程池
				2、synchronized
				3、ReentrantLock
				4、volatile
				5、Atomics
				6、wait、notity、notityall
				7、并发工具
				8、并发容器
			3、动态代理
			4、反射机制
			5、网络通信
				
			
	4、服务框架
		1、网站功能持续丰富后的困境与应对
		2、服务框架的设计与实现
			1、服务框架原型
				1、客户端：
					1、接口调用
					2、寻址路由
					3、编码
					4、通信
				2、服务端提供端
					1、服务调用
					2、实例定位
					3、解码
					4、通信			
			2、服务客户端的设计与实现
				具体实现过程：
					1、调用发起
					2、寻址路由
					3、协议适配/序列化
					4、网络传输
						一般采用的NIO，可以直接采用JavaNIO或采用第三方封装好的组件
					5、反序列化/协议解析
						注意问题:
							1、Java序列化或反序列化时自身的性能问题已经跨语言问题
							2、序列化和反序列化的性能开销
							3、还需要注意序列化长度
					6、得到结果，返回给调用方			
			3、服务提供端的设计与实现
				具体实现过程：
					1、网络传输
					2、反序列化/协议解析
					3、定位服务
					4、执行方法生成方法
					5、协议适配/序列化
					6、网络传输
		3、实战中的优化
			1、服务拆分
			2、服务的粒度
			3、优雅和使用的平衡
			4、分布式环境中请求合并
		4、为服务化护航的服务治理
			1、管理服务
			2、查看服务
		
				
	5、数据访问层
		1、数据库的挑战与应对（4个挑战）
			挑战1：数据库垂直/水平拆分的困难？
				数据拆分
				1、垂直拆分：把一个数据库中不同业务单元的数据分到不同的数据库里面
					带来的影响：
						1、单机的ACID保证被打破。数据到了多机后，原来在单机通过事务来进行的处理逻辑会受到很大的影响，我们面临的选择是，要么放弃原来的单机事务，修改实现，要么引入分布式事务。
						2、一些join操作会变得比较的困难
						3、靠外键去约束的场景会受到影响
				2、水平拆分：把同一个业务单元的数据拆分到多个数据库中
					带来的影响：
						4、依赖单库的自增序列生成唯一ID会受影响
						5、针对当个逻辑意义上的表的查询要跨库
			挑战2：单机变为多机后，事务如何处理？
				1、什么是分布式事务？
				2、分布式模型与规范是什么?
				3、如何解决分布式事务的一致性问题?
					1、两阶段提交
					2、CAP理论
					3、保证的是最终一致性，通过1、补偿机制，2、基于paxos算法
			挑战3：多机的Sequence问题与处理（保证唯一性与连续性）
				实现方案：我们把ID集中放在一个地方管理，对于每个ID序列独立管理，每台机器使用ID时都是从这个ID生成器上取
				需要解决：
					1、性能问题
					2、生成器的稳定问题
					3、存储问题
			挑战4：应对多机的数据查询
				1、跨库Join
					解决思路：
					1、在应用层把原来的数据库的Join操作分成多次数据库查操作
					2、数据冗余，也就是对一些常用信息进行冗余
					3、借助外部系统（例如搜索引擎）解决一些跨库的问题
				2、外键约束
				3、跨库查询的问题及解决
				
		2、数据访问层的设计与实现
			1、整体流程：
				1、SQL解析
				2、规则处理
				3、SQL改写
				4、数据源选择
				5、SQL执行
				6、结果集返回合并处理
	
			2、独立部署数据访问层实现方式
				从数据层的物理部署来说可以分为jar包方式或Proxy的方式
			
			
		
	6、消息中间件
		1、消息中间件的价值
		2、互联网时代中间件
			1、在大型互联网中，消息中间件最基本：解耦、异步、削峰
			2、还要考虑的问题：
				1、消息的顺序保证
				2、消息可扩展性
				3、消息可靠性
				4、业务操作与消息发送一致性
				5、多集群订阅者方面
			问题1：如何解决消息发送一致性？
				（一致性产生消息的业务动作与消息发送的一一致，业务成功，消息一定要发送出去）
				最终解决方案：发送消息的正向流程和检查业务操作结果的反向流程合起来，就是解决业务操作与发送消息一致性的方案
				1、发送消息给消息中间件
				2、消息中间件入库消息
				3、消息中间件返回结果
				4、业务操作
				5、发送业务操作结果给消息中间件
				6、更改存储中消息状态
			问题2：如何解决消息中间件与使用者的强依赖问题？
				思路：
				1、提供消息中间件系统的可靠性，但是在没有办法保证百分百可靠
				2、对于消息中间件系统中影响业务操作进行的部分，使其可靠性与业务自身的可靠性相同
				3、可以提供弱依赖支持，能够较好地保证一致性
				
			问题3：消息模型对消息接收的影响？
				1、JMS Queue模型（点对点）
				2、JMS Topic模型（发布/订阅）
			问题4：保证消息可靠性的做法？	
				1、消息发送端可靠性保证
				2、消息存储的可靠性保证
					1、实现基于文件的消息存储
					2、采用数据库作为消息存储
					3、基于双机内存的消息存储
				3、消息系统的扩容处理
					1、消息中间件自身如何扩容
						是让消息的发送者和消息的订阅者能够感知到有新的消息中间件机器加入到集群，这是通过软负载中心完成的。
					2、消息存储的扩容处理
						1、不用保证消息顺序
						2、提供从服务器端对消息投递的方式，不支持主动获取消息
				
				4、消息投递的可靠性保证
					1、消息投递简介
						消息中间件需要显示地收到接受者确认消息处理完毕的信号才能删除消息、
					2、投递处理的优化
			问题5：订阅者视角的消息重复的产生和应对？
				1、消息重复产生原因
					1、消息发送端应用的消息重复发送
						消息成功进入消息存储后，因为各种原因使得消息发送端没有收到成功的返回结果
					2、消息到达了消息存储，由消息中间件进行向外投递时产生重复
						因为消息接收者处理完消息后，消息中间件不能及时更新投递状态所造成	
			问题6：如何保证消息的顺序消费？
	
			
			
	7、软负载中心与集中配置管理
		1、软负载中心
			1、聚合地址信息
			2、生命周期感知
	
		2、软负载中心的结构
			软负载中心包括1、软负载中心的服务端，2、软负载中心的客户端
			1、聚合数据：
				聚合后的地址信息列表
			2、订阅关系：
				通过dataId和groupId确定一个数据内容。
			3、连接数据
				是指连接到软负载中心的节点和软负载中心已经建立的连接的管理

####19.2、面试题
https://juejin.im/post/5ab898b9518825188038eca3


	1、谈谈业务中使用的分布式场景？
		1、分布式服务框架
		2、分布式存储等（七牛）
		
	2、分布式事务
		1、概念：事务操作位于不同的节点上，需要保证事务的ACID
		2、产生原因：
			1、数据库的分库分表
			2、SOA架构（Dubbo，分布式服务架构）
		3、应用场景
			1、减少库存，更新订单状态。库存和订单不在同一个数据库，因此涉及到分布式事务
			2、支付：买家账户扣款，卖家账户入账。
			
		4、解决方案：
			1、两阶段提交协议：
				它可以使用 XA 来实现，XA 它包含两个部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如 Oracle、DB2 这些商业数据库都实现了 XA 接口；而事务管理器作为全局的协调者，负责各个本地资源的提交和回滚
			2、消息中间件
				1、用法：可以把一个业务操作转成一个消息。
				2、实现过程：
					1、消息发送端的可靠性
						在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息中间件，若转移消息成功则删除消息表中的数据，否则继续重传。
					2、消息接收端的可靠性
						保证接收端处理消息业务逻辑具有幂等性，那么消费多少次消息，最后处理结果都是一样的。
						保证消息具有唯一的编号，并使用一张日志来记录已经消费的消息编号
						
	3、负载均衡的算法与实现
		1、算法
			1、轮询：对于差不多性能的设备，平均分
			2、加权轮询
			3、最少连接
			4、加权最少连接
			5、随机算法
			
		2、实现
			1、DNS解析：使用DNS作为负载均衡器，根据负载情况返回不同的服务器的IP地址
			2、修改MAC地址：使用LVS这种链路层负载均衡器，根据负载均衡情况修改请求的MAC地址
				
			3、修改IP地址：在网络层修改请求的目的IP地址	
				
			4、HTTP重定向：
				HTTP 重定向负载均衡服务器收到 HTTP 请求之后会返回服务器的地址，并将该地址写入 HTTP 重定向响应中返回给浏览器，浏览器收到后需要再次发送请求
			5、反向代理：发生在服务器端，用户不知道代理的存在
				
				
	4、分布式锁
		实现方式：
		1、redis分布式锁
			1、基于setnx、expire
			使用setnx（set if not exit）命令插入一个键值对，如果Key已经存在，那么会返回False，否则插入成功并返回True。因此客户端在尝试获取锁的时候，先使用SetNt向Redis中插入一个记录，如果返回True表示获得锁。返回False表示已经有客户端占用锁。
			2、RedLock算法
				ReadLock 算法使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时还可用。
				1、尝试从 N 个相互独立 Redis 实例获取锁，如果一个实例不可用，应该尽快尝试下一个。
				2、计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数（N/2+1）实例上获取了锁，那么就认为锁获取成功了
				
				3、如果锁获取失败，会到每个实例上释放锁
					
		2、Zookeeper分布式锁			
			1、创建一个锁目录 /lock	
			2、在 /lock 下创建临时的且有序的子节点，第一个客户端对应的子节点为 /lock/lock-0000000000，第二个为 /lock/lock-0000000001，以此类推
			3、客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁
			4、执行业务代码，完成后，删除对应的子节点。
		
		3、数据库分布式锁
			1、基于 MySQL 锁表
			2、采用乐观锁增加版本号
				根据版本号来判断更新之前有没有其他线程更新过，如果被更新过，则获取锁失败

	5、分布式Session
		1、 粘性 Session
			1、原理：在负载均衡服务器上做设置，一直转发某一台服务器
			2、优点：简单
			3、缺点：缺乏容错性
		2、服务器Session复制
		3、Session共享机制（独立一个服务器供Session）
		4、还有Cookie保存Session	
		
			
	6、分库分表带来的问题
		1、垂直拆分
			1、事务被破坏
			2、表之间的join困难
			3、表外键约束失效
			
		2、水平拆分
			1、自增长ID受到影响
			2、跨库查询
	
### 20、大型网站架构——》已整理
####20.1、整体结构
	1、概述
		1、大型网站架构演进过程
			1、大型网站软件特点：
				1、高并发、大流量
				2、高可用
				3、海量数据
				4、用户广泛，网络情况复杂
				5、安全环境恶劣
				6、需求快速变化，发布频繁
			2、大型网站架构演化发展
				1、一个应用服务器
				2、应用服务和数据服务分离
				3、使用缓存改善网站性能
					1、本地缓存
					2、分布式服务器上远程缓存
				4、使用应用服务器集群改善网站的并发处理能力
				5、数据库读写分离
				6、使用反向代理和CDN加速网站响应
				7、使用分布式文件系统和分布式数据库系统
				8、使用NoSql和搜索引擎
				9、业务拆分
				10、分布式服务
		
		2、大型网站架构模式
			1、分层
			2、分割
			3、分布式
				分布式所带来的问题：
				1、分布式意味着服务调用需要通过网络，这可能对性能造成比较重的影响
				2、服务器越多，服务宕机概率就越大
				3、数据在分布式的环境中保持数据一致性也非常困难，分布式事务也难以保证
				4、分布式导致网站错综复杂，开发管理维护困难
			在网站应用中，常用的分布式方案：
				1、分布式应用和服务
				2、分布式静态资源
				3、分布式数据和存储
				4、分布式计算
			4、集群
			5、缓存
				1、cdn
				2、反向代理
				3、本地缓存
				4、远程缓存
			6、异步（消息队列）
			7、冗余
			8、自动化
			9、安全
		
		3、大型网站架构要素
			1、性能
				从用户浏览器到数据库：
				1、在浏览器端：
					可以通过浏览器缓存、使用页面压缩、合理布局页面、减少Cookie传输等手段改善性能
					还有CDN、反向代理，缓存热点文件
				2、应用服务器端：
					本地缓存和分布式缓存
					异步的操作将用户请求发送至消息队列
					部署集群
				3、代码层面：
					使用多线程，改善内存管理等手段优化性能
				4、数据服务器端：
					索引、缓存、SQL优化等性能优化还有NoSqlDB
				衡量网站性能有一系列指标：
				1、响应时间、TPS、系统性能计数器
			
			2、可用性
				网站高可用的主要手段是冗余
			3、伸缩性
				所谓伸缩性是指通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求
				主要标准：是否可以用多台服务器构建集群，是否容易向集群中添加服务器等
				1、应用服务器集群：只要服务器上不保存数据，所有服务器都是对等
				2、缓存服务器集群：可以通过缓存路由算法保证缓存数据的课访问性
				3、关系数据库：通过路由分区等手段
			4、扩展性
				主要标准是在网站增加新业务产品时，是否可以实现对现有产品透明无影响
				网站可扩展架构的主要手段是事件驱动架构和分布式服务
				1、事件驱动：利用消息队列实现
				2、分布式服务
			5、安全性
			
			
	2、网站高性能架构
		1、网站性能测试
			1、性能测试
			2、性能测试指标
				1、响应时间
				2、并发数
				3、吞吐量
					指单位时间内系统处理的请求数量，体现系统的整体处理能力
					TPS（每秒事务量）：是吞吐量的一个常用量化指标
					HPS（每秒HTTP请求数）
					QPS（每秒查询数）
				4、性能计数器
			3、性能测试方法
		2、Web前端优化
			1、浏览器访问优化
				1、减少HTTP请求
					HTTP协议是无状态的应用层协议，意味着每次http请求都需要建立通信链路，进行传输，而在服务器端，每个http都需要启动独立的线程去处理。
				2、使用浏览器缓存
					可以通过http头中cache-control和expires的属性，可以设定浏览器缓存
				3、启用压缩
				4、css放在页面最上面，JavaScript放在页面最下面
				5、减少Cookie传输
			2、cdn加速
				内容分发网络的本质依然是一个缓存，而且将数据缓存在离用户最近的地方，使用户以最快速度获取数据，即所谓的网络访问第一跳
				可以缓存一些静态资源
			3、反向代理
				反向代理服务器具有保护网站安全的作用，同时也可以通过配置缓存功能加速Web请求
				也可以实现负载均衡的功能
		3、应用服务器优化
			（主要优化手段：缓存、集群、异步）
			1、分布式缓存
				网站性能优化第一定律：优先考虑使用缓存性能
				1、缓存的基本原理
					是一个内存Hash表，网站应用中，数据缓存以一对Key，Value的形式存储在内存Hash表中。Hash表数据读写的时间复杂度为O（1）
					
				    网站数据访问通常遵循二八定律
				2、合理使用缓存
					1、频繁修改数据
					2、没有热度访问
					3、数据不一致与脏读
					4、缓存可用性
						缓存会承担大部分数据访问压力，数据库都已经习惯了有缓存的日子，所以当缓存服务崩溃时，数据库会因为完全不能承受巨大的压力而宕机，进而导致整个网站不可用。这情况被称为缓存雪崩
					可以通过分布式缓存集群改善缓存的可用性
					5、缓存预热
						最好在缓存系统启动时把热点数据加载好，这个缓存预加载手段叫做缓存预热
					6、缓存穿透
						持续高并发的请求某个不存在的数据，由于缓存没有保存该数据，所有请求都会落到数据库上，会对数据库造成很大压力，甚至是崩溃。应对方法：可以把不存在的数据也缓存起来
				3、分布式缓存架构
					缓存部署在多个服务器组成的集群中，以集群方式提供缓存服务
					1、JBoss Cache
					2、Memcached
		
			2、异步操作
				1、消息队列具有很好的削峰作用，即通过异步处理，将短时间内高并发产生的事务消息存储在消息队列中，从而削平高峰值得并发事务
					根据业务需要，确定是否在写入消息队列后立即返回
			3、使用集群
			4、代码优化
				1、多线程
					对网站而言，不管有没有进行多线程编程，每一行代码都会被多线程执行，因为用户请求是并发提交的。
					编程上，解决线程安全的主要手段：
						1、将对象设计为无状态对象
						2、使用局部对象
						3、并发访问资源时使用锁
				2、资源复用
					系统运行时，要尽量减少那些开销很大的系统资源的创建和销毁，例如数据库连接，网络通信连接，线程，复杂对象
					资源复用有两种模式：单例和对象池
				3、数据结构
				4、垃圾回收
					理解垃圾回收机制有助于程序优化和参数调整，以及编写安全的代码
					减少Full Gc
			
		4、存储性能优化
		
		
		
	3、网站高可用架构
		1、可用性度量与考核
			几个9衡量
		2、高可用网站架构
			高可用架构的主要手段是数据和服务的冗余备份及失效转移，一旦某些服务器宕机了，就将服务切换到其他可用的服务器上，如果磁盘坏了，则从备份的磁盘读取数据
		3、高可用的应用
			1、通过负载均衡进行无状态服务的失效转移
			2、应用服务器集群Session管理
				在集群环境下，Session管理主要有以下的几种手段
				1、Session 复制
				2、Session绑定（淘汰）
					Session绑定可以利用负载均衡的源地址Hash算法失效，负载均衡服务器总是将来源于同一个IP的请求分发到同一台服务器上
				3、利用Cookie 记录Session
					出现的问题：Cookie大小由限制，每次请求响应都要传输Cookie
				4、Session服务器
					利用独立部署的Session服务器（集群）统一管理Session，应用服务器每次读写Session时，都访问Session服务器
		4、高可用的服务
			高可用服务策略：
				1、分级管理
				2、超时设置
				3、异步调用
				4、服务降级
					1、拒绝服务：拒绝低优先级的应用调用
					2、关闭功能
				5、幂等性设计
					必须在服务层保证服务重复调用和调用一次产生的结果相同，即服务具有幂等性
		5、高可用的数据（数据备份和失效转移机制）
			1、CAP原理
			2、数据备份
				异步热备方式和同步热备方式
			3、失效转移
				若数据服务器集群中任何一台服务器宕机，那么应用程序针对这台服务器的所有读写操作都需要重新路由到其他服务器，保证数据访问不会失败，这个过程叫做失效转移。
				1、失效确认
				2、访问转移
					重新路由到其他的同等的存储服务器上
				3、数据恢复
					系统需要从健康的服务器复制数据，将数据副本数目恢复到设定的值
		6、网站运行监控
			1、监控数据采集
				1、用户行为日志收集
					1、服务器端日志收集
					2、客户端浏览日志收集
				2、服务器性能监控
				3、运行数据报告
			2、监控管理
				1、系统报警
				2、失效转移
				3、自动优雅降级
		
	4、网站伸缩性架构
		所谓网站的伸缩性是指不需要改变网站的软硬件设计，仅仅通过改变部署的服务器数量就可以扩大或缩小网站的服务处理能力
		1、网站架构伸缩性设计
			1、根据功能进行物理分离实现伸缩：不同服务器部署不同的服务
			2、单一功能通过集群实现伸缩：多台服务器部署相同的服务
		2、应用服务器集群伸缩性设计
			1、负载均衡的方式：
				1、HTTP重定向负责均衡
				2、DNS域名解析负载均衡
				3、反向代理负载均衡
				4、IP负载均衡
				5、数据链路层负载均衡
			2、负载均衡算法：
				实现：
					1、根据负载均衡算法和Web服务器列表计算得到集群中一台Web服务器的地址
					2、将请求数据发送到该地址对应的Web服务器上
				算法：
					1、轮询
						所有请求被依次分发到每台应用服务器上，即每台服务器需要处理的请求数目都相同，适合于所有服务器硬件都相同的场景
					2、加权轮询
						高性能的服务器能分配更多的请求
					3、随机
					4、最少连接
					5、源地址散列
						根据请求来源的IP进行Hash计算，得到应用服务器，这样来自同一IP地址的请求总在同一服务器上处理。
		3、分布式缓存集群伸缩性设计
		4、数据存储服务器集群伸缩性设计
		
		
	5、网站可扩展架构
		扩展性：功能迭代，产品扩展
		1、构建可扩展网站架构
			模块分布式部署以后具体聚合方式主要有分布式消息队列和分布式服务
		2、利用分布式消息队列降低系统耦合
		3、利用分布式服务打造可复用业务
			1、解决方案：拆分，将模块独立部署，降低系统耦合性。拆分可以分为纵向拆分和横向拆分
			纵向拆分：将一个大系统拆分为小系统
			横向拆分: 将复用的业务拆分出来，独立部署的分布式服务
			2、分布式服务需求和特点:
				1、负载均衡
				2、失效转移
				3、高效的远程通信
				4、整合异构系统
				5、对应用最少浸入
				6、版本管理
				7、实时监控	
		
		
	6、网站的安全架构
		1、网站应用攻击与防御
			1、XSS攻击
			2、注入攻击
			3、CSRF攻击
		2、信息加密技术
		
		
	7、网购秒杀系统架构设计案例分析
		1、秒杀活动的技术挑战
			1、对现有网站业务造成冲击
			2、高并发下的应用，数据库的负载
			3、突然增加的网络及服务器带宽
			4、直接下单
			
		2、秒杀系统的应对策略
			1、秒杀系统独立部署
			2、秒杀商品页面静态化
			3、租借秒杀活动网络带宽
			4、动态生成随机下单页面的URL
				办法：在下单页面URL加入由服务端生成的随机数作为参数，在秒杀开始的时候才能得到
		3、秒杀系统架构设计
			1、如何控制秒杀商品页面购买按钮的的点亮
			解决办法：使用Javascript脚本控制，在秒杀商品静态页面加入一个JavaScript文件引用，该Javascript文件中加入秒杀是否开始的标志和下单页面URL的随机数参数。
			2、如何只允许第一个提交的订单被发送到订单子系统
				

####20.2、面试题
	

	
	
