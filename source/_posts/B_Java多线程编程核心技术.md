---
title: Java多线程编程核心技术
date: 2019-11-16 10:17:59
tags: 
categories: 
---
#一、*思维导图*
#*总知识点*
###1、Java多线程技能
![Alt text](./1559655153518.png)
####1.1、进程和多线程的概念及线程的优点
	1、进程是受操作系统管理的基本运行单元
	2、线程是进程中独立运行的子任务
####1.2、使用多线程
#####1.2.1、继承Thread类
![Alt text](./1559640657584.png)
#####1.2.2、实现Runnbale接口
![Alt text](./1559640994871.png)
#####1.2.3、实例变量与线程安全
#####1.2.4、留言i--与System.out.println()异常
####1.3、currentThread()方法
	返回代码段正在被哪个线程调用信息
####1.4、isAlive()方法
	判断线程是否处于活动状态
####1.5、sleep()方法
####1.6、getId()方法
####1.7、停止线程
	1、使用退出标志，使线程正常退出，也就是当run方法完成后线程终止
	2、不推荐使用stop，suspend，resume
	3、使用interrupt方法中断线程
#####1.7.1、interrupt停止不了线程
	interrupt停止不了线程，只是在当前线程中打了一个停止标记，并未真正停止线程
#####1.7.2、判断线程是否是停止状态
	1、this.interrupted():测试当前线程是否已经中断
		具有清除状态的功能
	2、this.isInterrupted()：测试线程是否已经中断
		测试线程Thread对象是否已经是中断状态，但不清楚状态标志
#####1.7.3、能停止的线程-异常法
#####1.7.4、在沉睡中停止
#####1.7.5、能停止的线程-暴力停止
	使用stop（）方法停止线程则是非常的暴力
#####1.7.6、使用return停止线程
	将方法interrupt（）与return结合使用也能实现停止线程的效果
####1.8、暂停线程
	暂停线程意味着此线程还可以恢复运行，在Java多线程中，可以使用suspend方法暂停线程，使用resume（）方法恢复线程的执行
	1、使用不当，很容易造成公共的同步对象独占。
	2、导致数据不同步、
####1.9、yield方法
	放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间，但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片
####1.10、线程的优先级
	使用setPriority（）方法，确定在哪一次线程来优先执行
####1.11、守护线程
	1、用户线程
	2、守护线程：垃圾回收线程

###2、对象及变量的并发访问
![Alt text](./1559655096751.png)
####2.1、synchronized同步方法
#####2.1.1、方法内的变量为线程安全
#####2.1.2、实例变量为非线程安全
#####2.1.3、多个对象多个锁
#####2.1.4、synchronized方法与锁对象
![Alt text](./1559655907561.png)
	
	一个对象方法A是同步的，一个对象方法B是异步
#####2.1.5、脏读
![Alt text](./1559656209218.png)

#####2.1.6、synchronized锁重入
	拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求一个对象此对象锁是可以再次得到该对象锁的。
	1、可重入锁也支持父子类继承的环境中
		当存在父子类继承关系时，子类是完全可以通过可重入锁调用父类的同步方法
#####2.1.7、出现异常，锁自动释放
#####2.1.8、同步不具有继承性
	父类的同步方法，而子类继承之后调用，不具有同步性

####2.2、synchronized同步语句块
#####2.2.1、synchronized同步方法的弊端
	执行长时间的任务，等待的时间过长
#####2.2.2、synchronized同步同步代码块的使用
	1、当两个并发线程访问同一对象object中的synchronized(this)同步代码块时，一段时间内只能有一个线程被执行，另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码。
	2、一般是一半异步一半同步
#####2.2.3、synchronized代码块间同步性
	当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对同一个object中所有其他的synchronized(this)同步代码块的访问将被阻塞，这说明synchronized使用的“对象监视器”时一个

#####2.2.4、synchronized（this）代码块是锁定当前对象
	synchronized方法和synchronized（this）代码块也是锁定当前对象的
#####2.2.5、将任意对象作为对象监视器
![Alt text](./1559700740123.png)

	Java还支持对“任意对象”作为对象监视器来实现同步的功能，这个“任意对象”大多数是实例变量及方法的参数，使用格式为synchronized(非this对象)
![Alt text](./1559701411057.png)
	
	对象的监视器不同

#####2.2.6、细化验证3个结论
![Alt text](./1559701938260.png)

#####2.2.7、静态同步synchronized方法与synchronized(class)代码块
	关键字synchronized还可以应用在static静态方法上，如果这样写，那么对当前的*.java文件的Class类进行持锁。


#####2.2.8、数据类型String的常量池特性
	大多数情况下，同步synchronized代码块都不能使用String作为锁对象，而改用其他，比如new Object（）实例化一个Object对象，但它不能放入缓存中

#####2.2.9、多线程的死锁
	因为不同的线程都在等待根本不可能被释放的锁，从而导致所有的任务都无法继续完成。
![Alt text](./1559703387172.png)


####2.3、volatile关键字
	关键字volatile的主要作用是使变量在多个线程间可见
#####2.3.1、关键字volatile与死循环
	强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值
![Alt text](./1559704811381.png)
![Alt text](./1559704885423.png)
![Alt text](./1559704895311.png)
#####2.3.2、volatile非原子的特性
	需要注意的是，如果修改实例变量中的数据，比如i++也就是i=i+1,则这样的操作其实并不是一个原子操作，也就是非线程安全的。
![Alt text](./1559705194772.png)
![Alt text](./1559705450968.png)
![Alt text](./1559705467110.png)
![Alt text](./1559705713090.png)

	问题1：主内存变量发生改变，是由于其他的线程对它的操作还是主内存中自己的变化？
	问题2：如果是其他的线程的变量，已经通过volatile声明变量，为什么不会再从主内存读取？
#####2.3.3、使用原子类进行i++操作
	可以用AtomicInteger原子类进行实现

	学习多线程并发，要着重“外练互斥，内修可见”，这是掌握多线程，学习多线程并发重要技术点

###3、线程间通信
![Alt text](./1559707342949.png)

####3.1、等待/通知机制
#####3.1.1、不使用等待/通知机制实现线程间通信
#####3.1.2、什么是等待/通知机制
		wait使线程停止运行，而notify使停止的线程继续运行
![Alt text](./1559708468379.png)
![Alt text](./1559708585370.png)

#####3.1.3、方法wait()锁释放与notify()锁不释放
	1、执行完同步代码块就会释放锁
	2、在执行同步代码块过程中，遇到异常而导致线程终止，锁也会被释放
	3、在执行同步代码块的过程中，执行了锁所属对象的wait（）方法，这个线程会释放对象锁，而此线程对象会进行线程等待池中，等待被唤醒
#####3.1.4、生产者/消费者模式实现
	可以在一个同步代码块中进行线程的等待，或者是唤醒
	1、一生产与一消费：操作值
	2、多生产与多消费：操作值-假死
		有可能生产者唤醒的生产者
		消费者唤醒的是消费者
	
		这是由于通知过早，释放了锁了而导致
	3、多生产与多消费：操作值（可以唤醒全部）
	4、一生产与一消费：操作栈

#####3.1.5、通过管道进行线程间通信：字节流
	pipeStream是一种特殊的流，用于在不同线程间直接传送数据，一个线程发送数据到输出管道，另一个线程从输入管道中读取数据。通过使用管道，实现不同线程间的通信，而无须借助于类似临时文件之类的东西
![Alt text](./1559715775704.png)

#####3.1.6、通过管道进行线程间通信：字符流


####3.2、方法join的使用
	在很多情况下，主线程创建并启动子线程，如果子线程中要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join（）方法。方法join（）的作用是等待线程对象销毁。
	1、方法join的作用是使所属的线程对象x正常执行run（）方法中的任务，而使当前线程z进行无限期的阻塞，等待线程x销毁后再继续执行线程z后面的代码。
	2、方法join的功能是内部实现了wait方法来实现，具有释放锁的特点

####3.3、类ThreadLocal的使用
	变量值得共享可以使用public static变量的形式，所有的线程都使用同一个public static变量。如果想实现每一个线程都有自己的共享变量，可以通过ThreadLocal。
	类ThreadLocal主要解决就是每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。
	1、提供给每个私有线程存放自己的一份共享变量
#####3.3.1、方法get()与null
	1、类ThreadLocal解决的是变量在不同线程间的隔离性，也就是不同线程拥有自己的值，不同线程中的值是可以放入ThreadLocal类中进行保存

	问题1：每个线程内的变量值发生了改变，最后是以哪个线程为主呢？？

####3.4、类InheritableThreadLocal的使用
	使用类InheritableThreadLocal可以在子线程找那个取得父线程继承下来的值



###4、Lock的使用
![Alt text](./1559718605969.png)
####4.1、使用ReentrantLock类（重入锁）
	调用ReentrantLock对象的lock（）方法获取锁，调用unLock（）方法释放锁。
#####4.1.1、使用Condition实现等待/通知：错误用法与解决
	必须在condition.await()方法调用之前调用lock.lock()代码获得同步监视器
![Alt text](./1559719734370.png)
#####4.1.2、公平锁与非公平锁
![Alt text](./1559719909709.png)
####4.2、使用ReentrantReadWriteLock类(读写锁)
		读写锁表示也有两个锁，
		1、一个是读操作相关的锁，也称为共享锁
		2、一个是写操作相关的锁，也叫做排他锁。

	读写，写读，写写都是互斥，读读是异步的，非互斥
###5、单例模式与多线程
	如何使单例模式遇到多线程使安全的，正确的。
####5.1、立即加载/"饿汉模式"
	立即加载就是使用类的时候已经将对象创建完毕，常见的实现办法就是直接new实例化
####5.2、延迟加载/"懒汉模式"
	解决方案：
	1、声明synchronized关键字
	2、尝试同步代码块
	3、针对某些重要的代码进行单独的同步
	4、使用DCL双检查锁机制
![Alt text](./1559721501154.png)
####5.3、使用静态内置类实现单例模式
![Alt text](./1559721571625.png)
####5.4、使用序列化与反序列化实现单例模式
![Alt text](./1559721770626.png)

####5.5、使用static代码块实现单例模式
![Alt text](./1559721743465.png)

####5.6、使用enum枚举数据类型实现单例模式