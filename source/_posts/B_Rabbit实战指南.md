---
title: Rabbit实战指南
date: 2019-11-16 10:17:59
tags: 
categories: 
---
#一、*思维导图*
#*总知识点*
###1、RabbitMQ简介
####1.1、什么是消息中间件
	是利用高效可靠的消息传递进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。
	两种传递模式：
		1、点对点模式（P2P）
		2、发布/订阅模式（Pub/Sub）
			消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息，在消息一对多广播时使用
![Alt text](./1561706075486.png)


####1.2、消息中间件作用
	1、解耦
	2、冗余（存储）：有些情况下，处理数据的过程会失败，消息中间件可以吧数据进持久化直到它们已经被完全处理。
	3、扩展性：
	4、消峰
	5、可恢复性：当系统一部分组件失效时，不会影响到整个系统。
	6、顺序保证：在大多数使用场景下，数据处理的顺序很重要
	7、缓冲：
	8、异步通信

####1.3、RabbitMQ的起源
	是采用Erlang语言实现AMQP（高级消息队列协议）的消息中间件，用于在分布式系统中存储转发消息
![Alt text](./1561706748858.png)
####1.4、RabbitMQ的安装及简单使用
![Alt text](./1561708341713.png)
![Alt text](./1561708350212.png)
![Alt text](./1561708209232.png)
![Alt text](./1561708363411.png)
![Alt text](./1561708384382.png)
![Alt text](./1561708492520.png)
###2、RabbitMQ入门
####2.1、相关概念介绍
![Alt text](./1561708868651.png)
#####2.1.1、生产者和消费者
	1、Producer：生产者，就是投递消息的一方
	生产者创建消息，然后发布到RabbitMQ中。消息一般可以包括2部分：消息体和标签。消息的标签用来表述这条消息，比如一个交换器的名称和一个路由器。
	2、Consumer：消费者，就是接收消息的一方
	3、Broker：消息中间件的服务节点
![Alt text](./1561709451890.png)
#####2.1.2、队列

RabbitMQ中消息都只能存储在队列中。

![Alt text](./1561709744752.png)
#####2.1.3、交换器、路由键、绑定
![Alt text](./1561709901598.png)

1、交换器
2、RoutingKey：路由键，生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用于来指定这个消息的路由器规则，而这个RoutingKey需要与交换器类型和绑定键联合使用才能最终生效。
3、Binding:绑定，RabbitMQ中通过绑定将交换器与队列关联起来，在绑定的时候一般会制定一个绑定键。

![Alt text](./1561710253685.png)
![Alt text](./1561710583321.png)
#####2.1.4、交换器类型
	1、fanout:
		它会把所有发送到该交换器的消息路由到所有与该交换器绑定队列中
	2、direct：
		它会把消息路由到那些Bindingkey和RoutingKey完全匹配的队列中
![Alt text](./1561711435854.png)

3、topic

![Alt text](./1561711573687.png)
![Alt text](./1561711589066.png)

4、headers
	headers类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容的heads顺序拧进行匹配。

#####2.1.5、RabbitMQ运转流程
	1、生产者发送消息的时候：
![Alt text](./1561857694166.png)

2、消费者接收消息的过程:

![Alt text](./1561857864527.png)
![Alt text](./1561858143323.png)

####2.2、AMQP协议介绍
	AMQP的模型架构和RabbitMQ的模型是一样的，生产者将消息发送给交换器，交换器和队列绑定。当生产者发送消息时所携带的Rountingkey与BindingKey相匹配时，消息即被存入相应的队列之中。

![Alt text](./1561858781268.png)
#####2.2.1、AMQP生产者流转过程
#####2.2.2、AMQP消费者流转过程

####2.3、小结
![Alt text](./1561859151555.png)
###3、客户端开发向导
####3.1、连接RabbitMQ
![Alt text](./1561859778268.png)

####3.2、使用交换器和队列

交换器和队列是AMQP中high-level层面的构建模块，应用程序需确保在使用它们的时候就已经存在，在使用之前需要先声明（declare）它们。

![Alt text](./1561860143806.png)

#####3.2.1、exchangeDeclare方法详解
![Alt text](./1561861096774.png)
#####3.2.2、queueDeclare方法详解
![Alt text](./1561861351638.png)
#####3.2.3、queueBind方法详解
![Alt text](./1561861465348.png)
#####3.2.4、exchangeBind方法详解
	将交换器与队列绑定，也可以将交换器与交换器绑定。
#####3.2.5、何时创建

####3.3、发送消息
![Alt text](./1561862146130.png)
####3.4、消费消息
	RabbitMQ的消息模式分两种，推（Push）模式和拉（Pull）模式。推模式采用Basic.Consume进行消费，而拉模式则是调用Basic.Get进行消费
#####3.4.1、推模式
![Alt text](./1561862370814.png)
![Alt text](./1561862465778.png)
![Alt text](./1561862482011.png)
#####3.4.2、拉模式
![Alt text](./1561862725042.png)
####3.5、消费端的确认与拒绝
![Alt text](./1561863024972.png)

消费者可以拒绝：
1、Basic.Reject 命令一次只能拒绝一条信息，如果要拒绝使用Basic.Nack

####3.6、关闭连接

###4、RabbitMQ进阶
####4.1、消息何去何从
![Alt text](./1561864007980.png)

#####4.1.1、 mandatory参数
![Alt text](./1561864215413.png)

#####4.1.2 、immediate参数
![Alt text](./1561864397731.png)

#####4.1.3 、备份交换器
![Alt text](./1561864704885.png)
![Alt text](./1561864982899.png)


####4.2、过期时间（TTL）
#####4.2.1、设置消息的TTL
	1、通过队列属性设置，队列中所有消息都有相同的过期时间，、
	2、对消息本身进行单独的设置。（每条消息是否过期是在即将到消息消费者之前判定的）
#####4.2.2、设置队列的TTL
![Alt text](./1561865515294.png)

####4.3、死信队列
![Alt text](./1561865666206.png)
	

可以用于分析异常的原因


####4.4、延迟队列
	延迟队列存储的对象是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定的时间后，消费者才能拿到这个消息进行消费。
![Alt text](./1561865949419.png)

可以通过DLX和TTL模拟出延迟队列的功能

![Alt text](./1561866066388.png)
####4.5、优先级队列
	设置优先级
####4.6、RPC实现（理解）
	客户端发送请求消息，服务端回复响应的消息。为了接收响应的消息，我们需要在请求消息中发送一个回调队列，可以使用默认队列。
![Alt text](./1561867029282.png)
![Alt text](./1561867045433.png)
####4.7、持久化
	1、交换器的持久化
	2、队列的持久化
	3、消息的持久化
![Alt text](./1561868002999.png)
![Alt text](./1561868121264.png)
![Alt text](./1561868143451.png)
####4.8、生产者确认
![Alt text](./1561868303198.png)
#####4.8.1、事务机制
![Alt text](./1561868428219.png)
![Alt text](./1561868438752.png)
![Alt text](./1561868476718.png)
![Alt text](./1561868494440.png)
#####4.8.2、发送方确认机制
![Alt text](./1561868658650.png)
![Alt text](./1561868750626.png)

建议使用异步的confirm的方式。

####4.9、消费端要点介绍
![Alt text](./1561874053651.png)

1、消息分发
2、消息顺序性
3、弃用QueueingConsumer

#####4.9.1、消息分发
![Alt text](./1561874468593.png)

#####4.9.2、消息顺序性
![Alt text](./1561874783999.png)
	

解决方法：在业务方法使用RabbitMQ之后做一步的处理，比如在消息体内添加全局有序标识（类似SequenceID）来实现


#####4.9.3、弃用QueueingConsumer
![Alt text](./1561874980864.png)


####4.10、消息传输保障
![Alt text](./1561875168600.png)
![Alt text](./1561875268100.png)
####4.11、小结
![Alt text](./1561875995799.png)



###5、RabbitMQ管理
####5.1、多租户与权限
####5.2、用户管理
####5.3、Web端管理
####5.4、应用与集群管理
####5.5、服务端状态
####5.6、HTTP API接口管理
![Alt text](./1561877490824.png)


###6、RabbitMQ配置
![Alt text](./1561878289989.png)


####6.1、环境变量
####6.2、配置文件
####6.3、参数及策略


###7、RabbitMQ运维
####7.1、集群搭建