
##V_Mysql高级特性

###1、mysql的架构介绍
####1.1、Mysql简介
	1、概述
	2、高级mysql
		1、mysql内核
		2、sql优化工程师
		3、mysql服务器的优化
		4、各种参数常量设定
		5、查询语句优化
		6、主从复制 
		7、软硬件升级
		8、容灾备份
		9、sql编程
####1.2、mysqlLinux版安装
####1.3、mysql配置文件
	1、二进制日志log-bin
		主从复制
	2、错误日志log-error
		默认是关闭的，记录严重的警告和错误信息，每次启动和关闭的详细信息等
	3、查询日志log
		默认关闭，记录查询的sql语句，如果开启会降低mysql的整体性能，因为记录日志也是需要消耗系统资源
	4、数据文件
		1、两系统
		2、frm文件
			存放表结构
		3、myd文件
			存放表数据
		4、myi文件
			存放表索引
	5、如何配置
####1.4、mysql逻辑架构介绍
	1、总体概览
![Alt text](./1570155194206.png)
![Alt text](./1570155338964.png)

	2、查询说明
####1.5、mysql存储引擎
	1、查看命令
	2、MyISAM和InnoDB
![Alt text](./1570155512079.png)
	
###2、索引优化分析
####2.1、性能下降sql慢
	1、查询语句写的烂
	2、索引失效
		1、单值
		2、复合
	3、关联查询太多的join（设计的缺陷和不得与的需求）
	4、服务器调优及各个参数设置（缓冲、线程数）
#####2.1.1、执行时间长
#####2.1.2、等待时间长

####2.2、常见通用的join查询
	1、sql执行顺序
		1、手写
![Alt text](./1570155975046.png)

		2、机读
![Alt text](./1570156019194.png)

		3、总结
![Alt text](./1570156049513.png)

	2、Join图
![Alt text](./1570156137762.png)
![Alt text](./1570156179529.png)

	3、建表sql
	4、7种join
####2.3、索引简介
	1、是什么
		1、官方定义：索引Index是帮助mysql高效获取数据的数据结构。可以得到索引的本质：索引是数据结构
		2、可以简单理解为排好序的快速查找数据结构
			1、详解：
![Alt text](./1570156878220.png)
						
			2、结论：数据本身之外，数据还维护着一个满足特定查找算法的数据结构，这些数据结构以某种式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。
						
		3、一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上，我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉树）结构组织的索引

	2、优势
		1、提高数据检索的效率
		2、降低数据库的IO成本
		3、降低数据排序的成本
		4、降低了CPU的消耗
	3、劣势
		1、实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的
		2、虽然索引大大提高了查询速度，同时降低更新表速度，如对表进行的insert、update、delete
	4、mysql索引分类
		1、单值索引：一个索引只包含单个列，一个表可以有多个单列索引
		2、唯一索引：索引列的值必须唯一，单允许有空值
		3、复合索引
		4、基本语法
			1、创建
			2、删除
			3、查看
			4、使用Alter命令
	5、mysql索引结构
		1、BTree索引
			1、检索原理
![Alt text](./1570159718138.png)
![Alt text](./1570159788566.png)

		2、Hash索引
		3、full-text全文索引
		4、R-Tree索引
	6、哪些情况需要创建索引
		1、主键自动建立唯一索引
		2、频繁作为查询条件的字段应该创建索引
		3、查询中与其他表关联的字段，外键关系建立索引
		4、频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录还会更新索引
		5、where条件里用不到的字段不创建索引
		6、单值、组合索引的选择问题，who（在高并发下倾向创建组合索引）
		7、查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
		8、查询中统计或者分组字段
	7、哪些情况不要创建索引
		1、表记录太少
		2、经常增删改的表
		3、数据重复而且分布平均的表字段
####2.4、性能分析
	1、mysql query optimizer
![Alt text](./1570161207749.png)

	2、mysql常见瓶颈
		1、CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候
		2、IO：磁盘IO瓶颈发生在装入数据远大于内存容量时候，服务器硬件的性能瓶颈，top，free，iostat和vmstat来查看系统的性能状态
	3、Explain
![Alt text](./1570251341568.png)

		1、是什么
			使用Explain关键字可以模拟又花钱执行的SQL查询语句，从而知道MySQL是如何处理你的SQL语句，分析你的查询语句或是表结构的性能瓶颈
		2、能干嘛
			1、表的读取顺序
			2、数据读取操作的操作类型
			3、哪些索引可以使用
			4、哪些索引被实际使用
			5、表之间的引用
			6、每张表有哪些行被优化器查询
		3、怎么玩
		4、各字段解释
			1、id
				select查询的序列号，包含一组数字，表示查询中执行select子句或操作表顺序
				三种情况：
					1、id相同，执行顺序由上至下
					2、id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
					3、id相同不同，同时存在
			2、select_type
				1、simple
				2、primary
				3、subquery
				4、derived
				5、union
				6、union result
				查询的类型，主要是用于区别。普通查询，联合查询，子查询等复杂查询
![Alt text](./1570252071575.png)

			3、table
			4、type
				1、all
				2、index
				3、range
				4、ref
				5、eq_ref
				6、const，system
				7、null
				访问类型排列：从最好到最差依次：system>const>eq_ref>ref>range>index>all
![Alt text](./1570253005780.png)
		
			5、possible_keys
				显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用
			6、key
				实际使用的索引，如果为null，则没有使用索引
				查询中若使用了覆盖索引，则该索引仅出现在key列表中
			7、key_len
				表示索引中使用的字节数，可通过该列计算查询中使用索引长度。在不损失精度情况下，长度越短越好。
				显示的值为索引字段的最大可能长度，并非实际使用长度。即是根据定义计算而得，而不是通过表内检索的
			8、ref
				显示索引的哪一列被使用，如果可能的话，是一个常数。哪些列或者常量被用于查询索引列上的值
			9、rows
				根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取行数
			10、Extra
![Alt text](./1570257639411.png)

		5、热身case
![Alt text](./1570257720139.png)

####2.5、索引优化
	1、索引分析
		1、单表
		2、两表
		3、三表
	2、索引失效（应该避免）：带头大哥不能死，中间兄弟不能断+例子
		1、全值匹配我最爱
		2、最佳左前缀法则
		3、不在索引列上做任何操作（计算、函数（自动or手动）类型转换），会导致索引失效而转向全表
		4、存储引擎不能使用索引中范围条件右边的列
		5、尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *
		6、mysql在使用不等于（！=或者<>）的时候无法索引会导致全表扫描
		7、is null ，is not null 也无法使用索引
		8、like以通配符开头（‘%abc’）mysql索引失效会变成全表扫描的操作
		9、字符串不加单引号索引失效
		10、少用or。用它来连接时会索引失效
		
![Alt text](./1570259486936.png)
![Alt text](./1570259582190.png)
![Alt text](./1570260215207.png)

	3、一般性建议
		1、对于单键索引，尽量选择针对对当前query过滤性更好索引
		2、在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好
		3、在选择组合索引的时候，尽量选择可以能够包含当前query中的where子句中更多字段的索引
		4、尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的
###3、查询截取分析
####3.1、查询优化
	1、永远小表驱动大表（类似于嵌套循环nested Loop）
	2、order by 关键字优化
		1、order by 子句，尽量使用Index方式排序，避免使用FileSort方式
		2、尽可能在索引列上完成排序操作，遵循索引建的最佳左前缀
		3、如果不在索引列上，filesort有两种算法：mysql就要启动双路排序和单路排序
![Alt text](./1570263662716.png)
![Alt text](./1570263710292.png)

	3、group by 关键字优化
		1、是先排序后进行分组，遵循索引建的最佳坐前缀
		2、当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置
		3、where 高于having，能写在where限定的条件就不要去having限定
####3.2、慢查询日志
	1、是什么
![Alt text](./1570264142712.png)

	2、怎么玩
	3、日志分析工具mysqldumpslow
####3.3、批量数据脚本
	1、建表
	2、设置参数log_bin_trust_function_creators
	3、创建函数，保证每条数据都不同
	4、创建存储
	5、调用存储过程
####3.4、slow profile
	1、是什么：是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于sql的调优的测量。默认情况下，参数处于关闭状态，并保存最近15次的运行结果
	2、查看官网
	3、步骤
![Alt text](./1570264874134.png)
![Alt text](./1570264983756.png)
		
	4、结论
![Alt text](./1570265039143.png)

####3.5、全局查询日志
	1、配置启用
	2、编码启用
	3、永远不要在生产环境开启这个功能
###4、mysql锁机制
####4.1、概述
	1、定义
![Alt text](./1570265376146.png)

	2、锁的分类
		1、从对数据操作的类型（读、写）分
![Alt text](./1570265646865.png)
			
		2、从对数据操作的粒度分
####4.2、锁的分类
#####4.2.1、表锁（偏读）
	1、特点
	2、案例分析
	3、案例总结
![Alt text](./1570265761662.png)

	4、表锁分析
![Alt text](./1570265815716.png)

#####4.2.2、行锁（偏写）
![Alt text](./1570265876549.png)
![Alt text](./1570266177646.png)
![Alt text](./1570266329756.png)

	优化建议：
	1、尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
	2、合理设计索引，尽量缩小锁的范围
	3、尽可能较少检索条件，避免间隙锁
	4、尽量控制事务大小，减少锁定资源和时间长度
		5、尽可能低级别事务隔离
###5、主从复制
	1、复制的基本原理
![Alt text](./1570266687996.png)

	2、复制的基本原则
		1、每个slave只有一个master
		2、每个slave只能有一个唯一的服务器ID
		3、每个master可以有多个salve
	3、复制的最大问题
		1、延时
	4、一主一从常见配置