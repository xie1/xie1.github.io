---
title: 大话数据结构
date: 2019-11-16 10:17:59
tags: 
categories: 
---
#一、*思维导图*
#*总知识点*
###1、数据结构绪论
####1.4、基本概念和术语
#####1.4.1、数据
	数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合
		1、可以输入计算机中
		2、能被计算机程序处理
#####1.4.2、数据元素
	数据元素是组成数据的，有一定意义的基本单位，在计算机中通常作为整体处理。也称为记录
#####1.4.3、数据项
	数据项表示一个数据元素可以由若干个数据项组成
	数据项是数据不可分割的最小单位
#####1.4.4、数据对象
	是性质相同的数据元素的集合，是数据的子集。
#####1.4.5、数据结构
	是相互之间存在一种或多种特定关系的数据元素的集合
![Alt text](./1558964593567.png)

####1.5、逻辑结构与物理结构
#####1.5.1、逻辑结构
	是指数据对象中数据元素之间的相互关系
	1、集合结构
	  集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。
	2、线性结构
		线性结构中的数据元素之间是一对一的关系
	3、树形结构
		树形结构中的数据元素之间存在一种一对多的层次关系
	4、图形结构
		图形结构的数据元素是多对多的关系
#####1.5.2、物理结构
	是指数据的逻辑结构在计算机中的存储形式
	1、顺序存储结构
		是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的
	2、链式存储结构
		是把数据元素放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。
![Alt text](./1558964610127.png)

####1.6、抽象数据类型
#####1.6.1、数据类型
	是指一组性质相同的值的集合及定义在此集合上的一些操作总称
#####1.6.2、抽象数据类型
	ADT 是指一个数学模型及定义在该模型上的一组操作



###2、算法
####2.4、算法定义
	是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，而且每条指令表示一个或多个操作
####2.5、算法的特性
	1、输入输出
		算法具有零个或者多个输入，至少有一个或多个输出
	2、有穷性
	3、确定性
	4、可行性
####2.6、算法设计的要求
	1、正确性
		算法的正确性是指算法至少应该具有输入，输出和加工处理无歧义性，能正确反映出问题的需求，能够得到问题的正确答案
	2、可读性
		算法设计的另一个目的是为了便于阅读，理解和交流
	3、健壮性
		当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名的结果
	4、时间效率高和存储量低
####2.7、算法效率的度量方法
#####2.7.1、事后统计方法
	这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低
#####2.7.2、事前分析估算方法
	在计算机程序编制前，依据统计方法对算法进行估算
	1、算法采用的策略、方法
	2、编译产生的代码质量
	3、问题的输入规模
	4、机器执行指令的速度
	总的来说，一个程序的运行时间，依赖于算法的好坏和问题的输入规模
	最终，在分析程序的运行时间时，最重要的时把程序看成是独立于程序设计语言的算法或一系列的步骤
####2.8、函数的渐进增长	
	给定两个函数f(n)和g(n),如果存在一个整数N，使得对于所有的n>N,f(n)总比g(n)大，那么我们说f(n)的增长渐近快于g(n)
####2.9、算法时间复杂度
#####2.9.1、算法时间复杂度
	T（n）= O（f(n)）
	它表示随问题规模的n的增大，算法执行时间的增长率和f(n)的增长率相同,称作时间复杂度。
#####2.9.2、推导大O阶方法
	1、用常数1取代运行时间中的所有加法常数
	2、在修改后的运行次数函数中，只保留最高阶项
	3、如果最高阶项存在且不是1吗，则去除与这个项想乘的常数
#####2.9.3、常数阶O(1)
#####2.9.4、线性阶O(n)
#####2.9.5、对数阶O(logn)
![Alt text](./1559034836674.png)
#####2.9.6、平方阶O(n^2)
####2.10、常见的算法时间复杂度
![Alt text](./1559035304963.png)
####2.11、最坏情况与平均情况
	一般没有特殊说明，都是指最坏的时间复杂度
####2.12、算法空间复杂度

###3、线性表
####3.2、线性表的定义
	线性表（List）：零个或者多个数据元素的有限序列
![Alt text](./1559036246846.png)
	

在较复杂的线性表中，一个数据元素可以由若干个数据项组成。

####3.3、线性表的抽象数据类型
![Alt text](./1559036655474.png)
![Alt text](./1559036663713.png)


####3.4、线性表的顺序存储结构
#####3.4.1、顺序存储定义
	线性表的顺序存储结构，是指是用一段地址连续的存储单元依次存储线性表的数据元素。
![Alt text](./1559036885991.png)
#####3.4.2、顺序存储方式
	可以用一维数组来实现顺序存储结构
	描述顺序存储结构需要三个属性：
		1、存储空间的起始位置; 数组data
		2、线性表的最大存储容量; 数组长度MaxSize
		3、线性表的当前长度：length
#####3.4.3、数据长度与线性表长度区别
	1、数组长度是存放线性表的存储空间的长度，是不可变。
	2、线性表的长度是线性表中数据元素的个数，是可变的。
#####3.4.4、地址计算方法
![Alt text](./1559038119837.png)


####3.5、顺序存储结构的插入与删除
#####3.5.1、获取元素操作
#####3.5.2、插入操作
	插入算法的思路：
	1、如果插入位置不合理，抛出异常
	2、如果线性表长度大于等于数组长度，则抛出异常或动态增加容量
	3、从最后一个元素开始向前遍历到第i个位置，分别将他们都向后移动一位置
	4、将要插入元素的填入i处
	5、表长加1
#####3.5.3、删除操作
#####3.5.4、线性表顺序存储结构的优缺点
![Alt text](./1559117042349.png)

####3.6、线性表的链式存储结构
#####3.6.2、线性表的链式存储结构定义
![Alt text](./1559117721373.png)
![Alt text](./1559118086026.png)

#####3.6.3、线性表的链式存储结构代码描述
![Alt text](./1559118601583.png)

结点是有存放在数据元素的数据域和存放后继结点地址的指针域组成
p是指向线性表的第i个元素的指针，
该结点的ai的数据域，可以p->data
该结点ai的指针域，p->next ,p->next的值是一个指针
即 p->data = ai
  p->next->data = ai+1

####3.7、单链表的读取
	找到第一个元素，之后遍历找到第i元素
####3.8、单链表的插入与删除	
#####3.8.1、单链表的插入
![Alt text](./1559181310284.png)
![Alt text](./1559181331297.png)

操作：
	s->next = p->next ,p->next = s;
让p的后继结点改成s的后继结点，再把s结点变成p的后继结点

单链表第i个数据插入结点的算法思路：
1、声明一个指针p插入链表头结点，初始化j从1开始
2、当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1
3、若到链表末尾p为空，则说明第i个结点不存在
4、否则查找成功，在系统上生成一个空结点s
5、将数据元素e复制给s->data;
6、单链表的插入标准语句s->next = p->next; p->next = s
7、返回成功

#####3.8.2、单链表的删除
![Alt text](./1559182287735.png)

解析： q = p->next ; p->next = q->next
就是把p的后继结点改成p的后继的后继结点
单链表第i个数据删除结点的算法思路：
1、声明一个指针p指向链表头指针，初始化j从1开始
2、当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1
3、若到链表末尾p为空，则说明第i个结点不存在
4、否则查找成功，将欲删除的结点p->next 赋值给q
5、单链表的删除标准语句p->next = q ->next
6、将q结点中的数据赋值给e，作为返回
7、释放q结点
8、返回成功

####3.9、单链表的整表创建
	1、头插法
	2、尾插法
####3.10、单链表的整表删除
	算法思路：
		1、声明一结点p和q
		2、将第一个结点赋值给p
		3、循环
			1、将下一个结点赋值给q
			2、将第一个结点赋值p
			3、循环
				1、将下一个结点赋值给q
				2、释放p
				3、将q赋值给p

####3.11、单链表的结构与顺序存储结构优缺点
![Alt text](./1559184542252.png)


####3.12、静态链表
	用数组描述的链表叫做静态链表
	让数组元素都是由两个数据域组成，data和cur，数组的每一个下标都对应一个 data和一个cur。数据域data，用来存放数据元素，cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，我们把cur叫做游标
![Alt text](./1559185105891.png)
![Alt text](./1559185124459.png)
	

庚是最后一个有值元素，所以它的cur设置为0。而最后一个元素的cur则因“甲”是第一个有值元素而存在它的下标为1.而第一个元素则因空闲空间的一个元素下标为7，所以它的cur存有7

#####3.12.1、静态链表的插入操作-->暂定学习
#####3.12.2、静态链表的删除操作
#####3.12.3、静态链表的优缺点
![Alt text](./1559186633643.png)

####3.13、循环链表
	将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，称为循环链表
	判断p->next 是否为空，现在则是p->next 不等于头结点，则循环未结束
####3.14、双向链表
	是在单链表的每个结点中，在设置一个指向其前驱结点的的指针域
![Alt text](./1559188162247.png)
	

插入操作：先搞定s的前驱和后继，在搞定后结点的前驱，最后搞定解决前结点的后继

![Alt text](./1559188405930.png)

删除操作：

####3.15、总结
![Alt text](./1559188531830.png)


###4、栈与队列
####4.2、栈的定义
#####4.2.1、栈的定义
	栈（stack）是限定仅在表尾进行插入和删除操作的线性表
	允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素称为空栈，栈又称为后进先出的线性表，称为LIFO结构
#####4.2.2、进栈出栈变化形式
####4.3、栈的抽象数据类型
![Alt text](./1559199717464.png)
####4.4、栈的顺序存储结构及实现
#####4.4.2、栈的顺序存储结构——进栈操作
#####4.4.2、栈的顺序存储结构——出栈操作
####4.5、两栈共享空间
####4.6、栈的链式存储结构及实现
#####4.6.1、栈的链式存储结构
![Alt text](./1559200874377.png)

#####4.6.2、栈的链式存储结构-——进栈操作
![Alt text](./1559200889786.png)

#####4.6.3、栈的链式存储结构-——出栈操作
![Alt text](./1559200903201.png)

对比顺序栈与链栈，它们的时间复杂度上都是一样的，均为O（1）

####4.8、栈的应用——递归
#####4.8.1、斐波那契数列实现
	f(n) = f(n-1)+f(n-2) 当n>1
	f(n) = 1， 当n = 1
#####4.8.2、递归定义
	把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称为递归函数
####4.9、栈的应用——四则运算表达式求值
	1、后缀表达式计算结果：
		遇到数字就进栈，遇到是符号，就将处于栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果
	2、将中缀表达式转化为后缀表达式（栈用来进出运算的符号）
	3、将后缀表达式进行运算得出结果（栈用来进出运算的数字）

####4.10、队列的定义
	队列式只允许在一端进行插入操作，而在另一端进行删除操作的线性表
	队列是一种新进先出的线性表，FIFO，允许插入的一端称为队尾，允许删除的一端为队头
####4.11、队列的抽象数据类型
![Alt text](./1559204034152.png)
####4.12、循环队列
	front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，是空队列。
####4.12.2、循环队列的定义
	队列的这种头尾相接的顺序存储结构成为循环队列
####4.13、队列的链式存储结构及实现
	其实就是线性表的单链表，只不过它只能尾进头出而已，简称链队列
![Alt text](./1559206237077.png)
#####4.13.1、队列的链式存储结构——入队操作
	入队操作时，就是在链表尾部插入结点
#####4.13.2、队列的链式存储结构——出队操作
	出队操作，就是头结点的后继结点出队，将头结点后继改为它的后面的结点，若链表除头结点外只剩一个元素时，需要将rear指向头结点
####4.14、总结
![Alt text](./1559207456122.png)


###5、串
####5.2、串的定义
	串时由零个或多个字符组成的有限序列，又名字符串
####5.3、串的比较
![Alt text](./1559208080283.png)

根据编码比较，ASCII比较

####5.4、串的抽象数据类型
![Alt text](./1559208219342.png)

####5.5、串的存储结构
#####5.5.1、串的顺序存储结构
	是用一组地址连续的存储单元来存储串的字符串序列
	不适合字符串的操作
#####5.5.2、串的链式存储结构
####5.6、朴素的模式匹配算法
	字串的定位操作通常称做串的模式匹配，应该是串中最重要的操作之一
	思路：对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配，对主串做大循环，每个字符串开头做T的长度的小循环，直到匹配成功或全部遍历完成为止.
####5.7、KMP模式匹配算法---》重要暂定学习
#####5.7.1、KMP模式匹配算法原理


###6、树
####6.2、树的定义
	处理的是一对多的结构
![Alt text](./1559210303731.png)
#####6.2.1、结点分类
![Alt text](./1559210552299.png)
#####6.2.2、结点间关系
![Alt text](./1559210653875.png)
#####6.2.3、树的其他相关概念
![Alt text](./1559210711311.png)

森林是m（m>=0）棵互不相交的树的集合。

![Alt text](./1559211423646.png)

####6.3、树的抽象数据类型
![Alt text](./1559211465310.png)

####6.4、树的存储结构
#####6.4.1、双亲表示法
	在每个结点中，附设一个指示器指示其双亲结点在数组中的位置
![Alt text](./1559266338986.png)

#####6.4.2、孩子表示法
	每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法
	方案一
		一种是指针域的个数等于树的度，树的度是树各个结点度的最大值
![Alt text](./1559267194234.png)
![Alt text](./1559267215245.png)

方案二
	每个结点指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数

![Alt text](./1559267351481.png)
![Alt text](./1559267366343.png)

把每个结点的孩子排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子节点则此单链表为空，然后n个头指针又组成一个线性表，采用顺序存储结构，存放在一个一维数组中

![Alt text](./1559268083111.png)

该结构优势：适合查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可，对于遍历整棵树也是很方便，对头结点的数组循环即可。

#####6.4.3、孩子兄弟表示法
	

任意一棵树，它的结点的第一孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟

![Alt text](./1559268985559.png)
![Alt text](./1559268996508.png)
![Alt text](./1559269075295.png)


####6.5、二叉树的定义
	

二叉树是n（n>=0）个结点的有限集合，该集合或者为空集（空二叉树）或者是一个根结点和两棵互不相交的，分别称为根结点的左子树和右子树

#####6.5.1、二叉树的特点
	1、每个结点最多有两棵子树
	2、左子树和右子树是有顺序的
	3、即使树中某结点只有一棵子树

二叉树具有的五种基本形态
1、空二叉树
2、只有一个根结点
3、根结点只有左子树
4、根结点只有右子树
5、根结点既有左子树又有右子树

#####6.5.2、特殊二叉树
	1、斜树
	2、满二叉树
		在一棵二叉树中，如果所有的分支结点都存在左子树和右子树，而且所有的叶子都在同一层上，这样的二叉树称为满二叉树
![Alt text](./1559270787722.png)
	

3、完全二叉树
	对一棵具有n个结点的二叉树按层序编号，如果编号为i（1<=i<=n）的结点与同样深度的二叉树中编写为i的结点在二叉树中的位置完全相同，则称为完全二叉树
	即，满二叉树肯定是完全二叉树，但是完全二叉树不是满二叉树	


####6.6、二叉树的性质
#####6.6.1、二叉树性质1
	1、在二叉树上的第i层上至多有2^i-1个结点
#####6.6.2、二叉树性质2	
	2、深度为k的二叉树至多有2^k-1个结点
#####6.6.3、二叉树性质3
	3、对于任何一棵二叉树T，如果其终端结点数为n0,度为2的结点数为n2,则n0=n2+1		
#####6.6.4、二叉树性质4
	4、具有n个结点的完全二叉树的深度是[log2n]+1
#####6.6.5、二叉树性质5
![Alt text](./1559281423821.png)

####6.7、二叉树的存储结构
#####6.7.1、二叉树的顺序存储结构
	顺序存储结构一般只是用于完全二叉树
#####6.7.2、二叉链表
	二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，叫做二叉链表
![Alt text](./1559281921646.png)
![Alt text](./1559281995783.png)

####6.8、遍历二叉树
#####6.8.1、二叉树遍历原理
	是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且被访问一次
#####6.8.2、二叉树遍历方法
	1、前序遍历
		规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，在前序遍历右子树。
![Alt text](./1559282577171.png)

2、中序遍历
	规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树

![Alt text](./1559282724647.png)

3、后序遍历
	规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，然后是访问根结点

![Alt text](./1559282875138.png)

4、层序遍历
	规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上到下遍历，在同一层，按从左到右的顺序对结点逐个访问

![Alt text](./1559283222656.png)

#####6.8.3、前序遍历算法
	通过递归调用
![Alt text](./1559283563055.png)

#####6.8.4、中序遍历算法
#####6.8.5、后序遍历算法、
#####6.8.6、推导遍历结果
	二叉树遍历的性质：
	1、已知前序遍历和中序遍历序列，可以唯一确定一棵二叉树
	2、已知后序遍历和中序遍历序列，可以唯一确定一棵二叉树

####6.9、二叉树建立
	对于没有结点的位置可以从#表示
####6.10、线索二叉树
#####6.10.1、线索二叉树原理
	

指向前驱和后继的指针称为线索，加上线索的二叉树链表称为线索链表，相应的二叉树称为线索二叉树

![Alt text](./1559286031347.png)
#####6.10.2、线索二叉树结构实现——>暂定学习
####6.11、树、森林与二叉树的转换
#####6.11.1、树转换为二叉树
#####6.11.2、森林转换为二叉树
#####6.11.3、二叉树转换为树

####6.12、赫夫曼树及其应用
#####6.12.2、赫夫曼树定义与原理——>暂定学习
![Alt text](./1559292991861.png)
#####6.12.3、赫夫曼编码

###7、图
####7.2、图的定义
![Alt text](./1559293867387.png)
![Alt text](./1559293878177.png)
#####7.2.1、各种图的定义
![Alt text](./1559294047834.png)
![Alt text](./1559294069696.png)
#####7.2.2、图的顶点与边间关系
![Alt text](./1559294980798.png)
![Alt text](./1559295009758.png)


	路径的长度是路径上的边和弧的数目
	简单回路或简单环：除了第一个顶点和最后一个顶点之外，其余顶点不重复出现回路，称为简单回路或简单环

#####7.2.3、连通图相关术语
#####7.2.4、图的定义与术语总结
![Alt text](./1559295775097.png)
####7.3、图的抽象数据类型
![Alt text](./1559295910907.png)
####7.4、图的存储结构
#####7.4.1、邻接矩阵
![Alt text](./1559296237834.png)
![Alt text](./1559296504441.png)
![Alt text](./1559296522322.png)
![Alt text](./1559296533382.png)
#####7.4.2、邻接表
	数组与链表相结合的存储方式称为邻接表
![Alt text](./1559297233698.png)
![Alt text](./1559297248403.png)
#####7.4.3、十字链表
![Alt text](./1559298039688.png)
![Alt text](./1559298053174.png)
#####7.4.4、邻接多重表
#####7.4.5、边集数组
	边集数组是两个一维数组构成。一个是存储顶点信息，另一个是存储边的信息。这个边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）和权（weight）组成
![Alt text](./1559527026143.png)


####7.5、图的遍历
	从图中某一顶点出发访遍图中其余顶点，且使每个顶点仅被访问一次，这个过程叫做图的遍历
#####7.5.1、深度优先遍历
	它从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径想通的顶点都被访问到。
	若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中顶点都被访问到为止
#####7.5.2、广度优先遍历
	类似于树的层序遍历
	
####7.6、最小生成树
	把构造连通网最小代价生成树称为最小生成树
#####7.6.1、普里姆算法
#####7.6.2、克鲁斯卡尔算法



###8、查找
####8.2、查找概论
	查找就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）
	静态查找表：只作为查找操作的查找表
	1、查询某个特定的数据元素是否在查找表中
	2、检索某个特定的数据元素和各种属性

动态查找表：
在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素
	1、查找时插入数据元素
	2、查找时删除数据元素

####8.3、顺序表查找
	又叫线性查找，是最基本的查找技术，它的查找过程是，从表中的第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值的比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录，如果直到最后一个（或第一个）记录，其关键字和给定值比较不等时，则表中没有所查的记录，查找不成功
#####8.3.1、顺序表查找算法
#####8.3.2、顺序表查找优化

####8.4、有序表查找
#####8.4.1、折半查找	
	又称为二分查找，它的前提是线性表中的记录必须是关键码有序，线性表必须采用顺序存储。折半查找的思想，在有序中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功。若给定值小于中间记录的关键字，则在中间记录的左半区继续查找，若给定的值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到成功，或所有查找区域无记录，查找失败

#####8.4.2、插值查找
	是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找放方法，其核心就在于插值得计算公式key-a[low]/a[high]-a[low]

#####8.4.3、斐波那契查找	


####8.5、线性索引查找
#####8.5.1、稠密索引
	稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项。
	对于稠密索引这个索引表来说，索引项一定是按照关键码有序排列
#####8.5.2、分块索引
	是把数据集的记录分成了若干块，而且这些块需要满足两个条件
	1、块内无序
	2、块内有序
#####8.5.3、倒排索引
	索引项的通用结构：
	1、次关键码：例如上面的英文单词
	2、记录号表：例如上面的文章编码
	

其中记录号表存储具有相同的次关键字的所有记录的记录号，（可以是指向记录的指针或者该记录的主关键字）。这样的索引方法就是倒排序索引

####8.6、二叉排序树	
	二叉排序树，又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树
	1、若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
	2、若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
	3、它的左，右子树也分别为二叉排序树
#####8.6.1、二叉排序树查找操作
#####8.6.2、二叉排序树插入操作
#####8.6.2、二叉排序树删除操作

####8.7、平衡二叉树（AVL树）