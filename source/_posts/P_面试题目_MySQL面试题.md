
##P_面试题目_MySQL面试题

##一、数据库系统原理
###1、说一说三个范式？
	第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。
	第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。 
	第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如果存在"A → B → C"的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y

##二、SQL
###1、MySQL中varchar与char的区别以及varchar(50)中的50代表的含义？
	(1)、varchar与char的区别char是一种固定长度的类型，varchar则是一种可变长度的类型
	(2)、varchar(50)中50的涵义最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，
	因为order by col采用fixed_length计算col长度(memory引擎也一样)
	(3)、int（20）中20的涵义是指显示字符的长度但要加参数的，最大为255，比如它是记录行数的id,插入10笔资料，
	它就显示00000000001 ~~~00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，
	它不会在前面加020表示最大显示宽度为20，但仍占4字节存储，存储范围不变；
	
	
	例如：
		int(M) 在 integer 数据类型中，M 表示最大显示宽度。
		在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都是占用 4 btyes 的存储空间。说白了，除了显示给用户的方式有点不同外，int(M) 跟 int 数据类型是相同的。
		如果int的值为10
		int（10）显示结果为0000000010
		int（3）显示结果为010
		就是显示的长度不一样而已 都是占用四个字节的空间

###2、什么是触发器，MySQL中都有哪些触发器？
	触发器是指一段代码，当触发某个事件时，自动执行这些代码。在MySQL数据库中有如下六种触发器：
		1、Before Insert
		2、After Insert
		3、Before Update
		4、After Update
		5、Before Delete
		6、After Delete
		
###3、什么是存储过程？有哪些优缺点？
	1、存储过程是一些预编译的SQL语句。
	2、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。
	存储过程是一个预编译的代码块，执行效率比较一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率
	可以一定程度上确保数据安全


###4、什么是视图？以及视图的使用场景有哪些？
	1、视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。只暴露部分字段给访问者，所以就建一个虚表，就是视图。查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异
	
##三、MySQL
###1、MySQL中myisam与innodb的区别，至少5点？
	(1)、问5点不同
		1>.InnoDB支持事务，而MyISAM不支持事物
		2>.InnoDB支持行级锁，而MyISAM支持表级锁
		3>.InnoDB支持MVCC, 而MyISAM不支持
		4>.InnoDB支持外键，而MyISAM不支持
		5>.InnoDB不支持全文索引，而MyISAM支持。
		
	(2)、innodb引擎的4大特性
		插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)
	(3)、2者selectcount(*)哪个更快，为什么 myisam更快，因为myisam内部维护了一个计数器，可以直接调取。



###2、Mysql数据库有多少种日志
	1、错误日志：记录出错信息，也记录一些警告信息或者正确的信息
	2、慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。
	3、二进制日志：记录对数据库执行更改的所有操作
	4、查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。


###3、事务是如何通过日志来实现的（通过描述更新sql过程来表达）
	隔离性： 通过锁实现(MVVC), 间隙锁+MVVC控制幻读
	原子性、一致性和持久性是通过 redo和undo来完成的。
	
	在Innodb存储引擎中，事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的lsn(log sequence number)号; 当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”，innodb通过此方式来保证事务的完整性。也就意味着磁盘上存储的数据页和内存缓冲池上面的页是不同步的，是先写入redo log，然后写入data file，因此是一种异步的方式。通过 show engine innodb status/G 来观察之间的差距


	类似与一条SQL执行的修改和更行过程：
	1、先查询到张三这一条数据，如果有缓存，也是会用到缓存。
	2、然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。
	3、执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。
	更新完成



###4、列值为NULL时，查询是否会用到索引？
	在MySQL里NULL值的列也是走索引的。当然，如果计划对列进行索引，就要尽量避免把它设置为可空，MySQL难以优化引用了可空列的查询,它会使索引、索引统计和值更加复杂


###5、MyISAM索引实现？
	MyISAM存储引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。MyISAM的索引方式也叫做非聚簇索引的，
	之所以这么称呼是为了与InnoDB的聚簇索引区分。

###6、MyISAM索引与InnoDB索引的区别？
	InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。
	InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。
	InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。
	MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。

###7、讲述下如何做sql优化？
	1、explain 出来的各种 item 的意义
	2、profile 的意义以及使用场景。
	3、explain 中的索引问题。
	
	(1) explain 出来的各种 item 的意义
		id:每个被独立执行的操作的标志，表示对象被操作的顺序。一般来说， id值大，先被执行；
		如果 id 值相同，则顺序从上到下。
		select_type：查询中每个 select 子句的类型。
		table:名字，被操作的对象名称，通常的表名(或者别名)，但是也有其他格式。
		partitions:匹配的分区信息。
		type:join 类型。
		possible_keys：列出可能会用到的索引。
		key:实际用到的索引。
		key_len:用到的索引键的平均长度，单位为字节。
		ref:表示本行被操作的对象的参照对象，可能是一个常量用 const 表示，也可能是其他表的key 指向的对象，比如说驱动表的连接列。
		rows:估计每次需要扫描的行数。
		filtered:rows*filtered/100 表示该步骤最后得到的行数(估计值)。
		extra:重要的补充信息。 
		
	(2) profile 的意义以及使用场景。
		Profile 用来分析 sql 性能的消耗分布情况。当用 explain 无法解决慢 SQL 的时候，需要用
		profile 来对 sql 进行更细致的分析，找出 sql 所花的时间大部分消耗在哪个部分，确认 sql
		的性能瓶颈。 (我用的也不多，期待更好的答案)
	
	(3) explain 中的索引问题。
		Explain 结果中，一般来说，要看到尽量用 index(type 为 const、 ref 等， key 列有值)，避
		免使用全表扫描(type 显式为 ALL)。比如说有 where 条件且选择性不错的列，需要建立索引。
		被驱动表的连接列，也需要建立索引。被驱动表的连接列也可能会跟 where 条件列一起建立
		联合索引。当有排序或者 group by 的需求时，也可以考虑建立索引来达到直接排序和汇总
		的需求


###8、MySQL的复制原理以及流程？
	基本原理流程，3个线程以及之间的关联：
	主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；
	从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；
	从：sql执行线程——执行relay log中的语句


###9、备份计划，mysqldump以及xtranbackup的实现原理？
	(1)、备份计划；这里每个公司都不一样，您别说那种1小时1全备什么的就行
	(2)、备份恢复时间；这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考20G的2分钟（mysqldump）80G的30分钟(mysqldump)111G的30分钟（mysqldump)288G的3小时（xtra)3T的4小时（xtra)逻辑导入时间一般是备份时间的5倍以上
	(3)、xtrabackup实现原理在InnoDB内部会维护一个redo日志文件，我们也可以叫做事务日志文件。事务日志会存储每一个InnoDB表数据的记录修改。当InnoDB启动时，InnoDB会检查数据文件和事务日志，并执行两个步骤：它应用（前滚）已经提交的事务日志到数据文件，并将修改过但没有提交的数据进行回滚操作

###10、innodb的读写参数优化？--》在大表优化方案中有涉及
	(1)、读取参数global buffer pool以及 local buffer；
	(2)、写入参数；innodb_flush_log_at_trx_commitinnodb_buffer_pool_size
	(3)、与IO相关的参数；innodb_write_io_threads = 8innodb_read_io_threads = 8innodb_thread_concurrency = 0
	(4)、缓存参数以及缓存的适用场景。query cache/query_cache_type并不是所有表都适合使用query cache。造成query cache失效的原因主要是相应的table发生了变更
	第一个：读操作多的话看看比例，简单来说，如果是用户清单表，或者说是数据比例比较固定，比如说商品列表，是可以打开的，前提是这些库比较集中，数据库中的实务比较小。
	第二个：我们“行骗”的时候，比如说我们竞标的时候压测，把query cache打开，还是能收到qps激增的效果，当然前提示前端的连接池什么的都配置一样。大部分情况下如果写入的居多，访问量并不多，那么就不要打开，例如社交网站的，10%的人产生内容，其余的90%都在消费，打开还是效果很好的，但是你如果是qq消息，或者聊天，那就很要命。
	第三个：小网站或者没有高并发的无所谓，高并发下，会看到 很多 qcache 锁 等待，所以一般高并发下，不建议打开query cache


###11、问了下MySQL数据库cpu飙升到500%的话他怎么处理？
	1、当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。
	2、如果是 mysqld 造成的， show processlist，看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。
	3、一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等



###12、你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？
	监控的工具有很多，例如zabbix，lepus，我这里用的是lepus

###13、你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？
	主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等
	
###14、你们数据库是否支持emoji表情，如果不支持，如何操作？
	如果是utf8字符集的话，需要升级至utf8_mb4方可支持
	
###15、表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为主，请问是否拆分？
	(1)、您是选择拆成子表，还是继续放一起；
	(2)、写出您这样选择的理由

	拆带来的问题：连接消耗 + 存储拆分空间；不拆可能带来的问题：查询性能；如果能容忍拆分带来的空间问题,拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序IO,减少连接消耗,最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗如果能容忍不拆分带来的查询性能损失的话:上面的方案在某个极致条件下肯定会出现问题,那么不拆就是最好的选择

###16、MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？
	InnoDB是基于索引来完成行锁例: select * from tab_with_index where id = 1 for update;for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列,如果 id 不是索引键那么InnoDB将完成表锁,并发将无从谈起


###17、一个6亿的表a，一个3亿的表b，通过外键tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录
	1、如果A表TID是自增长,并且是连续的,B表的ID为索引select * from a,b where a.tid = b.id and a.tid>500000 limit 200;
	2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。
	select * from b , (select tid from a limit 50000,200) a where b.id = a .tid;

###18、对于大流量的网站,您采用什么样的方法来解决各页面访问量统计问题？
	确认服务器是否能支撑当前访问量。
	优化数据库访问。
	禁止外部访问链接（盗链）, 比如图片盗链。
	控制文件下载。
	使用不同主机分流。
	使用浏览统计软件，了解访问量，有针对性的进行优化

###19、MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？
	1、设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。
	2、选择合适的表字段数据类型和存储引擎，适当的添加索引。
	3、mysql库主从读写分离。
	4、找规律分表，减少单表中的数据量提高查询速度。
	5、添加缓存机制，比如memcached，apc等。
	6、不经常改动的页面，生成静态页面。
	7、书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.
	

###20、如果发现CPU，或者IO压力很大，怎么定位问题？
	 1、首先我会用top命令和iostat命令，定位是什么进程在占用cpu和磁盘io； 
	 2、如果是mysql的问题，我会登录到数据库，通过show full processlist命令，看现在数据库在执行什么sql语句，是否有语句长时间执行使数据库卡住；
	 3、执行show innodb engine status命令，查看数据库是否有锁资源争用；
	 4、查看mysql慢查询日志，看是否有慢sql；
	 5、找到引起数据库占用资源高的语句，进行优化，该建索引的建索引，索引不合适的删索引，或者根据情况kill掉耗费资源的sql语句等

###21、描述MySQL中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响？（重点）
	知识点分析：
	此真题主要考察的是MySQL索引的基础和类型，由此延伸出的知识点还包括如下内容：
		MySQL索引的创建原则
		MySQL索引的注意事项
		MySQL索引的原理
		下面我们就来将这些知识一网打尽

	1、索引的基础:
		索引类似于书籍的目录，要想找到一本数的某个特定主题，需要先查找书的目录，定位对应的页码
		存储引擎使用类似的方式进行数据查询，先去索引当中找到对应的值，然后根据匹配的索引找到对应的数据行。
	
	2、创建索引的语法：
		首先创建一个表：create table t1 (id int primary key,username varchar(20),password varchar(20));
		创建单个索引的语法：CREATE INDEX 索引名 on 表名（字段名）
		索引名一般是：表名_字段名
		给id创建索引：CREATE INDEX t1_id on t1(id);
		创建联合索引的语法：CREATE INDEX 索引名 on 表名（字段名1，字段名2）
		给username和password创建联合索引：CREATE index t1_username_password ON t1(username,password)
		其中index还可以替换成unique，primary key，分别代表唯一索引和主键索引
		删除索引：DROP INDEX t1_username_password ON t1
		
	3、索引对性能的影响：
		1、大大减少服务器需要扫描的数据量。
		2、帮助服务器避免排序和临时表。
		3、将随机I/O变顺序I/O。
		4、大大提高查询速度。
		5、降低写的速度（不良影响）。
		6、磁盘占用（不良影响）。
		
	4、索引的使用场景：
		1、对于非常小的表，大部分情况下全表扫描效率更高。
		2、中到大型表，索引非常有效。
		3、特大型的表，建立和使用索引的代价会随之增大，可以使用分区技术来解决。
	
	5、索引的类型：
		普通索引、唯一索引(主键索引、唯一索引)、联合索引、全文索引、空间索引
		索引很多种类型，是在MySQL的存储引擎实现的。
		普通索引：最基本的索引，没有任何约束限制。
		唯一索引：和普通索引类似，但是具有唯一性约束。
		主键索引：特殊的唯一索引，不允许有空值。
	
	6、索引的区别：
		一个表只能有一个主键索引，但是可以有多个唯一索引。
		主键索引一定是唯一索引，唯一索引不是主键索引。
		主键可以与外键构成参照完整性约束，防止数据不一致。
		联合索引：将多个列组合在一起创建索引，可以覆盖多个列。（也叫复合索引，组合索引）
		外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性、和实现级联操作（基本不用）。
		全文索引：MySQL自带的全文索引只能用于MyISAM，并且只能对英文进行全文检索 （基本不用）
	
	7、MySQL索引的创建原则：
		1、最适合创建索引的列是出现在WHERE或ON子句中的列，或连接子句中的列而不是出现在SELECT关键字后的列。
		2、索引列的基数越大，数据区分度越高，索引的效果越好。
		3、对于字符串进行索引，应该制定一个前缀长度，可以节省大量的索引空间。
		4、根据情况创建联合索引，联合索引可以提高查询效率。
		5、避免创建过多的索引，索引会额外占用磁盘空间，降低写操作效率。
		6、主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用提高查询效率。
	
	8、MySQL索引的注意事项：
		1、联合索引遵循前缀原则
			KEY(a,b,c)  
			WHERE a = 1 AND b = 2 AND c = 3  
			WHERE a = 1 AND b = 2  
			WHERE a = 1  
			#以上SQL语句可以用到索引  
			WHERE b = 2 AND c = 3  
			WHERE a = 1 AND c = 3  
			#以上SQL语句用不到索引  
		2、LIKE查询，%不能在前
			WHERE name LIKE "%wang%"  
			#以上语句用不到索引，可以用外部的ElasticSearch、Lucene等全文搜索引擎替代。  
		3、列值为空（NULL）时是可以使用索引的，但MySQL难以优化引用了可空列的查询,它会使索引、索引统计和值更加复杂。可空列需要更多的储存空间，还需要在MySQL内部进行特殊处理。
		4、如果MySQL估计使用索引比全表扫描更慢，会放弃使用索引，例如：
			表中只有100条数据左右。对于SQL语句WHERE id > 1 AND id < 100，MySQL会优先考虑全表扫描。
		5、如果关键词or前面的条件中的列有索引，后面的没有，所有列的索引都不会被用到。
		6、列类型是字符串，查询时一定要给值加引号，否则索引失效，例如：
			列name varchar(16)，存储了字符串"100"
			WHERE name = 100;
			以上SQL语句能搜到，但无法用到索引。
	
	9、MySQL索引的原理：
		MySQL索引是用一种叫做聚簇索引的数据结构实现的，下面我们就来看一下什么是聚簇索引。
		聚簇索引是一种数据存储方式，它实际上是在同一个结构中保存了B+树索引和数据行，InnoDB表是按照聚簇索引组织的（类似于Oracle的索引组织表）。
		注：
		B+ 树是一种树数据结构，是一个n叉排序树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。
		B+ 树通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。
		InnoDB通过主键聚簇数据，如果没有定义主键，会选择一个唯一的非空索引代替，如果没有这样的索引，会隐式定义个主键作为聚簇索引。
	
	下图形象说明了聚簇索引表(InnoDB)和普通的堆组织表(MyISAM)的区别：
	最常问的MySQL面试题三——每个开发人员都应该知道
	对于普通的堆组织表来说（右图），表数据和索引是分别存储的，主键索引和二级索引存储上没有任何区别。
	而对于聚簇索引表来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据，二级索引的叶结点存储行的主键值。
	
	聚簇索引表最大限度地提高了I/O密集型应用的性能，但它也有以下几个限制：
		1）插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。
		2）更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。
		3）二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。
		二级索引的叶节点存储的是主键值，而不是行指针，这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。



###22、数据库优化的思路？（重点）
	1.SQL语句优化
		1）应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。
		2）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null
		可以在num上设置默认值0，确保表中num列没有null值**，然后这样查询：
		select id from t where num=0
		3）很多时候用 exists 代替 in 是一个好的选择
		4）用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过滤
	2.索引优化
		合理使用：普通索引、唯一索引(主键索引、唯一索引)、联合索引、全文索引、空间索引
	3.数据库结构优化
		1）范式优化：
		比如消除冗余（节省空间。。）
		2）反范式优化：
		比如适当加冗余等（减少join）
		3）拆分表：
		分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。
		4）拆分其实又分垂直拆分和水平拆分：		
	4.服务器硬件优化

###23、简述项目中优化SQL语句执行效率的方法，从哪些方面，SQL语句性能如何分析？（重点）
	考点分析：
	这道题主要考察的是查找分析SQL语句查询速度慢的方法
	
	延伸考点：
	优化查询过程中的数据访问
	优化长难的查询语句
	优化特定类型的查询语句
	如何查找查询速度慢的原因

	记录慢查询日志，分析查询日志，不要直接打开慢查询日志进行分析，这样比较浪费时间和精力，可以使用pt-query-digest工具进行分析
	1、使用show profile
	set profiling=1;开启，服务器上所有执行语句会记录执行时间，存到临时表中  
	show profiles  
	show profile for query 临时表ID  
	
	2、使用show status
	show status会返回一些计数器，show global status会查看所有服务器级别的所有计数
	有时根据这些计数，可以推测出哪些操作代价较高或者消耗时间多
	
	3、show processlist
	观察是否有大量线程处于不正常的状态或特征

	1、使用explain
	2、分析单条SQL语句
	
	3、优化查询过程中的数据访问
		1、访问数据太多导致查询性能下降
		2、确定应用程序是否在检索大量超过需要的数据，可能是太多行或列
		3、确认MySQL服务器是否在分析大量不必要的数据行
		4、避免犯如下SQL语句错误
			查询不需要的数据。解决办法：使用limit解决
			多表关联返回全部列。解决办法：指定列名
			总是返回全部列。解决办法：避免使用SELECT *
			重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存
			是否在扫描额外的记录。解决办法：
			使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：
			使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。
			改变数据库和表的结构，修改数据表范式
			重写SQL语句，让优化器可以以更优的方式执行查询。
		
	4、优化长难的查询语句
		一个复杂查询还是多个简单查询
		MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。
		切分查询
		将一个大的查询分为多个小的相同的查询
		一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。
		分解关联查询，让缓存的效率更高。
		执行单个查询可以减少锁的竞争。
		在应用层做关联更容易对数据库进行拆分。
		查询效率会有大幅提升。
		较少冗余记录的查询。
		优化特定类型的查询语句
		count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)
		MyISAM中，没有任何where条件的count(*)非常快。
		当有where条件时，MyISAM的count统计不一定比其它引擎快。
		可以使用explain查询近似值，用近似值替代count(*)
		增加汇总表
		使用缓存
		优化关联查询
		确定ON或者USING子句中是否有索引。
		确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。
		优化子查询
		用关联查询替代
		优化GROUP BY和DISTINCT
		这两种查询据可以使用索引来优化，是最有效的优化方法
		关联查询中，使用标识列分组的效率更高
		如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。
		WITH ROLLUP超级聚合，可以挪到应用程序处理
		优化LIMIT分页
		LIMIT偏移量大的时候，查询效率较低
		可以记录上次查询的最大ID，下次查询时直接根据该ID来查询
		优化UNION查询
		UNION ALL的效率高于UNION
		优化WHERE子句
	
	解题方法
	对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。
	
	5、SQL语句优化的一些方法:
		1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
		2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：
		
		select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=
		
		3.应尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描。
		4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：
		
		select id from t where num=10 or num=20可以这样查询：select id from t where num=10 union all select id from t where num=20
		
		5.in 和 not in 也要慎用，否则会导致全表扫描，如：
	
		select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 3
		
		6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。
		
		7. 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：
		
		select id from t where num=@num可以改为强制查询使用索引：select id from t with(index(索引名)) where num=@num
		
		8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：
		
		select id from t where num/2=100应改为:select id from t where num=100*2
		
		9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：
		
		select id from t where substring(name,1,3)=’abc’ ，name以abc开头的id应改为:
		
		select id from t where name like ‘abc%’
		
		10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
