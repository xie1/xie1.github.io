---
title: Java_多线程并发
date: 2018-11-19 14:17:59
tags: 多线程并发
categories: Java基础
---

####一、*思维导图*
#####1、[http://naotu.baidu.com/file/2ab52ad502d59fdd09f26e3413f1b9d9](http://naotu.baidu.com/file/2ab52ad502d59fdd09f26e3413f1b9d9)
####二、*总知识点*
## 1、多线程基础

### 1、线程与进程

#### 进程：一个正在执行的程序

#### 线程：进程中负责程序执行的执行单元。一个进程中至少有一个线程

#### 一个进程至少包含一个线程

#### 进程在执行过程中拥有独立内存单元，而多个线程共享内存

### 2、线程的实现

#### 1、继承Thread类重写run方法

#### 2、实现Runnable接口重写run方法

### 3、线程的状态

#### 1、创建（new）

#### 2、就绪（runnable）

#### 3、运行（running）

#### 4、堵塞（blocked）

#### 5、终止（dead）

### 上下文切换

#### 存储和恢复CPU状态过程，它是的线程执行能够从中断恢复执行

### 4、线程中常用方法

#### 1、静态方法

##### currentThread（），获得正在执行的线程

##### sleep（long）线程休眠

##### yield（）让出CPU

#### 2、对象方法

##### start启动线程

##### setPriority(int)

##### setDaemon(boolean)设置守护线程（后台线程）

##### interrupt()中断线程

##### join（）等待该线程结束

### 5、停止线程

#### 使用退出标志

#### 使用stop方法（不推荐）

#### 使用interrupt方法中断线程，但这个不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止

### 6、线程同步

#### 如何同步

##### java5以前，synchronized

###### 在方法上添加synchronized关键字

###### 同步代码块 ，synchronized（对象）

##### java5后

###### Lock

####### lock（）加锁

####### unlock（）解锁

####### tryLock（）尝试获得锁

###### Semaphone

####### acquire（）获取资源

####### release（）尝试获取锁

###### CountDownLatch

## 2、多线程中级

### 1、控制线程

#### join

##### B调用Ajoin，要等A执行完毕B才执行

##### 就是说B的线程会堵塞

##### 可以在构造函数里面传最大堵塞时间

#### 守护进程

##### 任务是给其他线程提供服务

##### 当前台进程死亡，守护进程自动死亡

##### 例如：java垃圾回收线程

##### setDeamo设置

#### 线程睡眠

##### 主动进入堵塞状态，调用sleep方法

##### jdk以后推荐TimeUtil类睡眠

#### 线程让步

##### 执行yield方法，让当前线程设置为就绪状态

##### 当在完成一个方法最重要的功能时候，可以将处理器控制权让出去

##### 不保证让出去后马上得到处理器控制权

#### 改变线程的优先级

##### SetPriority 范围1-10

##### 推荐使用Thread的三个静态常量

### 2、线程通信

#### 协调运行的控制策略

##### synchronized

###### wait

####### 释放当前线程锁定

####### 例如：如果消费完，等待生产者将其

###### notify

####### 唤醒当前等待的线程

##### lock

###### 使用Condition代替同步监视功能

####### lock.newCondition

####### await代替wait

####### signal代替

#### 管道流通信

##### 使用new分别创建管道输入流（Piperead）和输出流（PipeRead）

##### 使用管道输入流或者管道输出流将对象用connect连接起来

##### 将输入输出分别传入两个线程

##### 分别依赖各自的管道输入流，管道输出流进行通信

##### 两个线程分别依赖自己的管道流进行通信

### 3、其他工具

#### ThreadLocal

##### 线程局部变量

##### 当前线程作为key，要存的值为value

##### 从线程的角度看，每个线程完全拥有该变量

##### 实例，HibernateFactory生成session

##### 每个线程独立的改变自己的副本，和其他线程不产生冲突

#### Collection

##### 提供将线程不安全的集合转为线程安全

##### Collection.synchronizedMap(new HashMap)

#### 线程安全的集合类

##### hashtable,vector,stack

##### ConCurrentHashMap

### 4、线程同步

#### 当多个线程访问同一个资源时，加synchronized对资源进行加锁

#### synchronized可以修饰代码块，修饰方法

#### 只对可以改变竞争资源的方法加锁

#### 只有多线程才会出现线程安全

#### 释放锁条件

##### 同步方法，代码块结束

##### 出现未处理的异常

##### 调用wait，将本线程置为就绪状态

##### sleep或者yield,suspend不会释放同步锁

#### 同步锁，显示加锁，释放锁

##### 读写锁（readWriteLock）

##### 可重入锁（ReentrantLock）

###### 对以加锁的继续加锁

###### 每一个lock方法都有一个unlock方法

#### 死锁

##### A调用B方法，B调用A方法

##### A，B要相互等待执行完之后才执行

### 5、线程组

#### 默认情况下父线程创建子线程就是在同一线程下

### 6、线程池

#### 用Executor创建线程池

#### 创建Runnable或Callable实例，作为任务类

#### 向线程池提交线程

##### submit（有返回值）

##### execute无返回值，方便Exception

### 7、Callable和Futuer

#### 带有返回值的“run”方法

#### 使用FutureTask接受Callable

#### 使用get堵塞方法得到返回值


####三、*重点知识点实例*
####四、*参考资料*
####五、*思维扩展*
####六、*存在疑问*