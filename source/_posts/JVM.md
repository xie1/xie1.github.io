

title: JVM整体介绍
abstract: 
url: 
date: 2018-11-18 14:17:59
category:Java基础
tags: JVM

---

#### 一、*思维导图*

![JVM整体图](https://note-img1.oss-cn-shenzhen.aliyuncs.com/img/JVM.xmind.png)

#### 二、*JVM知识点*
JVM的组成：JVM = 类加载器 classloader  + 运行时数据区域 runtime data area + 执行引擎 execution engine（解析class文件）
classloader 把硬盘上的class , 但是它不负责这个类文件能否执行，而这个是执行引擎execution engine 负责的
一、类加载器 classloader
	1、作用：装载.class文件,文件加载到JVM中的运行时数据区域。
	2、classloader 有两种装载class的方式 （时机）：
		隐式：运行过程中，碰到new方式生成对象时，隐式调用classLoader到JVM
		显式：通过class.forname()动态加载
	双亲委派模型（Parent Delegation Model）
		1.当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。
		每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，
		等下次加载的时候就可以直接返回了。
		2.当前 classLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader.
		当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。

二、运行时数据区域 runtime data
	JVM 运行时数据区 (JVM Runtime Area) 其实就是指 JVM 在运行期间，其对JVM内存空间的划分和分配。JVM在运行时将数据划分为了6个区域来存储。
	程序员写的所有程序都被加载到运行时数据区域中，不同类别存放在heap, java stack, native method stack, PC register, method area.

1、PC程序计数器：一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器, NAMELY存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。Java 的多线程机制离不开程序计数器，每个线程都有一个自己的PC，以便完成不同线程上下文环境的切换。

2、java虚拟机栈：与 PC 一样，java 虚拟机栈也是线程私有的。每一个 JVM 线程都有自己的 java 虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

3、本地方法栈：与虚拟机栈的作用相似，虚拟机栈为虚拟机执行执行java方法服务，而本地方法栈则为虚拟机使用到的本地方法服务。

4、Java堆：被所有线程共享的一块存储区域，在虚拟机启动时创建，它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配。

Java堆在JVM启动的时候就被创建，堆中储存了各种对象，这些对象被自动管理内存系统（Automatic Storage Management System，也即是常说的 “Garbage Collector（垃圾回收器）”）所管理。这些对象无需、也无法显示地被销毁。

JVM将Heap分为两块：新生代New Generation和旧生代Old Generation

堆在JVM是所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也是new开销比较大的原因。

鉴于上面的原因，Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间，这块空间又称为TLAB

TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效

5、方法区
方法区和堆区域一样，是各个线程共享的内存区域，它用于存储每一个类的结构信息，例如运行时常量池，成员变量和方法数据，构造函数和普通函数的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。当开发人员在程序中通过Class对象中的getName、isInstance等方法获取信息时，这些数据都来自方法区。

方法区也是全局共享的，在虚拟机启动时候创建。在一定条件下它也会被GC。这块区域对应Permanent Generation 持久代。 XX：PermSize指定大小。

6、运行时常量池
其空间从方法区中分配，存放的为类中固定的常量信息、方法和域的引用信息。


三、执行引擎 execution engine：执行字节码，或者执行本地方法


##### 1、自动内存管理机制
###### 1.1、虚拟机内存区域与内存溢出异常
1.1.1、运行时的数据区域
		 1、程序计数器
		 2、Java虚拟机栈
		 3、本地方法栈
		 4、Java堆 ：存放对象实例（通过-Xmx和-Xms控制）
		 5、方法区：存储已被虚拟机加载的类信息、常量、静态方法
1.1.2、HotSpot虚拟机对象
		1、对象的创建
		2、对象的内存布局
		3、对象的访问定位
1.1.3、实战：OutOfMemoryError异常
		 1、Java堆溢出
		 2、虚拟机栈和本地方法栈溢出
		 3、方法区和运行时常量池溢出
		 4、本机直接内存溢出
1.2、垃圾收集算法与内存分配策略
1.2.1、判断对象是否已经死：
		1、引用计数算法	
		2、根搜索算法
		3、引用：
			 1、强引用
			 2、软引用
			 3、弱引用
			 4、虚引用
1.2.2、垃圾收集算法
		 1、标记-清除算法
		 2、复制算法
		 3、标记-整理算法
		 4、分代收集算法
1.2.3、内存分配与回收策略
1.2.4、虚拟机性能监控与故障处理工具
1.2.4.1、JDK命令
		1、jps:虚拟机进程状况工具
		2、jstat:虚拟机统计信息工具
		3、jinfo:Java配置信息工具
		4、jmap:Java内存映像工具
		5、jhat:虚拟机堆转储快照分析工具
		6、jstack:Java堆栈跟踪工具
1.2.4.2、可视化工具
1.2.5、调优案例分析与实战



##### 2、虚拟机执行子系统
###### 2.1、类文件结构	
2.1.1、Class文件结构

​	1、魔数与Class类文件的版本
​	2、常量池
​	3、访问标志
​	4、类索引、父类索引与接口索引集合
​	5、字段表集合
​	6、方法表集合
​	7、属性表集合

###### 2.2、虚拟机类加载机制
2.2.1、类加载的时机

2.2.2、类加载的过程

​	1、加载，验证，准备，解析，初始化（4个触发点），使用，卸载
​	2、虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制

2.2.3、类加载器

​	 1、类与类加载器
​	 2、双亲委派模型
​	 3、破坏双亲委派模型

###### 2.3、虚拟机字节码执行引擎
2.3.1、运行时栈帧结构

​	 1、局部变量表
​	 2、操作数栈
​	 3、动态连接
​	 4、方法返回址
​	 5、附加信息

2.3.2、方法调用

##### 3、程序编译与代码优化
###### 3.1、早期（编译期）优化
3.1.1、Javac编译器

​	 1、Javac的源码与调试
​		 1、字节码编译过程，javac 通过把java文件编译成Class文件，其中编译过程中存在着语法及结构关系对应
​	 2、解析与填充符号表
​	 3、注解处理器
​	 4、语义分析与字节码生成

3.1.2、Java语法糖的味道

​	1、java语言中泛型、自动装箱及拆箱、遍历循环与变长参数

###### 3.2、晚期（运行期）优化
3.2.1、HotSpot 虚拟机内的即时编译器




##### 4、高效并发
###### 4.1、Java内存模型与线程
4.1.1、Java内存模型

1、主内存与工作内存
2、内存间交互操作
3、对于volatile型变量的特殊规则
4、对于long和double型变量的特殊规则
5、原子性，可见性与有序性
6、先行发生原则

4.1.2、Java与线程

###### 4.2、线程安全与锁优化
4.2.1、线程安全

 1、java语言中的线程安全
 2、线程安全的实现方法

4.2.2、锁优化

1、自旋锁与自适应自旋
2、锁消除
3、锁粗化
4、轻量级锁
5、偏向锁



#### 三、*重点分析JVM知识点*
这块会重点分析以下几个方面的知识：
	JVM的系列文章：
	1、虚拟内存区域（运行时的数据区域）
	2、垃圾收集机制

​	3、Class文件结构
​    4、虚拟机类加载机制
​	5、虚拟机字节码执行（栈帧）

​	6、早期编译及晚期优化

​	7、Java内存模型与线程
​	8、线程安全与锁优化

#### 四、*参考资料*