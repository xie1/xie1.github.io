---
title: 读书笔记
date: 2019-04-05 23:01:41
tags:
categories: 读书笔记
---
#一、*思维导图*
#*总知识点*
##一、一切都是对象
	1、对象在虚拟机JVM的内存分配
		像正常通过new进行创建的对象是直接存储于堆中，而像基本类型创建变量是存储于栈中
	2、Javac（编译）、Java(运行)
##二、操作符
	1、equals 和== 之间的区别，equals比较的是引用之间，==比较的是基本类型
	2、移位操作符运算
##三、控制执行流程
	1、switch中，参数必须是int和char那样整数值
##四、初始化与清理
	1、用构造器确保初始化
	2、方法重载，重载的参数列表主要基本类型的自动转换，无法根据返回值区分重载方法
	3、this关键字
	4、static关键字
	5、构造器初始化
		初始化顺序，静态数据化，数组初始化
	清理：
		1、finalize()
		2、垃圾回收器
##五、访问权限控制
	1、4种访问权限
		public
		protect
		默认
		private
##六、复用类
	1、继承
	2、组合
	3、代理
	向上转型有什么用--》继承
	final关键字：
		用于对象引用，final使引用恒定。一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象,然而，对象本身却是可以修改的。
##七、多态
	1、动态绑定
	2、后期绑定即（运行时绑定）
		1、Super sup = new sub（）
		2、对象既可以作为它自己本身类型使用，也可以作为它的基类型使用，而这种把某个对象的引用视为对基类的引用做法被称为向上转型
			Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定
		3、多态是一项让程序员，将改变的事务与未变的事物分离开来的重要技术
		4、编写构造器时有一条有效的准则
			用尽简单的方法使对象进入正常状态，如果可以的话，避免调用其他的方法
##八、接口
	1、抽象类
		如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的
	2、接口
		1、策略设计模式
		2、适配器模式
		3、工厂方法模式：使用于框架

##九、内部类
	1、内部类还拥有其他外围类的所有元素的访问权
	2、静态内部类
	3、在方法和作用域内的内部类
	4、匿名内部类，并且希望它使用一个在其外部定义的对象，那编译器会要求其参数引用的是final的
	问题：为什么需要内部类
		1、每个内部类都能独立地继承自一个(接口的)实现，所以无论外围类是否已经继承了某个接口的实现，对于内部类都没有影响
##十一、持有对象
	1、泛型和类型安全容器
		Collection
		Map
	2、实现类：
		Arrays
		Collections
	3、迭代器：统一对容器的访问方式
		Stack：后进先出（LIFO）
		Set ： LinkedHashList因为查询速度的原因也是使用了散列，但是看起来它使用链表来维护插入顺序
		Queue ： 队列  LinkedList提供了方法以支持队列的行为

##十二、通过异常处理错误
	1、终止与恢复
	2、异常类型基类：Exception
		Error/Excepiton以及RuntimeExeception

##十三、字符串
	1、重载"+" 与StringBuilder
	2、String 上操作
	3、正则表达式
	4、patten和matcher对象

##十四、类型信息
	运行时识别对象和类的信息
	1、反射机制
	2、Class对象
		类加载器，一旦某个类的Class对象呗载入内存，它是被用来创建这个类的所有对象
		3种生成Class对象的方法
			1、Class.forName()
			2、Class.getClass()
			3、类名.class()


	3、反射：运行时的类信息
	4、动态代理
		代理是基本的设计模式，它是你为了提供额外的或者不需要操作，而插入的用来代替"实际对象"的对象
##十五、泛型
	1、泛型
	2、泛型接口
	3、泛型方法
	4、简化无组的使用
		有了类型推断，再加上Static方法，可以重新编写之前看到元组工具
	5、匿名内部类
		在泛型代码内部，无法获得任何有关泛型参数类型的信息
	6、擦除和边界问题
	7、通配符
		first类型是List<? extend Fruit>,具有任何从Fruit继承的类型的列表
		无界通配符<?> 意味着任何事物
##十六、数组
	1、数组是第一级对象
	2、返回一个数组
	3、数组与泛型
	4、创建测试数据
	5、Arrays使用功能
		1、数组排序，使用内置的排序方法，就可以对任意基本类型数组排序，也可以对任意的对象数组进行排序，只要该对象实现了Compare接口或者相关联的Comparator

##十七、容器深入研究
	1、完整容器分类法
	2、填充容器
	3、Collection的功能方法
	4、可选操作
		任何会引起对底层数据结构的尺寸进行修改的方法都会产生一个Unsupported OperationException异常
	5、List的功能方法
	6、Set和存储顺序
		1、HashSet ：为了快速查找而设计的Set
		2、TreeSet： 保持次序的set，底层为树结构
		3、LinkedHashSet ：具有HashSet的查询速度，内部使用链表维护元素的顺序
	7、队列
		Queue 仅有实现LinkedList 和 PriorityQueue
		优先级队列
		双向队列， LinkedList支持双向队列
	8、理解Map
		1、HashMap
		2、TreeMap
		3、LinkedHashMap：散列化所有元素，但是在遍历键值时，却又以元素插入顺序返回键值对
		4、WeakHashMap : 
		5、ConcurrentHashMap：一种线程安全的map，它不涉及同步加锁
	9、散列和散列码
	10、选择接口不同实现
		Map，List，Set 和Queue
		1、对List的选择：ArrayList
		2、对Set的选择：HashSet
		3、对Map的选择：HashMap，
			HashMap的性能因子
				1、容量：表中桶位数
				2、初始容量：表在创建时所拥有桶位数
				3、尺寸：表中当前存储的项数
				4、负载因子：尺寸/ 容量
				默认负载因子是0.75（只有当表达到四分之三满时，才进行散列），这个因子在时间和容量代价之间平衡
				更高的负载因子可以降低表所需的时间，但是会增加查找代价
	
##十八、Java I/O系统
	1、File类
		File不仅仅只代表存在的文件或目录，有可以用File对象创建新的目录或者尚不存在的整个目录路径
	2、输入和输出
		通过叠加多个对象来提供所期望的功能（装饰器设计模式）
		FilterInputStream/FilterOutputStream,作为装饰器接口
	3、添加属性和有用接口
	4、Reader和Writer
		有时来自“字节”层次结构中的类和“字符”层次结构的类结合使用
		InputStreamReader --》可以把InputStream 转换为Reader
		OutputStreamWriter -->把OutputStream 转换成Rreader
	5、自我独立的类：把OutputStream 转换成Writer
	6、I/O流典型使用方式
		1、缓冲输入文件
		2、从内存中输入
		3、格式化的内存输入
		4、基本文件输出
	7、文件读写的使用工具
	8、标准I/O
	9、进程控制
	10、新I/O
		1、文件I/O和网络I/O
		2、转换数据
		3、视图缓冲器
		4、内存映射文件
	11、压缩
	12、对象序列化
		1、轻量级持久化：Serializeble,Externalizable,transient(瞬时)关键字 
	13、XML
##十九、枚举类型
	1、基本enum特性：将静态导入用于enum
	2、向enum中添加新方法
	3、values()方法
	4、常量相关方法
	5、多路分发
##二十、注解
	1、元注解，Java目前只内置了三种标准注解以及四种元注解

##二十一、并发
	1、并发的多面性
	2、基本的线程机制：Concurrent包中的执行器（Executor）将为你管理Thread对象，从而简化并发编程
		1、休眠
		2、优先级
		3、让步 ，yield（）
			在构造器中启动线程可能会变得有问题，因为另一个任务可能会在构造器结束之前开始执行，这意味着该任务能够访问处于不稳定状态的对象
		4、加入一个线程：join（） 如果某个线程在另一个线程上调用了join(),此线程将被挂起，直到目标线程结束才恢复
		5、线程组
		6、捕获异常
	3、共享受限资源
		1、解决共享资源竞争，synchronize同步锁，如果你正在写一个变量，它可能接下来被另一个线程读取，或者正在读取上一个已经被另一个线程写过的变量，那么你必须同步，而且读写线程，都必须用相同监视器锁同步
		2、使用显示的Lock对象
			Lock对象必须被显示地创建，锁定，释放
		3、原子性与易变性：volatile关键字
		4、原子类：AtomicInteger，AtomicLong，AtomicReference
		5、临时区
		6、在其他对象同步
		7、线程本地存储
			可以为使用相同或的每个不同线程创建不同的存储，创建和管理线程本地存储可以由java.lang.ThreadLocal类实现
	4、终结任务
		1、在阻塞时终结
			线程状态：
				1、新建 2、就绪，3、堵塞，4、死亡
		2、中断：被互斥所阻塞
		3、检查中断
				interruped() 检查中断状态
		4、线程之间协作
			1、wait() 和notityAll（），wait()使你可以等待某个条件发生变化，而改变这个条件超出了当前方法
			2、notif（）与notifyAll（），notifAll（）因某个特定锁而被调用时，只有等待这个锁的任务才会被唤醒
			3、生产者与消费者：使用显示的Lock和Condition对象
			4、生产者——消费者与队列
				BlockingQueue与LinkedBlockingQueue
			5、任务间使用管道进行输入与输出
		5、死锁
			满足以下四个条件，就会发生死锁。
			1、互斥条件
			2、至少有一个任务它必须持有一个资源而且等待获取当前被别的任务持有的资源
			3、资源不能被任务抢占，任务必须把资源当作普通的事件
			4、必须有循环等待	
		6、新类库中构件
			1、countDownLatch：它是被用来同步一个或者多个任务，强制他们等待由其他任务执行的一组操作完成
			2、cyclicBarrier：你希望创建爱你一组任务，他们并行地执行工作，然后在进行下一个步骤之前直至所有任务都完成（看起来有点像join（））
			3、DelayQueue：无界的BlokingQueue，用于防止实现了Delayed接口，其中的对象只能在其到期时才能从队列取走。
			4、priotityBlockingQueue,优先级队列，它具有可阻塞读取操作
			5、Semaphore,计数信号量允许几个任务同时访问这个资源
			6、Exchanger,是两个任务之间交换对象栏杆
		7、性能调优
			1、比较各类互斥技术
			

