---
title: 读书笔记_高性能MySQL
date: 2019-04-05 23:01:41
tags:
categories: 读书笔记
---
#一、*思维导图*
#*总知识点*
####第1章、MySQL架构与历史
#####1.1、MySQL逻辑架构
		1、应用层
		2、服务层：包括查询解析，分析，优化，缓存以及内置函数，这一层实现了存储过程，触发器，视图
		3、存储引擎层：负责MYSQL中数据的存储和提取
######1.1.1、连接管理与安全
		1、对客户端连接服务器的验证，及对权限的验证
######1.1.2、优化与执行
		1、MySQL会解析查询，并创建内部的数据结构（解析树），然后对其进行各种优化，包括重写查询，决定表的读取顺序，以及选择合适的索引等。
#####1.2、并发控制
######1.2.1、读写锁
		1、读锁（共享锁）
		2、写锁（排他锁）
######1.2.2、锁粒度
		1、表锁：服务器会为如ALTER TABLE之类的使用表锁，而忽略存储引擎的锁机制
		2、行级锁：存储引擎层实现行级锁
#####1.3、事务
		1、ACID
######1.3.1、隔离级别
		1、未提交读：脏读（可以读到未提交的数据）
		2、提交读：不可重复读(一个事务开始时，只能看见已经提交的事务所做的修改)
		3、可重复读：是mysql默认的事务隔离级别，即多次读取的数据都是一样的
		4可串行化：可以避免幻读的情况
######1.3.2、死锁
######1.3.3、事务日志
		1、类似的
######1.3.4、MySQL中的事务
		1、自动提交
		2、在事务中混合使用存储引擎
		3、隐式和显示锁定
#####1.4、多版本并发控制
		1、InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现。一个保存行的创建时间，一个保存行的过期时
#####1.5、MySQL的存储引擎
		1、在文件系统中，MySQL将每个数据（也可以称之为schema）保存为数据目录下的一个字目录
		2、InnoDB
		3、MyISAM
######1.5.6、转换表的引擎
#####1.6、MySql时间线


####第2章、MySQL基准测试
#####2.1、为什么需要基准测试
		1、TPS（每秒事务数）
		2、QPS（每秒查询次数）
#####2.2、基准测试的策略
######2.2.1、测试何种指标
		1、吐量
		2、响应时间或延迟
		3、并发性
		4、可扩展性
####第3章、服务器性能剖析
#####3.1、性能优化简介
######3.1.1、通过性能剖析进行优化
		1、测量任务所花费的时间，然后对结果进行统计和排序，将重要的任务排到前面。
		2、基于执行时间分析和基于等待的分析
######3.1.2、理解性能剖析
#####3.2、对应用程序进行性能剖析
		1、外部资源，比如调用了外部的Web服务或者搜索引擎
		2、应用需要处理大量的数据，比如分析一个超大的XML文件
		3、在循环中执行贵的操作，比如滥用正则表达式
		4、使用低效的算法，比如使用暴力搜索算法来查找列表中的项
#####3.3、剖析MySQL查询
######3.3.1、剖析服务器负载
		1、捕获MySQL的查询到日志文件中（慢查询）
		2、分析查询日志
			1、可以考虑在一些典型的时间窗口如业务高峰期的一个小时内记录查询
		3、使用pt-query-digest分析tcpdump的结果
######3.3.2、剖析单条查询
		1、使用show profile
		2、使用show status
######3.3.3、使用性能剖析
#####3.4、诊断间歇性问题

####第4章、Schema与数据类型优化
#####4.1、选择优化数据类型
		1、更小的通常更好
		2、简单就好
		3、尽量避免null
######4.1.1、整数类型
		1、存在两种类型的数字：整数和实数
		2、对于存储和计算来说，int(1)和int（20）是相同的，它不会限制值得合法范围，只是规定了MySql的一些交互工具用来显示字符的个数
######4.1.2、实数类型
		1、Float和Double类型支持使用标准的浮点运算进行近似的计算
		2、Decimal类型用于存储精确的小数，Decimal只是一种存储格式，在计算中Decimal会转换为Double类型
######4.1.3、字符串类型
		1、Varchar
			1、varchar需要使用1和2个额外字节记录字符串的长度
			2、varchar(10)的列需要11字节的存储空间，varchar(1000)的列则需要1002的存储长度信息
		2、Char：会根据需要采用空格进行填充以方便比较
		3、Blob（二进制方式存储）和Text（字符方式存储）类型
		4、使用枚举（ENUM）代替字符串类型
######4.1.4、日期和时间类型
		1、dateTime：8个字节存储
		2、timestamp：4个字节存储（优先使用）
######4.1.5、位数据类型
		1、bit
		2、set
		3、在整数列上进行按位操作
######4.1.6、选择标识符
		1、优先选择整数类型
		2、Enum和Set类型在适合时候选择
		3、字符串类型
######4.1.7、特殊类型数据
#####4.2、MySQL schema设计中的陷阱
		1、太多的列
			服务层和存储层之间的通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。
		2、太多的关联：单个查询最好在12张表内做关联
		3、全能的枚举
		4、变相的枚举
		5、非此发明的null
#####4.3、范式和反范式
		在范式数据库中，每个事实数据会出现并且只出现一次，相反，在反范式化的数据库中，信息是冗余的，可能会存储在多个地方
######4.3.1、范式的优点和缺点
		1、范式化的更新操作通常比反范式化要快
		2、当数据较好地范式化时，就只有很少或没有重复数据，所以只需要修改更少的数据
		3、范式化的表更小，可以放在内存中
		4、检索列表数据时更少的需要distinct或者group by
######4.3.2、反范式的优点和缺点
######4.3.3、混用范式化和反范式化
#####4.4、缓存表和汇总表
######4.4.1、物化视图：实际上是预先计算并且存储在磁盘上的表，可以通过各种各样的策略刷新和更新
######4.4.2、计数器表：
#####4.5、加快Alter Table操作的速度
		mysql执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表
		1、是先在一台不提供服务的机器上执行Alter table操作，然后和提供服务的主库进行切换
		2、影子拷贝
#####4.5.1、只修改.frm文件
#####4.5.2、快速创建MyISAM索引

####第5章、创建高性能的索引
		索引是存储引擎用于快速查到记录的一种数据结构。
#####5.1、索引基础
######5.1.1、索引的类型
		在mysql中，索引的实现是在存储引擎层而不是在服务器层实现的。
		1、B-Tree索引：
			1、全值匹配：和索引中的所有列进行匹配
			2、匹配最左前缀：只使用索引的第一列
			3、匹配列前缀：
			4、匹配范围值
			5、精确匹配某一列并范围匹配另外一列
			6、只访问索引的查询
		限制：
			索引（last_name,frist_name,dob）
			1、如果不是按照索引的最左列开始查找，则无法使用索引。
			2、不能跳过索引的列
			3、如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找
		2、哈希索引：
			基于哈希表实现，只有精确匹配索引所有列的查询才有效。
		限制：
			1、哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行
			2、哈希索引数据并不是按照顺序存储的，所以无法用于排序
			3、哈希索引也不支持部分索引列匹配查找，因为哈希始终是使用索引列的全部内容来计算哈希值
			4、只支持等值比较查询
			5、会存在很多哈希冲突
			
		3、空间数据索引（R-Tree）
		4、全文索引
#####5.2、索引优点
		优点：
			1、索引大大减少了服务器需要扫描的数据量
			2、索引可以帮助服务器避免排序和临时表
			3、索引可以将随机I/O变成顺序I/O
#####5.3、高性能的索引策略
######5.3.1、独立的列：指的是索引列不能是表达式的一部分，也不能是函数的参数
######5.3.2、前缀索引和索引选择性
######5.3.3、多列索引
		1、当出现服务器对多个索引做相交操作时（通常有多个and条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个单独的单列索引
		2、当出现服务器对多个索引做联合操作时（通常有多个or条件），通常需要消耗大量资源
######5.3.4、选择合适的索引列顺序
######5.3.5、聚簇索引
		InnoDB的聚簇索引实际上在同一结构中保存了B-Tree索引和数据行
		1、当表有聚簇索引的时候，它的数据行数据实际存放在索引的叶子页，但是节点页只包含了索引列
		优点：
			1、数据访问更快
			2、使用覆盖索引扫描的查询可以直接使用页节点中主键值
			3、可以把相关数据保存在一起
		在InnoDB表中按主键顺序插入行
######5.3.6、覆盖索引
		mysql只能使用B-Tree索引做覆盖索引
######5.3.7、使用索引扫描来做排序
		1、只有当索引的列顺序和order by 子句的顺序完全一致，并且所有的列的排序方法都一样时，mysql才能使用索引来对结果做排序。
	不能使用索引做排序查询：
		1、查询使用了两种不同的排序方向，但是索引列都是正序排序
		2、order by 子句中引用了一个不在索引中的列
		3、where和order by中的列无法组成索引最左前缀
		4、查询在索引列的第一列上是范围条件
######5.3.8、压缩（前缀压缩）索引
######5.3.9、冗余和重复索引
######5.3.10、未使用的索引
######5.3.11、索引和锁
#####5.4、索引案例学习
#####5.4.1、支持多种过滤条件
		1、哪些列在where子句中出现的最频繁。哪些列有不同的取值
#####5.4.2、避免多个范围条件
#####5.4.3、优化排序
#####5.5、维护索引和表


####第6章、查询性能优化
#####6.1、为什么查询速度会慢
#####6.2、慢查询基础：优化数据访问
		分析
			1、确认应用程序是否存在检索大量超过需要的数据。(访问太多的行，访问太多的列)
			2、确认MySql服务器层是否在分析大量超过需要的数据行
######6.2.1、是否向数据库请求了不需要的数据
		1、查询不需要的记录
		2、多表关联时返回全部列
		3、总是取出全部列
		4、重复查询相同的数据
######6.2.2、MySQL是否在扫描额外的记录
		1、响应时间
		2、扫描的行数
		3、返回的行数
		mysql一般能够使用如下三种方式应用where条件（从好到坏）
			1、在索引中使用where条件过滤不匹配的记录，是在存储引擎层完成
			2、使用索引覆盖扫描（在Extra列using index）来返回记录，不直接从索引中过滤不需要的数据
			3、从数据表中返回数据，然后根据where条件过滤，是在服务器层完成
#####6.3、重构查询的方式
######6.3.1、一个复杂查询还是多个简单查询
######6.3.2、切分查询
######6.3.3、分解关联查询
		优势：
			1、让缓存的效率更高
			2、将查询分解后，执行单个查询可以减少锁的竞争
			3、在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展
			4、查询本身效率也可能有所提升，用in代替关联查询
			5、可以减少冗余记录的查询
#####6.4、查询执行的基础
		当向MySQL发送一个请求的时候：
			（发送一个Web请求是如何）
			1、客户端发送一条查询给服务器
			2、服务器会检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中结果。否则进入下个阶段。
			3、服务器会进行sql解析，预处理，在由优化器生成对应的执行计划
			4、MySQL根据优化器生成的执行计划，调用存储引擎的API执行查询
			5、将结果返回客户端
![Alt text](./QQ截图20181016204937.png)

######6.4.1、MySql客户端/服务器通信协议
			通信协议是“半双工”
		查询状态（show full processlist）
			1、Sleep：线程正在等待客户端发送新的请求
			2、Query：线程正在执行查询或者正在将结果发送给客户端
			3、Locked：在MySQL服务器层，该线程正在等待表锁
			4、Analyzing and statistics ： 线程正在收集存储引擎的统计信息，并生成执行计划
			5、Copying to tmp table[on disk]:线程正在执行查询。并且将其结果集都复制到一个临时表中，这种状态一般要么是在做group by 操作，要么是文件排序操作，或者是union 操作。
			6、sorting result: 线程正在对结果集进行排序
			7、sending data ： 线程可能在多个状态之间传递数据，或者在生成结果集，或者在客户端返回数据、
######6.4.2、查询缓存
######6.4.3、查询优化处理
		1、语法解析器和预处理：
			1、mysql通过关键字将sql语句进行解析，并生成一棵树对应的“解析树”。mysql解析器将使用mysql语法规则验证和解析查询
			2、预处理器：检查解析树是否合法，例如表和数据列是否存在，下一步会验证权限
		2、 查询优化器
			1、通过last_query_cost的值来得知MySQL计算当前查询的成本
			2、导致MySQL优化器选择错误的执行计划：
				1、统计信息不准确
				2、执行计划中的成本估算不等同与实际执行的成本
				优化策略：一种是静态优化，一种是动态优化
			3、MySQL能够处理的优化类型：
				1、重新定义关联表的顺序
				2、将外连接转化成内连接
				3、使用等价变换规则
				4、优化Count（），min（），max（）
				5、预估并转化为常数表达式
				6、覆盖索引扫描
				7、子查询优化
				8、提前终止查询（可以使用limit子句）类似于这种“不同值/不存在”的优化一般可以拥有distinct，not exist(),或者left join类型查询
				9、等值转播
				10、列表in（）的比较
		3、数据和索引的统计信息
		4、mysql如何执行关联查询
			mysql先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为为止
		5、执行计划
		6、关联查询优化器
		7、排序优化
######6.4.4、查询执行引擎
######6.4.5、返回结果给客户端
#####6.5、MySQL查询优化器的局限性
#####6.5.1、关联子查询
		低效：
		1、in（）加上子查询
		2、如何用好关联子查询
#####6.5.2、union的限制
#####6.5.3、索引合并优化
#####6.5.4、等值传递
#####6.5.5、并行执行
#####6.5.6、哈希关联	
#####6.5.7、松散索引扫描 	
#####6.5.8、最大值和最小值优化
#####6.5.9、在同一个表上查询和更新（禁止）	
####6.6、查询优化器的提示（hint）
####6.7、优化特定类型的查询
#####6.7.1、优化Count()查询
		1、Count()的作用
		2、简单的优化
		3、使用近似值
		4、更复杂的优化
#####6.7.2、优化关联查询
		1、确保on或者using子句中的列上有索引，（只需要在关联顺序中的第二表的相应列上创建索引）
		2、确认任何的group by和order by 中的表达式只涉及到一个表中的列
#####6.7.3、优化子查询
#####6.7.4、优化group by 和distinct
		优化group by with rollup
#####6.7.5、优化limit分页
#####6.7.6、优化sql_calc_found_rows
#####6.7.7、优化union查询（如果不是一定要过滤重复的数据，一般都是用union all连接）
#####6.7.8、静态查询分析
#####6.7.9、使用用户自定义变量
		1、优化排名语句
		2、避免重复查询刚刚更新的数据
		3、统计更新和插入数量
		4、确定取值的顺序
		5、编写偷懒的union
####6.8、案例学习


####第7章、MySQL高级特性
#####7.1、分区表 
		分区表示一个独立的逻辑表，但是底层由多个物理子表组成
			分区使用场景：
				1、表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他都是历史数据
				2、分区表的数据更容易维护
				3、分区表的数据可以分布在不同的物理设备
			分区表限制
				1、一个表最多有1024分区
				2、如果分区字段中有主见或者唯一索引的列，那么所有的主键列和唯一索引列都必须包含进来
				3、分区表无法使用外键约束
#####7.1.1、分区表的原理
	1、select 查询
		当查询一个分区表的时候，分区层先打开并锁住所有的底层表，优化器先判断是否可以过滤部分分区，然后在调用对应的存储引擎接口访问各个分区的数据
	2、insert 操作
		 当写入一个分区表的时候，分区层先打开并锁住所有的底层表，然后确定哪个分区接收这条记录，再将记录写入对应的底层表
	3、delete操作
		 当删除一个分区表的记录时候，分区层先打开并锁住所有的底层表，然后确定哪个分区接收这条记录，再将记录对应的底层表进行删除操作
	4、update操作
		当更新一个分区表的记录时候，分区层先打开并锁住所有的底层表，然后确定哪个分区接收这条记录，再将记录对应的底层表进行取出并更新操作，在判断更新后的数据放在哪个分区，后面对底层表进行写入操作，并对原数据所在底层进行删除操作。
#####7.1.2、分区表的类型
#####7.1.3、如何使用分区表
		例如：从一个非常大的表中查询出一段时间的记录（大约有10亿条记录）
			1、不使用索引
			2、为了保证大数据量的可扩展性，一般有下面两个策略：
				1、全量扫描数据，不要任何的索引（可以使用简单的分区方式存放表）
				2、索引数据，并分离热点
#####7.1.4、什么情况下会出现问题
		1、null值会使分区过滤无效
		2、分区列和索引列不匹配
		3、选择分区的成本可能很高
		4、打开并锁住所有底层表的成本可能很高
		5、维护分区的成本可能很高
#####7.1.5、查询优化
#####7.1.6、合并表	

#####7.2、视图
	视图的两种实现
		1、合并算法
		2、临时表算法
######7.2.1、可更新视图
	是指可以通过更新这个视图来更新视图涉及的相关表。只要指定了合适的条件，就可以更新，删除甚至想视图中写入数据。
######7.2.2、视图对性能的影响

#####7.3、外键约束
#####7.4、在MySQL内部存储代码
		MySQL允许通过触发器、存储过程、函数的形式、定时任务存放代码
######7.4.1、存储过程和函数
######7.4.2、触发器 
######7.4.3、事件 
######7.4.4、在存储程序中保留注释
#####7.5、游标
#####7.6、绑定变量
		MySQL在使用绑定变量的时候可以更高效地执行大量重复语句
		1、在服务器中需要解析一次SQL语句
		2、在服务器端某些优化器的工作只需执行一次，因为它会缓存一部分的执行的计划。
		3、以二进制
#####7.6.1、绑定变量的优化
		1、在准备阶段
			服务器解析SQL语句，移除不可能的条件，而且重写子查询
		2、在第一次执行的时候
			如果可能的化，服务器先简化嵌套循环的关联，并将外关联转化成内关联
		3、在每次SQL语句执行时
			过滤分区
			如果可能的话，尽量移除Count（），min（），max（）
			移除常量表达式
			检测常量表
			做必要的等值传播
			分析和优化ref，range和索引优化等访问数据的方法
			优化关联顺序

#####7.6.2、SQL接口的绑定变量
#####7.7、用户自定义函数
#####7.8、插件
#####7.9、字符集和校验
	     字符集是指从二进制编码到某类字符符号的映射。校对是指一组用于某个字符集的排序规则		 
######7.9.1、mysql如何使用字符集
		1、创建对象时默认设置
		2、服务器和客户端通信时设置
#####7.10、全文索引 （待定）	
#####7.11、分布式（XA）事务
		XA事务中需要有一个事务协调器来保证所有的事务参与者都完成了准备工作（第一阶段）。
		如果协调器收到所有的参与者都准备好的消息，就会告诉所有事务都可以提交了。（第二阶段）
			1、mysql可以参与外部的分布式事务
			2、可以通过XA事务来协调存储引擎和二进制日志 
######7.11.1、内部XA事务
######7.11.2、外部XA事务
#####7.12、查询缓存
######7.12.1、Mysql如何判断缓存命中
		缓存存在一个引用表中，通过一个哈希值引用，这个哈希值包含如下因素，即查询本身，当前要查询的数据库，客户端协议的版本等
		1、不被缓存情况：
			1、包含now（），current_date()的查询
			2、包含任何用户自定义函数，存储函数，用户变量，临时表等
		2、打开查询缓存对读和写操作都会带来些额外的消耗
			1、读查询在开始之前必须先检查是否命中缓存
			2、如果这个读者查询可以被缓存，那么当完全执行后，MySQL若发现查询缓存中没有这个查询，将会把结果写入
			3、对写操作也有影响，mysql必须将对应的所有缓存都设置失效
######7.12.2、查询缓存如何使用内存
######7.12.3、什么情况下查询缓存能发挥作用
######7.12.4、如何配置和维护查询缓存
			1、query_cache_type：是否打开查询缓存
			2、query_cache_size:查询缓存在使用的总内存空间，单位是字节
			3、query_cache_min_res_unit:在查询缓存中分配内存块时的最小单位
			4、query_cache_limit：能够缓存的最大查询结果
			5、query_cache_wlock_invalidate:如果某个数据表被其他的连接锁住，是否依然从查询缓存中返回结果
		减少碎片
		提高查询缓存的使用率
![Alt text](./微信图片_20181023203440.jpg)
######7.12.5、InnoDB和查询缓存
		事务是否可以访问查询缓存存取取决于当前事务ID，以及对应的数据表上是否有锁。每个InnoDB表的内存数据字典都保存在一个事务ID号中，如果当前事务ID小于该事务ID，则无法访问查询缓存


####第8章、优化服务器设置
#####8.1、MySQL配置的工作原理
######8.1.1、语法、作用域和动态性
		1、query_cache_size变量是全局的
		2、sort_buffer_size变量默认是全局相同的，但是每个线程里也可以设置
		3、join_buffer_size变量也有全局默认值而且每个线程可以设置，但是若一个查询中关联多张表，可以为每个关联分配一个关联缓冲
######8.1.2、设置变量的副作用
######8.1.3、入门
######8.1.4、通过基准测试迭代优化
#####8.3、创建MySQL配置文件



####第10章、复制
#####10.1、复制概述
	mysql支持两种复制方式：基于行的复制和基于语句的复制。而基于行的复制方式是在5.1版本才加进来的。这两种方式都是通过主库上记录二进制日志，在备库重放日志的方式来说实现异步的数据复制
######10.1.1、复制
		复制比较常见的用途
		1、数据分布
		2、负载均衡
		3、备份
		4、高可用性和故障切换：复制能够帮助应用程序避免MySQL单点失败
		5、Mysql升级测试
######10.1.2、复制如何工作
		1、在主库中把数据更改记录到二进制日志中
		2、备库将主库上的日志复制到自己的中继日志中（IO线程）
		3、备库读取中继日志中的时间，将其重放到备库数据上（sql线程）
#####10.2、配置复制
		1、在每台服务器上创建复制账号
		2、配置主库和备库
		3、通知备库连接到主库并从主库复制数据	
######10.2.1、创建复制账号	
######10.2.2、配置主库和备库
		主库是服务器server1,需要打开二进制日志并指定一个独一无二的服务器ID，在主库的my.cnf文件中增加或修改
######10.2.3、启动配置
######10.2.4、从另一个服务器开始复制
	有几种办法来初始化备库或者从其他服务器克隆数据到备库。
		1、从主库复制数据
		2、从另一台备库克隆数据
		3、以及使用最近的一次备份来启动备库
	需要有三个条件来让主库和备库保持同步：
		1、在某个时间点的主库的数据快照
		2、主库当前的二进制日志文件，和获得数据快照时在该二进制日志文件中偏移量，我们把这个两个值称为日志文件坐标
		3、从快照时间到现在的二进制日志
	一些从别服务器克隆备库方法：
		1、使用冷备份
		2、使用热备份
		3、使用mysqldump
		4、使用快照或备份
		5、使用开源热备份工具
		6、使用另外的备库
######10.2.5、推荐的复制配置	
#####10.3、复制的原理
######10.3.1、基于语句的复制
	能够让主备保持同步。另一个好处是二进制日志里的事件更加紧凑
######10.3.2、基于行的复制	
######10.3.3、基于行或基于语句
		基于语句复制模式的优点
######10.3.4、基于行或基于语句
######10.3.6、复制过滤器
#####10.4、复制拓扑
######10.4.1、一主库多备库
	用途
		1、为不同的角色使用不同的备库（例如添加不同的索引或使用不同的存储引擎）
		2、把一台备库当作待用的主库，除了复制没有其他的数据传输
		3、将一台备库放到远程数据中心，用作灾难恢复
		4、延迟一个或多个备库，以备灾难恢复
		5、使用其中的一个备库，作为备份，培训，开发或者测试使用服务器
######10.4.2、主动-主动模式下的主-主复制
	包含两台服务器，每一个都配置成对方的主库和备库。他们是一对主库
######10.4.3、主动-被动模式下的主-主复制
	它可以让你在不关闭服务器的情况下执行维护，优化表，升级操作系统或其他任务
######10.4.4、拥有备库的主-主结构
######10.4.5、环形复制
######10.4.6、主库、分发主库以及备库
######10.4.7、树或金字塔形
######10.4.8、定制的复制方案
		1、选择性复制：复制少量的数据到备库
		2、分离功能
		3、数据归档
		4、将备库用作全文检索
		5、模拟多主库复制
		6、创建日志服务器

#####10.5、复制和容量规划
######10.5.1、为什么复制无法扩展写操作
#####10.6、复制管理和维护
######10.6.1、监控复制
######10.6.2、测量备库延迟
######10.6.3、确定准备是否一致
######10.6.4、从主库重新同步备库
######10.6.5、改变主库
	计划内提升
		1、停止向老主库写入
		2、让备库追赶上主库（可选）
		3、	将一台备库配置为新的主库
		4、将备库和写操作执行新的主库，然后开启主库的写入

#####10.7、复制的问题和解决方案