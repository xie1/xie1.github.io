---
title: 读书笔记_设计模式之禅
date: 2019-04-05 23:01:41
tags:
categories: 读书笔记
---


#一、*思维导图*
#*总知识点*
####第1章、单一职责原则
#####1.1、我是牛类，我可以担任多职吗
		1、概念：应该有且只有一个原因引起类的变化
####第2章、里氏替换原则（继承关系）
		1、子类必须完全实现父类的方法
		2、子类可以有自己的个性
		3、覆盖或实现父类的方法时输入参数可以被放大
		4、复写或实现父类的方法时输出结果可以被缩小
####第3章、依赖倒置原则（面向接口编程）
#####3.1、依赖倒置原则的定义
		1、含义：
			1、高层模块不应该依赖底层模块，两者都应该依赖其抽象
			2、抽象不应该依赖细节
			3、细节不应该依赖抽象
		2、对应的Java
			1、模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的
			2、接口或抽类不依赖于实现类
			3、实现类依赖接口或抽象类
#####3.3、依赖的三种写法
		1、构造函数传递依赖对象
		2、Setter方法传递依赖对象
		3、接口声明依赖对象 
####第4章、接口隔离原则 
#####4.1、接口隔离原则的定义 
#####4.2、保证接口的纯洁性
		1、接口要尽量小（根据接口隔离原则拆分接口时，首先必须满足单一职责原则）
		2、接口要高内聚
		3、定制服务
		4、接口设计是有限度的
#####4.3、最佳实践
####第5章、迪米特法则（最少知识原则）
		1、只和朋友交流
		2、朋友间也是有距离
		3、是自己的就是自己的
			如果一个方法放在本类中，即不增加类间关系，也对本类不产生负面影响，那就放置在本类中
####第6章、开闭原则
			1、逻辑变化
			2、子模块变化
			3、可见视图变化
#####6.1、为什么要采用开闭原则
		1、开闭原则对测试的影响
		2、开闭原则可以提高代码复用
		3、开闭原则可以提高可维护性
		4、面向对象开发的要求
#####6.2、如何使用开闭原则	 
		1、抽象约束
		       1、通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法
		       2、参数类型，引用对象尽量使用接口或者抽象类，而不是实现类
		       3、抽象层尽量保持稳定，一旦确定即不允许修改
		2、元数据控制模块行为
		3、制定项目章程
		4、封装变化
#####6.3、最佳实践
		SOLID（稳定的）
		1、单一职责原则（S）
		2、开闭原则(O)
		3、里氏替换原则(L)
		4、迪米特法则(L)
		5、接口隔离原则(I)
		6、依赖倒置原则(D)

###第二部分

####第7章、单例模式
#####7.1、我是皇帝我是独苗
#####7.2、单例模式的定义：
	确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例
	
```
	Singleton (实例类)
	private final Singleton singleton = new Singleton()
	private Singleton(){}
	public static Singleton getSingleton()	
```
#####7.3、单例模式的应用：
######7.3.1、单例模式的优点：
		1、由于单例模式在内存中只有一个实例，减少了内存的开支
		2、由于单例模式只生成一个实例，所以减少了系统的性能开销
		3、单例模式可以避免对资源的多重占用
		4、单例模式可以在系统设置全局访问点，优化和共享资源访问
######7.3.2、单例模式的缺点：
		1、一般没有接口，扩展比较困难
		2、单例模式对测试时不利。特别是在并发环境下
		3、单例模式与单一职责原则有冲突
######7.3.3、单例模式的使用场景：
		1、要求生成唯一的序列号环境
		2、在整个项目中需要一个共享访问点或共享数据，例如web页面的计数器
		3、创建一个对象需要消耗的资源过多，如要访问IO和数据库资源
		4、需要定义大量的静态常量和静态方法
######7.3.4、单例模式的注意事项：
#####7.4、单例模式的扩展：

####第8章、工厂方法模式
#####8.1、女娲造人的故事
		1、女娲对应场景类Client
		2、八卦炉对应一个工厂
		3、三种不同肤色的人对应同一接口下的不同实现类
		
#####8.2、工厂方法模式的定义
		定义了一个用于创建对象的的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类
		1、类图
		2、通用代码
#####8.3、工厂方法模式的应用
#####8.3.1、工厂方法模式的优点
		1、良好的封装性，代码结构清晰
		2、工厂方法模式的扩展性非常优秀
		3、屏蔽产品类
		4、工厂方法模式典型的解耦框架
#####8.3.2、工厂方法模式的使用场景
		1、工厂方法模式是new一个对象的替代品
		2、工厂方法可以用在异构项目
		3、可以使用在测试驱动开发的框架
#####8.4、工厂方法模式的扩展
		1、缩小为简单工厂模式（去除抽象工厂类并把工厂方法定义为static）
		2、升级为多个工厂类：创建自己负责的产品对象
		3、代替单例模式
		4、延迟初始化
			通过定义一个Map容器，容纳所有产生的对象。如果在Map中容器中有对象，则直接取出返回
####第9章、抽象工厂模式
#####9.1、失误的女娲
#####9.2、抽象工厂模式的定义
		为创建一组相关或相互依赖的对象提供一个接口，而且无须指定他们的具体类
		1、类图
#####9.3、抽象工厂模式的应用
#####9.3.1、抽象工厂模式的优点
			1、封装性
			2、产品族内的约束为非公开状态
#####9.3.2、抽象工厂模式的缺点
			1、产品族扩展非常困难
#####9.3.3、抽象工厂模式的使用场景
#####9.3.4、抽象工厂模式的注意事项
####第10章、模板方法模式
#####10.1、辉煌工程-制造悍马 
#####10.2、模板方法模式定义
		定义一个操作中算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法结构即重新定义该算法的某些特定步骤。
		1、类图
		2、它的方法：
			1、基本方法：抽象方法，由子类实现的方法，而且在模板方法被调用
			2、模板方法：一般模板方法定义成final
#####10.3、模板方法模式的应用
#####10.3.1、模板方法模式的应用
		1、封装不可变的部分，扩展可变的部分
		2、提取公共部分代码，便于维护
		3、行为由父类控制，子类实现
#####10.3.2、模板方法模式的优点
#####10.3.3、模板方法模式的缺点
####10.4、模板方法模式的扩展

####第11章、建造者模式
#####11.1、变化是永恒的
#####11.2、建造者模式的定义
		将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
		1、类图
		2、建造者模式中，有如下4个角色
			1、Product产品类
			2、Bulider抽象建造者
			3、ConcreteBuilder具体建造者，实现抽象类定义的所有方法，并且返回一个组建好的对象
			4、Director导演类：负责安排已有模块的顺序
#####11.3、建造者模式的应用
#####11.3.1建造者模式的优点
		1、封装性
		2、建造者独立，容易扩展
		3、便于控制细节风险


####第12章、代理模式(重点)
#####12.1、我是游戏至尊
#####12.2、代理模式的定义
		为其他对象提供一种代理以控制对这个对象的访问。
		1、类图
		2、角色定义
			1、Subject抽象主题角色
			2、RealSubject具体的主题角色，业务逻辑的具体执行者
			3、Proxy代理主题角色：它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，而且在真实主题角色处理完毕前后做
#####12.3、代理模式的应用
#####12.4、代理模式的扩展
######12.4.1、普通代理
		该模式下，调用者只知代理而不用知道真实的角色是谁，屏蔽了真实角色的变更对高层模块的影响
######12.4.2、强制代理
		要从真实角色查找到代理角色，不允许直接访问真实角色
######12.4.3、代理是有个性的	
######12.4.4、动态代理
		动态代理是在实现阶段不用关心代理谁，而是在运行阶段才制定代理哪一个对象。

####第13章、原型模式
#####13.1、个性化电子账单	
#####13.2、原型模式的定义
		用原型实例指定创建对象的种类，而且通过拷贝这些原型创建的对象
		覆盖clone（）方法	
#####13.3、原型模式的应用
#####13.3.1、原型模式的优点
	1、性能优良
	2、逃避构造函数的约束
#####13.3.2、原型模式的使用场景
	1、资源优化场景
	2、性能和安全要求的场景
	3、一个对象多个修改者的场景
#####13.4、原型模式的注意事项	
#####13.4.1、构造函数不会被执行
		Object类的clone方法的原理是从内存中（具体低说是堆内存）以二进制流的方式进行拷贝，重新分配一个内存块。那构造函数没有被执行也是非常正常的
#####13.4.2、浅拷贝和深拷贝
	浅拷贝：Object类提供的方法clone只是拷贝本对象，其对象内部的数组，引用对象等都不拷贝，还是指向原生对象的内部元素地址。
#####13.4.3、clone与final两个冤家
	要使用clone方法，类的成员变量上不要增加final关键字	


####第14章、中介者模式
#####14.1、进销存管理是这样子的吗
		多个模块之间的相互耦合
#####14.2、中介者模式的定义
		用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变他们之间的交互
		中介者模式通用类图
			1、Mediator 抽象中介者角色
				抽象中介者角色定义统一的接口，用于各同事角色之间通信
			2、Concrete Mediator具体中介者角色
				具体的实现
			3、College同事角色
#####14.3、中介者模式的应用
######14.3.1、中介者模式的优点
		减少了类之间的依赖关系，减少耦合
######14.3.2、中介者模式的缺点
		中介类会变得越来越大
######14.3.3、中介者模式的使用场景	
		类的相互之间的依赖出现蜘蛛网可以梳理成星型结构
#####14.4、中介者模式的实际应用
	
####第15章、命令模式	
#####15.1、项目经理也难当
#####15.2、命令模式的定义
		将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能
#####15.3、命令模式的应用
######15.3.1、命令模式的优点
		1、类间解耦
		2、可扩展性
		3、命令模式结合其他模式更优秀
######15.3.2、命令模式的缺点
		命令的子类的比较的膨胀	

####第16章、责任链模式 
#####16.1 古代妇女的枷锁--"三从四德"
#####16.2 责任链模式的定义
	使多个对象都有机会处理请求，从而避免了请求的发送和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，知道有对象处理它为止
	抽象处理者：
		1、定义一个请求的处理方法handleMessage，唯一对外开放的方法
		2、定义一个链的编排方法setNext,设置下一个处理中
		3、定义了具体的请求者必须实现的两个方法（定义自己能够处理的级别getHandleLevel和具体的处理任务echo）
#####16.3 责任链模式的应用
######16.3.1、责任链模式的优点
######16.3.2、责任链模式的缺点
		1、性能问题
		2、调试不很方便 

####第17章、装饰模式
#####17.1、罪恶的成绩单
#####17.2、装饰模式的定义
	通用类图：
		1、Component抽象组件：是一个接口或者是抽象类，就是定义我们最核心的对象，也是最原始的对象
		2、ConcreteComponent具体组件：你要装饰的就是它
		3、Detcorator装饰角色：在它的属性里必然有一个private变量指向Component抽象构件
		4、具体的装饰角色：把你最核心，最原始的，最基本的东西装饰城其他东西	
#####17.3、装饰模式的应用
######17.3.1、装饰模式的优点
######17.3.2、装饰模式的缺点：
######17.3.3、装饰模式的使用场景：
		1、需要扩展一个类的功能，或给一个类增加附加功能
		2、需要动态地给一个对象增加功能，这些功能可以在动态地撤销
		3、需要为一批的兄弟类进行改装或加装功能，首选装饰模式
####第18章、策略模式
#####18.1、刘备江东娶妻
#####18.2、策略模式的定义
	定义一组算法，将每个算法都封装起来，而且使他们之间可以互换
	类图：
		1、Context封装角色：上下文角色，屏蔽高层模块对策略，算法的直接访问，封装可能存在的变化
		2、Strategy抽象策略角色
		3、ConcreteStrategy具体策略角色
#####18.3、策略模式的应用
######18.3.1、策略模式的优点:
		1、算法可以自己切换
		2、避免使用多重条件判断
		3、扩展性良好
######18.3.2、策略模式的缺点;
		1、策略类数量增多
		2、所有的策略类都需要对外暴露
######18.3.3、策略模式的使用场景
		1、多个类只有在算法或行为上稍微不同场景
		2、算法需要自由切换的场景
		3、需要屏蔽算法规则的场景


####第19章、适配器模式
#####19.1、业务发展
#####19.2、适配器模式定义
	将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作
		适配器三种角色：
			1、Target目标角色：该角色定义把其他类转换为何种接口，也就是我们所期望的接口。
			2、Adaptee源角色：想把谁转换成目标角色，这个“谁”就是源角色
			3、Adapter适配器角色：就是把源角色转换成目标角色，可以通过继承或是关联的方式 
#####19.3、适配器模式的应用
######19.3.1、适配器模式的优点
		1、适配器模式可以让两个没有任何关联的类在一起运行
		2、增加了类的透明性
		3、提高了类的复用度
		4、灵活性非常好
######19.3.2、适配器模式的使用场景
		1、扩展已经运行正常的系统


####第20章、迭代器模式
#####20.1、整理项目信息
