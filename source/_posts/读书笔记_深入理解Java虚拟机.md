---
title: 读书笔记_深入理解Java虚拟机
date: 2019-04-05 23:01:41
tags:
categories: 读书笔记
---
#一、*思维导图*
#*总知识点*
####第一部分
####第1章走近Java
#####1.6、实战：自己编译JDK 
####第二部分、自动内存管理机制
####第2章、Java内存区域与内存溢出异常
#####2.2、运行时数据区域
######2.2.1、程序计数器：
	是一块比较小内存空间，它可以看作是当前线程所执行的字节码的行号指示器，这类内存区域为线程私有的内存。这一块是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域 
######2.2.2、Java虚拟机栈：
	1、线程私有，生命周期与线程生命周期一样。描述的是Java方法执行的内存模型，每个方法执行的时候都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息
	2、每个方法从调用到执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈过程
	这区域规定出现两种异常：
		1、如果线程请求的栈深度大于虚拟机如允许的深度，将会抛出StackOverflowError异常
		2、如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常
		
######2.2.3、本地方法栈：类似于Java虚拟机栈
######2.2.4、Java堆
		1、是虚拟机所管理内存最大的一块
		2、Java堆是被所有线程共享的一块区域，在虚拟机启动时创建。主要的目前是存放对象实例
		3、Java堆是垃圾收集器管理的主要区域，现在收集器基本采用分代收集算法，可以细分为新生代和老年代，再细分则为Eden，From，To Survivor空间
		4、通过（-Xmx和-Xms控制）异常抛出OutOfMemoryError异常
######2.2.5、方法区
		1、是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码
		2、异常抛出OutOfMemoryError异常
		3、运行时常量池时方法区的一部分。
#####2.3、HotSpot虚拟机对象
######2.3.1、对象的创建
		1、解决在并发情况下创建对象并非是线程安全两种解决方案：
			1、对分配内存空间的动作进行同步处理----实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性
			2、把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为线程分配缓冲
######2.3.2、对象的内存布局
	 对象在内存中存储的布局可以划分为3块区域：对象头，实例数据，对齐填充
		1、对象头包括两部分信息
			1、第一部分：用于存储对象自身的运行时数据。
			2、第二部分：类型指针，即对象只想它的类云数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
######2.3.3、对象的访问定位
	建立对象是为了使用对象，Java程序需要通过栈（Java虚拟机栈）上的reference数据来操作堆上的具体对象
		访问方式：
			1、使用句柄
				Java堆中将会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址。
				句柄中包含对象的实例数据与类型数据格式具体的地址
			2、直接指针
				存对象的具体地址
#####2.4、实战：OutOfMemoryError异常
#####2.4.1、Java堆溢出
		会跟着进一步提示Java heap space
		解决这个区域的异常:
			1、通过内存映射分析工具堆Dump出来的堆快照进行分析，分析到底出现的是内存泄漏（Memory leak）还是内存溢出（Memory OverFlow）
			2、内存泄漏，通过工具查看泄漏对象到GC root的引用链，是通过什么路劲与GC root相关联导致垃圾收集器无法自动回收它们
			3、内存溢出，通过调节堆参数
#####2.4.2、虚拟机栈和本地方法栈溢出
		栈的容量只有-Xss参数设定，在Java虚拟机规范中描述了两种异常
			1、如果线程请求的栈深度大于虚拟机锁允许的最大深度，将抛出StackOverflowError异常
			2、如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError
#####2.4.3、方法区和运行时常量池溢出
		-XX：PermSize和-XX：MaxPermSize限制方法区大小
		方法区用于存放Class的相关信息，如类名、访问修饰符，常量池，字段描述、方法描述等
#####2.4.4、本机直接内存溢出
		DirectMemory容量可通过-XX：MaxDirectMemorySize指定


####第3章、垃圾收集器与内存分配策略
#####3.1、概述
		1、哪些内存需要回收？
		2、什么时候回收？
		3、如何回收/
#####3.2、对象已死吗？
######3.2.1、引用计数算法
		问题：它很难解决对象相互循环引用问题
######3.2.2、可达性分析算法
		 在Java中，可以作为GC Roots的对象包括下面几种‘
		 1、虚拟机栈（栈帧中的本地变量表）中引用的对象
		 2、方法区中类静态属性引用的对象
		 3、方法区中常量引用的对象
		 4、本地方法栈中JNI（即一般说的Native方法）引用的对象
######3.2.3、再谈引用
		1、强引用
		2、软引用
		3、弱引用
		4、虚引用
######3.2.4、生存还是死亡
		至少需要经历两次标记过程
######3.2.5、回收方法区

#####3.3、垃圾收集算法
#####3.3.1、标记-清除算法
#####3.3.2、复制算法
#####3.3.3、标记-整理算法
#####3.3.4、分代收集算法
			新生代：复制算法
			老年代：标记-清除/标记-整理	

#####3.4、HotSpot的算法实现	
######3.4.1、枚举根节点	
#####3.5、垃圾收集器
#####3.5.8、理解GC日志

#####3.6、内存分配与回收策略
######3.6.1、对象优先在Eden分配	
######3.6.2、大对象直接进入老年代	：字符串及数组
######3.6.3、长期存活的对象将进入老年代
######3.6.4、动态对象年龄判定
######3.6.3、空间分配担保	

####第4章、虚拟机性能监控与故障处理工具	
#####4.1、概述
		运行日志，异常堆栈，GC日志，线程快照，堆转储快照
#####4.2、JDK的命令行工具
######4.2.1、jps:虚拟机进程状况工具
		jps  -q/-m/-l/-v
######4.2.2、jstat:虚拟机统计信息工具
		用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载，内存，垃圾收集，jit编译等运行数据。
		jstat[option vmid[interval[s|ms][count]]]
		选项option代表着用户希望查询虚拟机的信息，主要分成，类装载，垃圾收集，运行期编译	
######4.2.3、jinfo:Java配置信息工具
		实时地查看和调整虚拟机各项参数
######4.2.4、jmap:Java内存映像工具
		用于生产堆转存储快照
######4.2.5、jhat:虚拟机堆转储快照分析工具
######4.2.6、jstack:Java堆栈跟踪工具
		用于生成虚拟机当前时刻的线程快照
		主要原因是定位线程出现长时间停顿的原因，如线程间死锁，死循环，请求外部资源导致长时间等待等都是导致线程长时间停顿常见原因。
#####4.3、JDK的可视化工具	
#####4.3.1、JConsole:Java监视与管理控制台
#####4.3.2、VisualVm: 多合一故障处理工具

####第5章、调优案例分析与实战
#####5.1、概述
#####5.2、案例分析
######5.2.1、高性能硬件上的程序部署策略
######5.2.2、集群间同步导致的内存溢出
######5.2.3、堆外内存导致的溢出错误
######5.2.4、外部命令导致系统缓慢
######5.2.5、服务器JVM进程崩溃
######5.2.6、不恰当数据结构导致内存占用过大
######5.2.7、由window虚拟内存导致的长时间停顿	
#####5.3、实战：Eclipse运行速度调优	




####第三部分、虚拟机执行子系统
####第6章、类文件结构	
#####6.1、概述
#####6.3、Class类文件的结构
		这种伪结构只有两种数据类型：无符号和表。无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表一个字节，2个字节，4个字节，8个字节。无符号数可以用来描述数字，索引引用，数量值或者按照utf-8编码构成字符串值
######6.3.1、魔数与Class类文件的版本
		每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件
		魔数的字节存储的是Class文件的版本号，第5和6是次版本号（Minor Version），第7和第8字节是主版本号（Major Verison）
######6.3.2、常量池
		是常量池入库，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型 
		常量池主要存放两大类型常量：字面量和符号引用。
		1、字面量主要包含文本字符串，声明为final的常量值
		2、符号引用：
			1、类和接口的全限定名
			2、字段的名称和描述符
			3、方法的名称和描述符
######6.3.3、访问标志
	  2个字节代表访问标志，这个标志用于识别一些类火车接口层次的访问信息，包括这个Class是类还是接口，是否定义为public类型。是否定义为abstct
######6.3.4、类索引、父类索引与接口索引集合
	类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据集合，Class文件中由这个确立这个类的继承关系 
######6.3.5、字段表集合
	字段表用于描述 接口或者类中声明的变量。字段包括类级变量和实例变量，但不包括在方法内声明的局部变量
######6.3.6、方法表集合
	依次包含访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）
######6.3.7、属性表集合
	对于每个属性，它的名称需要从常量池中引用一个Constant_utf8_info类型的常量来表示。
	1、Code属性
		Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内
		Code属性是Class文件中最重要的的一个属性，如果把一个Java程序中的信息分为代码Code和元数据，Code描述代码
	2、Exceptions属性:列举出方法中可能抛出的受检查异常，也就是方法描述时在throws关键字后面列举的异常
	3、LineNumberTable属性:用于描述Java源码行号与字节码行号之间的对应关系。
	4、LocalVariableTable属性：用于描述栈帧中局部变量表中的变量与java源码中定义的变量之间的关系，它不是运行时必须的属性
	5、SourceFile属性
		用于记录生成这个Class文件的源码文件名称
	6、ConstantValue属性：通知虚拟机自动为静态变量赋值
	7、InnerClasses属性：记录内部类与宿主类之间的关联
#####6.4、字节码指令简介
#####6.5、公有设计和私有实现


####第7章、虚拟机类加载机制	
#####7.1、概述
		虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。这就是虚拟机的类加载机制
#####7.2、类加载的时机
		它的整个生命周期：加载，（验证，准备，解析，）初始化，使用，卸载
		解析阶段可以在初始化阶段之后开始，这个是支持Java语言运行时绑定
		5种情况下必须立即对类进行“初始化”
		1、遇到new ，getstatic，putstatic，invokestatic这4条字节码指令时，如果类没有进行初始化，则需要先触发其初始化
		2、使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
		3、当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
		4、当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机先要初始化这个主类
		5、当使用JDk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandler实例最后的解析结果，ref_getstaticd的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则序号先触发其初始化

#####7.3、类加载的过程
######7.3.1、加载
	在加载阶段，虚拟机需要完成3件事
		1、通过一个类的全限定名来获取定义此类的二进制字节流
		2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
		3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
	加载完成之后，在内存中实例化一个java.lang.Class类对象，存放于方法区里面
######7.3.2、验证
	这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，而且不会危害虚拟机的自身安全
		1、文件格式验证：主要的目的是保证输入的字节流能正确解析并存储于方法区之内
			1、是否以魔数oxcaffbabe开头
			2、主次版本号是否在当前虚拟机处处理范围之内
		2、元数据验证：是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。
		3、字节码验证：这个阶段对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件
		4、符号引用验证：虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段-解析阶段中发生
######7.3.3、准备
	这个阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配
		1、内存分配的仅仅包括类变量（被static修饰的变量）
		2、初始值是对数据类型的零值
######7.3.4、解析
	这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程
	解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄、和调用点限定符7类符号进行
		1、类和接口解析
		2、字段解析
		3、类方法解析
		4、接口方法解析
######7.3.5、初始化
	这个阶段，才是真正开始执行类中定义的Java程序代码，初始化阶段是执行类的构造器<clinit>()方法的过程

#####7.4、类加载器
######7.4.1、类与类加载器
######7.4.2、双亲委派模型
	从Java虚拟机的角度来讲，只存在两种不同的类加载器
		1、启动类加载器
		2、其他的类加载器，实现ClassLoader
	从Java开发人员的角度来看
		1、启动类加载器:这个类加载器负责将存在java_home\lib，加载置内存中
		2、扩展类加载器：ext目录中
		3、应用程序类加载器：用户类路径上指定的类库
######7.4.3、破坏双亲委派模型



####第8章、虚拟机字节码执行引擎	
#####8.1、概述
		虚拟机方法调用和字节码执行
#####8.2、运行时栈帧结构
		是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素
		栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息
		每个方法从调用开始至执行完成的过程，都对应一个栈帧在虚拟机栈厘米从入栈到出栈的过程
######8.2.1、局部变量表
		是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量
######8.2.2、操作数栈
		它是一个后入先出的栈
######8.2.3、动态连接
		每个栈帧都包含一个指向运行时常量池中该栈帧所属的方法的引用，持有这个引用是为了支持方法调用过程中动态连接
######8.2.4、方法返回址
		1、正常退出出口：调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值
		2、异常退出出口：返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息
######8.2.5、附加信息
#####8.3、方法调用
		在Java虚拟机中提供了5条方法调用字节码指定
			1、invokestatic：调用静态方法
			2、invokespecial：调用实例构造器<init>	方法，私有方法，父类方法
			3、invokevirtual：调用所有的虚方法
			4、invokeinterface：调用接口方法，会在运行时在确定一个实现此接口的对象
			5、invokedynamic:先在运行时动态解析出调用点限定符所引用的方法，然后在执行
######8.3.1、解析
	所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号转化为直接引用
######8.3.2、分派
	1、静态分派
		所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载。是发生在编译阶段
	2、动态分派
		重写
	3、单分派与多分派
	4、虚拟机动态分派的实现
######8.3.3、动态类型语言支持
	字节码指令集迎来了一个新的指令-invokedynamic指令，是使jdk实现“动态类型语言”
		1、动态类型语言
		2、JDK1.7与动态类型
		3、java.lang.invoke包
#####8.4、基于栈的字节码解释执行引擎
######8.4.1、解释执行  
		在Java语言中，javac编译器完成了程序代码经过词法分析，语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流过程。
######8.4.2、基于栈的指令集与基于寄存器的指令集


####第9章、类加载及执行子系统的案例与实战
#####9.1、概述
		能通过程序操作的，主要是字节码生成与类加载器这两部分的功能
#####9.2、案例分析
######9.2.1、Tomcat：正统的类加载器架构
	在Tomcat目录结构下，有三组（common，server，shared）可以存放Java类库
	另外还可以加上Web应用程序自身的目录/WEB-INF
		1、放置在/common目录中：类库可被Tomcat和所有的Web应用程序共同使用
		2、放置在/server目录中：类库可被Tomcat使用，对所有的Web应用程序都不可见
		2、放置在/shared目录中：类库可被所有的Web应用程序共同使用，对tomcat自己不可见
		2、放置在/WEB-INF目录中：类库只可被此Web应用程序使用，其他的Web应用和tomcat本身不可用

	tomcat自定义4个自定义加载器



####第四部分、程序编译与代码优化
####第10章、早期（编译期）优化
#####10.1、概述
		1、前端编译器：Sun的Javac,Eclipse JDT中的增量式编译器，把*.java文件转变成*.class文件的过程
		2、JIT编译器：HotSpot VM C1、C2编译器
		3、AOT编译器
#####10.2、Javac编译器
######10.2.1、Javac的源码与调试
		从Sun Javac的代码来看，编译过程大致分为3个过程：
			1、解析与填充符号表过程
			2、插入式注解处理器过程
			3、分析与字节码生成过程
######10.2.2、解析与填充符号表
		 1、词法、语法分析
		 2、填充符号表
######10.2.3、注解处理器
######10.2.4、语义分析与字节码生成
		语义分析
			1、标注检查：变量使用前是否已被声明，变量与赋值之间的数据类型是否能够匹配等
			2、数据及控制流分析：检查出例如程序局部变量在使用前是否有赋值，方法的每条路径是否都有返回值，是否所有的受查异常都被正确处理了问题
			3、解语法糖：Java中最常用语法糖，泛型，变长参数，自动装箱/拆箱
			4、字节码生成：
#####10.3、Java语法糖的味道
######10.3.1、泛型与类型擦除
######10.3.2、自动装箱、拆箱与遍历循环
######10.3.3、条件编译
#####10.4、实战：插入式注解处理器


####第11章、晚期（运行期）优化
#####11.1、概述
	 在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器
#####11.2、HotSpot 虚拟机内的即时编译器
######11.2.1、解释器与编译器
######11.2.2、编译对象与触发条件
		在运行过程中会即时编译为“热点代码”有两类：
			1、被多次调用的方法
			2、被多次执行的循环体
		判定热点栈测有两种
			1、基于采样的热点栈测
			2、基于计数器的热点栈测
######11.2.4、查看及分析即时编译结果
#####11.3、编译优化技术


####第五部分、高效并发
####第12章、Java内存模型与线程
#####12.1、概述
	虚拟机如何实现多个线程，多线程之间由于共享和竞争数据而导致一系列问题及解决方案
#####12.2、硬件的效率与一致性
		缓存一致性协议
##### 12.3、Java内存模型
	Java内存模型，JMM来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果
###### 12.3.1、主内存与工作内存
###### 12.3.2、内存间交互操作
	8种内存访问操作：
		1、lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态
		2、unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
		3、read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
		4、load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存的变量副本中
		5、use（使用）：作用于工作内存的变量，它把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个使用到变量的值得字节码指令时将会执行这个操作。
		6、assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值付给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
		7、store（存储）：作用于工作内存变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
		8、write（写入）：作用于主内存的变量，它把store操作从工作内存中得到变量的值放到如主内存变量中
###### 12.3.3、对于volatile型变量的特殊规则
		1、运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
		2、变量不需要与其他的状态变量共同参与不变约束
###### 12.3.4、对于long和double型变量的特殊规则
		在编写代码的时候一般不需要把用到的long和double变量专门声明为volatile
###### 12.3.5、原子性，可见性与有序性
	 原子性：read，load，assign，use，store，write
	 可见性：volatile，Java两个关键字，synchronize和final
	 有序性：volatile，	synchronize
###### 12.3.6、先行发生原则
		1、程序次序规则
		2、管程锁定规则
		3、volatile变量规则
		4、线程启动规则：Thread对象的start（）方法先行发生于此线程的每个动作
		5、线程终止规则：线程中所有操作都先行于对此线程的终止检测，我们可以通过Thread.join()方法介绍，Thread.isAlive()的返回值终止线程
		6、线程中断规则
		7、线程终结规则
		8、传递性

##### 12.4、Java与线程
######12.4.1、线程的实现
		1、使用内核线程实现
		2、使用用户线程实现
		3、使用用户线程加轻量级进程混合实现
		4、java线程的实现
######12.4.2、Java线程调度
		协同式线程调度
		抢占式线程调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定




####第13章、线程安全与锁优化
#####13.1、概述
#####13.2、线程安全
######13.2.1、java语言中的线程安全
		各种操作共享的数据分为5类：
		1、不可变
		2、绝对线程安全
		3、相对线程安全
		4、线程兼容
		5、线程对立
######13.2.2、线程安全的实现方法
		1、互斥同步：临界区，互斥量，信号量都是主要的互斥实现方式。
		2、非阻塞同步：乐观的并发策略
		3、无同步方案
			1、可重入代码
			2、线程本地存储
				通过ThreadLocal类来实现线程本地存储功能

#####13.3、锁优化
######13.3.1、自旋锁与自适应自旋
######13.3.2、锁消除：指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除
######13.3.3、锁粗化
######13.3.4、轻量级锁、
######13.3.5、偏向锁