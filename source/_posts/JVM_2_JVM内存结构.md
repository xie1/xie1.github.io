---
title: JVM_虚拟内存结构(二)
date: 2018-11-18 15:02:55
tags: JVM
categories: Java基础

---


##虚拟机内存区域与内存溢出异常
	主要关注点：
		1、jvm内存结构都是什么
		2、对象分配规则
	问题分析：
	1、理解运行的数据区域划分为几块-->概念
	2、每一块区域主要存放的是什么，有什么功能-->特性的理解
	3、每一块最有可能出现的问题，例如内存溢出或泄露之类的-->异常
	4、如何定位这类问题的出现及解决，如何调整区域的设置-->扩展
	5、此块区域与其他模块的之间的关系（垃圾回收机制等）-->关系

		


#一、*思维导图*
[http://naotu.baidu.com/file/424e5783104cee1155554921f0ca3cd7](http://naotu.baidu.com/file/424e5783104cee1155554921f0ca3cd7)	
#二、*总知识点*
### 1、运行时的数据区域划分
![运行时的数据区域](https://i.imgur.com/2OEJXlr.png)
#### 1.1、程序计数器
		1、存放内容：正在执行的虚拟机字节码指令的地址
		2、特点：线程私有，每个线程都有自己的程序计数器	
#### 1.2、Java虚拟机栈
	1、存放内容：虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程
		1、描述Java方法执行的内存模型（栈帧）：
				1、局部变量表
				2、操作数栈
					字节码指令，先入后出
					调用其它的方法的时候是通过操作数栈来传递参数的
				3、动态连接
				4、返回地址，方法退出的过程实际上就等于把当前栈帧出栈，退出可能执行的操作
					退出种类
					执行引擎遇到人员一个方法返回的字节码指令
					方法执行过程中遇到了异常，而且这个异常没有在方法体内得到处理
		2、局部变量表：
				1、存放编译期间可知的各种基本类型，对象引用和returnAdress类型（指向字节码地址）
				2、单位64位的long和double占2slots的局部变量空间，其他类型1slot
						
	2、特点：线程私用
	3、异常状况
			1、请求栈深度大于虚拟机允许的深度，将抛出StackOverflowError异常
			2、无法申请到足够的内存，将抛出OutOfMemoryError异常

#### 1.3、本地方法栈
		类似于虚拟机栈，而本地方法则为虚拟机使用到的Native方法服务
#### 1.4、Java堆 
		存放对象实例（通过-Xmx（最大值）和-Xms（初始值）控制）
		1、存放内容：对象实例及几乎所有的对象实例和数组都要再堆上分配
		2、分区
			1、新生代
			 Eden空间
			 From Survivor空间
			 To Survivor空间
			2、老年代
		3、特点:线程共享
		4、异常状况：将抛出OutOfMemoryError异常
#### 1.5、方法区
		1、存放内容
			已被虚拟机加载类信息
			常量
			静态变量
			即时编译后的代码
		2、特点 :线程共享,可以选择不实现垃圾收集
		3、异常状况 : 将抛出OutOfMemoryError异常
		4、运行时常量池


####宏观简述一下JVM加载类的工作流程：
	1、通过java.exe运行Java3yTest.class，随后被加载到JVM中，元空间存储着类的信息(包括类的名称、方法信息、字段信息..)。
	2、然后JVM找到Java3yTest的主函数入口(main)，为main函数创建栈帧，开始执行main函数
	3、main函数的第一条命令是Java3y java3y = new Java3y();就是让JVM创建一个Java3y对象，但是这时候方法区中没有Java3y类的信息，所以JVM马上加载Java3y类，把Java3y类的类型信息放到方法区中(元空间)
	4、加载完Java3y类之后，Java虚拟机做的第一件事情就是在堆区中为一个新的Java3y实例分配内存, 然后调用构造函数初始化Java3y实例，这个Java3y实例持有着指向方法区的Java3y类的类型信息（其中包含有方法表，java动态绑定的底层实现）的引用
	5、当使用java3y.setName("Java3y");的时候，JVM根据java3y引用找到Java3y对象，然后根据Java3y对象持有的引用定位到方法区中Java3y类的类型信息的方法表，获得setName()函数的字节码的地址
	6、为setName()函数创建栈帧，开始运行setName()函数




----------

### 2、HotSpot虚拟机对象
####2.0、对象分配规则	
		1、对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
		大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
		长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
		2、动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
		3、空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC

#### 2.1、对象的创建
##### 2.1.1、第一步
		在Java堆上做操作：
		1、检查常量池
		2、检查类加载，解析，初始化
		3、指针策略 :CAS 和 TLAB
		4、空间分配 ：指针碰撞 和 空闲列表
		5、初始化内存空间为零值
		6、设置对象属性
		7、完成对象创建
##### 2.1.2、第二步
		1、设置对象信息
		2、初始化类信息
#### 2.2、对象的内存布局
		1、对象头
			1、自身信息
				1、哈希码
				2、 GC分代年龄
				3、 锁状态标志
				4、 线程持有的锁
				5、 偏向线程ID
				6、 偏向时间戳
			2、类型指针：指向它的类元数据的指针
		2、实例数据
		3、对齐填充
#### 2.3、对象的访问定位
		1、方式
			1、句柄
			2、直接指针
![](https://i.imgur.com/2ATxWAC.png)
![](https://i.imgur.com/TplB2oA.png)

----------

### 3、实战：OutOfMemoryError异常
####3.1、Java堆溢出
		-Xms : 设置堆的最小值
		-Xmx : 设置堆的最大值
####3.2、虚拟机栈和本地方法栈溢出
		1、参数：-Xss
		2、单线程： 实际一般抛出的异常都是StackOverflowError
		3、多线程
			StackOverflowError
			OutOfMemoryError

####3.3、方法区和运行时常量池溢出
####3.4、本机直接内存溢出
		-XX：MaxDirectMemorySize
		特点




####三、*参考资料*
[https://juejin.im/post/5b45ef49f265da0f5140489c#heading-13](https://juejin.im/post/5b45ef49f265da0f5140489c#heading-13)
[http://www.cnblogs.com/qiumingcheng/p/5398610.html](http://www.cnblogs.com/qiumingcheng/p/5398610.html "Java程序编译和运行的过程")









 






