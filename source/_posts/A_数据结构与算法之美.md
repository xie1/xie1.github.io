
##A_数据结构与算法之美

![Alt text](./913e0ababe43a2d57267df5c5f0832a7.jpg)


	
	学习的目的：
	1、它的来历
	2、自身的特点
	3、适合解决的问题
	4、实际的应用场景

	数据结构：
	1、线性表
		1、数组
		2、链表
			1、单链表
			2、双向链表
			3、循环链表
			4、双向循环链表
			5、静态链表
		3、栈
			1、顺序栈
			2、链式栈
		4、队列
			1、普通队列
			2、双端队列
			3、阻塞队列
			4、并发队列
			5、阻塞并发队列
	2、散列表
		1、散列函数
		2、冲突解决
			1、链表法
			2、开放寻址
			3、其他
		3、动态扩容
		4、位图
	3、树
		1、二叉树
			1、平衡二叉树
			2、二叉查找树
			3、平衡二叉查找树
				1、AVL树
				2、红黑树
			4、完全二叉树
			5、满二叉树
		2、多路查找树
			1、B树
			2、B+树
			3、2-3树
			4、2-3-4树
		3、堆
			1、小顶堆
			2、大顶堆
			3、优先级队列
			4、裴波那契堆
			5、二项堆
		4、其他
			1、树状数组
			2、线段树
	4、图
		1、图的存储
			1、邻接矩阵
			2、邻接表
		2、拓扑排序
		3、最短路径
		4、关键路径
		5、最小生成树
		6、二分图
		7、最大流
		
		
		
	算法：
	1、复杂度分析
		1、空间复杂度
		2、时间复杂度
			1、最好
			2、最坏
			3、平均
			4、均摊
	2、基本算法思想
		1、贪心算法
		2、分治算法
		3、动态规划
		4、回溯算法
		5、枚举算法
	
	3、排序
		1、O(n^2)
			1、冒泡排序
			2、插入排序
			3、选择排序
			4、希尔排序
		2、O(nlogn)
			1、归并排序
			2、快速排序
			3、堆排序
		3、O(n)
			1、计数排序
			2、基数排序
			3、堆排序
	4、搜索
		1、深度优先搜索
		2、广度优先搜索
		3、A*启发式搜索
	
	5、查找
		1、线性查找
		2、树结构查找
		3、散列表查找
		
	6、字符串匹配
		1、朴素
		2、KMP
		3、Robin-Karp
		4、Boyer-Moore
		5、AC自动机
		6、Trie
		7、后缀数组
		
	7、其他
		1、数论
		2、计算几何
		3、概率分析
		4、并查集
		5、拓扑网络
		6、矩阵运算
		7、线性规划
	
	
	事半功倍的学习技巧：
		1、边学边练，适度刷题
			每周花1-2小时的时间，集中把这周涉及的数据结构及算法，全部写出，用代码实现一遍
		2、多问，多思考，多互动
		3、知识需要沉淀，不要试图一下掌握所有
			学习知识的过程是反复迭代，不断沉淀的过程
##一、数据结构
###0、时间和空间复杂度
####1、时间复杂度分析
![Alt text](./1560925810647.png)
![Alt text](./1560925823153.png)

	
	1、最好情况时间复杂度
	2、最坏情况时间复杂度
	3、平均情况时间复杂度
	4、平摊时间复杂度


####2、空间复杂度分析
###1、数组
	1、数组Array是一种线性表的数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。
	特性：
		1、线性表
		2、连续的内存空间和相同的类型的数据
![Alt text](./1560927894470.png)
![Alt text](./1560927904357.png)

####1.1、如何实现随机访问
####1.2、插入和删除操作
####1.3、数组的访问越界问题
####1.4、容器能否完全替代数组
	1、在开发阶段，优先选择容器
	2、在做底层的数据结构优化，性能优化，可以优先考虑数组
###2、链表
	如何基于链表实现LRU缓存淘汰算法？
	缓存淘汰策略：
		1、先进先出策略FIFO
		2、最少使用策略LFU
		3、最近最少使用策略LRU
####2.1、单链表
	1、头结点
	2、尾结点，指针指向null

	链表的操作
		1、单链表的反转
		2、链表中环的检测
		3、两个有序的链表合并
		4、删除链表倒数第n个结点
		5、求链表的中间结点
####2.2、双向链表
	LinkedHashMap底层实现是双向链表
####2.3、循环链表
	约瑟夫问题

####2.4、其他
	1、理解指针或引用的含义
	2、警惕指针丢失和内存泄漏
	3、利用哨兵简化实现难度
		new_node->next = p->next;
		p->next = new_node	
	4、重点留意边界条件处理
		在写代码的时候考虑会遇到什么样的边界问题
	5、举例画图，辅助思考
	

###3、栈
####3.1、顺序栈：可以用数组来实现
		入栈的时间复杂度是O(1)
		1、栈在函数调用中的应用（类似是栈帧入栈出栈（虚拟机栈）过程）
		2、栈在表达式求值中的应用
		3、栈在括号匹配中的应用
####3.2、链式栈：用链表来实现
###4、队列
	数据结构：先进先出(队尾插入，队头删除)
####4.1、顺序队列
		1、入队：存在一个head指针，指向队头，一个是tail指针，指向队尾
		2、出队
####4.2、链式队列
		1、入队
			tail->next = new_node ,tail = tail->next
		2、出队
			head = head ->next
####4.3、循环队列
		当队满时，(tail+1)%n ==head
####4.4、阻塞队列和并发队列
		线程池中使用
		1、阻塞队列
		2、并发队列
			线程安全的队列
		
###5、散列表
###6、二叉树
###7、堆
###8、跳表
	跳表，它确实是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作、写起来也不复杂。甚至可以代替红黑树

	跳表是这种链表加多级索引的结构
![Alt text](./1564841136297.png)
![Alt text](./1564841152968.png)

###9、图
###10、Tire树
##二、算法
###1、递归
		1、例如 f(n) = f(n-1)+1  其中f(1) = 1
			这可以理解为f(n)表示你想知道自己在哪一排，f(n-1)表示前面一排所在的排数，f(1)=1表示第一排的人知道自己在第一排
		2、递归需要满足的三个条件
			1、一个问题的解可以分解为几个子问题的解
			2、这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
			3、存在递归终止条件
		3、注意事项
			1、递归代码要警惕堆栈溢出（避免太深的递归）
			2、递归代码要警惕重复计算
			3、过多的函数调用会耗时较多
###2、排序
![Alt text](./1563157611916.png)

	1、冒泡、插入、选择排序 ，时间复杂度为O(n^2) 
	2、快排、归并排序 ,时间复杂度为O（nlogn）
	3、计数、基数、桶排序 ,O(n)

	4、如何分析一个“排序算法”
		1、排序算法的执行效率
			1、最好情况，最坏的情况，平均情况时间复杂度
			2、时间复杂度的系数，常数，低阶（规模比较小）
			3、比较次数和交换（或移动）次数
		2、排序算法的内存消耗
		3、排序算法的稳定性

####2.1、冒泡排序 （Bubble Sort）
		只会操作相邻的两个过程。
![Alt text](./1563159840822.png)
![Alt text](./1563159853254.png)
![Alt text](./1563159872754.png)

	
		1、有序度：数组中具有有序关系的元素对个数
		2、逆序度：
		3、满有序度
		4、冒泡排序包含两个操作原子，比较和交换
####2.2、插入排序（insert Sort）
		1、包含两种操作，一种是元素的比较，一种是元素的移动
![Alt text](./1563161236687.png)
![Alt text](./1563161382920.png)
![Alt text](./1563161428169.png)
	
####2.3、选择排序
![Alt text](./1563161647137.png)
![Alt text](./1563161879686.png)
	
####2.4、归并排序
		原理
		归并排序使用分治思想，将一个大问题分解成小的子问题来解决，小的子问题解决了，大问题也就解决了。分治是一种解决问题的处理思想，递归是一种编程技巧。
		递推公式：
		merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))
		
		终止条件：
		p >= r 不用再继续分解
![Alt text](./1563163531700.png)

####2.5、快速排序（Quicksort）
![Alt text](./1563164796779.png)

		思想是：
		1、如果要排序数组中下标从到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点）
		2、遍历p到r之间的数据，将小于pivot的放左边，将大于pivot的放在右边，将pivot放在中间，经过一系列步骤之后，数组p到r之间的数据就被分成三个部分，前面p到q-1之间都是小于pivot的，中间是pivot，后面的q+1到r之间是大于pivot
		3、用递归排序下标从p到q-1之间的数据和下标q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都是有序
			
			递推公式：
			quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)
			
			终止条件：
			p >= r
####2.6、桶排序
	1、桶排序的核心思想：
		如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有k=n/m个元素。每个桶内部使用快速排序，时间复杂度为O(k*logK)。m个桶排序的时间复杂度就是O（m*k*logK）,因为k=n/m,所以整个桶排序的时间复杂度就是O(n*log(n/m)).当桶的个数m接近数据个数n时，log(n/m)就是一个非常小的常量，这个时候桶的排序的时间复杂度接近O(n)
	2、桶排序比较适合用在外部排序中
####2.7、计数排序	
	1、计数排序的思想是什么
	2、应用场景：
		1、计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合用计数排序，而且计数排序中能给非负数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。		
####2.8、基数排序
	1、基数排序：
		基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可用用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O（n）

####2.9、排序的优化
![Alt text](./1564477902511.png)

###3、二分查找O(logn)
![Alt text](./1564479099228.png)


	二分查找是针对一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0

	1、二分查找递归与非递归实现

	public int bsearch(int[] a, int n, int value) {
		  int low = 0;
		  int high = n - 1;
		
		  while (low <= high) {
		    int mid = (low + high) / 2;
		    if (a[mid] == value) {
		      return mid;
		    } else if (a[mid] < value) {
		      low = mid + 1;
		    } else {
		      high = mid - 1;
		    }
		  }
		
		  return -1;
		}
	
	递归：
		// 二分查找的递归实现
		public int bsearch(int[] a, int n, int val) {
		  return bsearchInternally(a, 0, n - 1, val);
		}
		
		private int bsearchInternally(int[] a, int low, int high, int value) {
		  if (low > high) return -1;
		
		  int mid =  low + ((high - low) >> 1);
		  if (a[mid] == value) {
		    return mid;
		  } else if (a[mid] < value) {
		    return bsearchInternally(a, mid+1, high, value);
		  } else {
		    return bsearchInternally(a, low, mid-1, value);
		  }
		}
	二分查找应用场景的局限性：
		1、二分查找依赖的是顺序表结构，简单来说是数组
			需要按照下标随机访问元素
		2、二分法查找针对的都是有序数据
		3、数据量太小或者太大都不适合二分查找


	2、4种常见的二分查找变形问题
		1、查找第一个值等于给定值的元素
		2、查找最后一个值等于给定值的元素
		3、查找第一个大于等于给定值的元素
		4、查找最后一个小于等于给定值的元素
	
###4、搜索
###5、哈希算法
###6、贪心算法
###7、分治算法
###8、回溯算法
###9、动态规划
###10、字符串匹配算法