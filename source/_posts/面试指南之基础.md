
##1_Java学习/面试指南之基础

##一、Java相关
###1、JVM
####1、概述
####2、运行时数据区域
	1、线程共享：
		堆，方法区，直接内存
	2、线程独享
		虚拟机栈，本地方法栈，程序计数器
#####2.1、程序计数器
	两个作用：
		1、字节码解释器通过改变程序计数器依次读取指令
		2、在多线程情况下，程序计数器用于记录当前的线程执行的位置
	这个一个唯一不会出现OOM的内存区域
#####2.2、Java虚拟机栈
	1、描述的是Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的
	2、虚拟机栈是由一个个栈帧组成，栈帧包括，局部变量表，操作数栈，动态连接，方法出口信息
		1、局部变量表：可知个各种基本数据类型，对象引用（可能是一个指向对象起始地址的引用指针或者是指向一个代表对象的句柄）
	会出现：StackOverflowError：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度时候，则抛出
		 OutOfmemoryError: 若Java虚拟机栈的内存大小允许动态扩展,而且当线程请求栈时内存用完了，无法再动态扩展。
#####2.3、本地方法栈
	执行的本地native方法服务
#####2.4、堆
	1、概念
	2、具体的划分
	3、垃圾回收算法情况
#####2.5、方法区
	用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据
		-XX:perSize= N  方法区永久代初始大小
		-XX：MaxPermSize=N 方法区永久代最大大小
	1、常量池：（字面量,符号引用)
#####2.6、直接内存

####3、HotSpot虚拟机对象
#####3.1、对象创建
	Java创建对象过程：
	1、类加载检查-》2、分配内存-》3、初始化零值-》4、设置对象头-》执行init方法
	解释：
	1、类加载检查:
		虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，而且检查这个符号引用代表的类是否已被加载过，解析和初始化过。如果没有，则必须先执行相应的类加载过程
	2、分配内存：
		对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块大小的内存从java堆中划分出来。分配方式有“指针碰撞”与“空闲列表”
	PS：内存分配并发问题，虚拟机采用两种方式来保证线程安全
		1、CAS+失败重试：CAS是乐观锁的一种实现方式
		2、TLAB：为每个线程现在Eden区分配一块内存
	3、初始化零值：
		将分配到的内存空间都初始化为零值
	4、设置对象头：
		例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象哈希吗，对象的GC分代年龄
	5、执行init方法：
		按照程序员的意愿进行初始化
#####3.2、对象的内存布局
	对象头，实例数据，对齐填充
#####3.3、对象的访问定位
	1、使用句柄（稳定）
		Java堆中划分一块内存作为句柄池，reference中存储的对象的句柄地址，而句柄中包含对象实例数据与对象类型数据各自的具体地址信息
	2、直接指针（速度快）
		reference中存储的对象的地址

	补充：
		1、8种基本类型的包装类和常量池
			Java基本类型的包装类的大部分都实现了常量池技术，即Byte，Short，Integer，Long，Character,Boolean，这5个包装类默认创建数值[-128,127]的相应类型的缓存数据
			两种浮点数类型的包装类Float，Double并没有实现

####4、垃圾回收机制
	常见面试题：
		1、如何判断对象是否死亡
		2、简单介绍一下强引用，软引用，弱引用，虚引用（虚引用与软引用的区别，使用软引用能带来的好处）
		3、如何判断一个常量是废弃常量
		4、如何判断一个类是无用类
		5、垃圾收集有哪些算法，各自特点？
		6、HotSpot为什么分为新生代和老年代
		7、常见的垃圾回收器有哪些？
		8、介绍下CMS，G1收集器？
		9、Minor Gc和Full GC有什么不同
		内存如何分配和回收-》哪些垃圾需要回收-》什么时候回收-》如何回收
#####4.1、JVM内存分配与回收
	堆内存分配策略：
######4.1.1、对象优先在eden区分配
		1、新生代（Minor GC）：指发生在新生代垃圾收集动作，速度一般也比较快
		2、老生代（full GC）：指发生在老年代垃圾收集动作，一般速度会比Minor GC慢10倍以上
######4.1.2、大对象直接进入老年代
		大对象比如字符串，数组
######4.1.3、长期存活的对象将进入老年代
		虚拟机给每个对象一个对象年龄（Age）计数器，阈值为15岁，进入老年代
#####4.2、对象的死亡
	1、引用计数器
	2、可达性分析法
		通过一系列称为GCRoot的对象作为起点，例如：栈中引用的对象，常量引用的对象
######4.2.1、引用
	1、强引用
	2、软引用：可有可无生活用品
	3、弱引用：可有可无生活用品，生命周期更短
	4、虚引用
#####4.3、垃圾收集算法
######4.3.1、标记-清除
		1、效率问题
		2、空间问题
######4.3.2、标记-整理
######4.3.3、复制
		内存分成大小相同的两块
######4.3.4、分代收集
		新生代使用复制算法，老年代使用的标记-清除/标记整理算法

#####4.4、垃圾收集器
######4.4.1、Serial收集器
		串行，单线程，Client选择、
		分代收集
######4.4.2、ParNew收集器
		多线程并发，应用程序暂停，Server模式下首选
		分代收集
######4.4.3、Parallel Scavenge收集器
######4.4.4、CMS收集器（重点）
		是一种以获取最短回收停顿时间为目标的收集器，是以标记-清除算法实现
		并发收集，低停顿
######4.4.5、G1收集器（重点）

####5、虚拟机性能监控和故障处理工具
	JVM调优的常见命令行工具有哪些？
#####5.1、概述
	给一个系统定位问题的时候，知识，经验是关键基础，数据是依据，工具是运用知识处理数据的手段。
#####5.2、JDK命令行工具
	JDK监控和故障处理工具：
		1、jps:显示指定系统内所有的HotSpot虚拟机进程
		2、jstat：用于收集虚拟机各方面的运行数据
		3、jinfo：显示虚拟机配置信息
		4、jmap：生成虚拟机的内存存储快照
		5、jhat：用于分析heapdump文件，它会见了一个HTTP/HTML服务器，让用户可在浏览器上查看分析结果
		6、jstack：显示虚拟机的线程快照
#####5.3、JDK可视化工具
		JConsole和VisualVM是两个功能强大的可视化工具
####6、虚拟机之类文件结构
		1、简单介绍一下Class类文件结构（常量池主要存放的是那两大常量？
		2、Class文件的继承关系是如何确定的？字段表、方法表、属性表主要包含那些信息？
####7、虚拟机之类加载
		1、简单说说类加载过程，里面执行了哪些操作？
		2、对类加载器有了解吗？
		3、什么是双亲委派模型？
		4、双亲委派模型的工作过程以及使用它的好处。
####8、虚拟机之字节码执行引擎
		1、栈帧
		2、方法调用
####9、虚拟机之Java 内存模型
####10、虚拟机之线程安全与锁优化


###2、Java基础
####2.1、Java基础知识回顾
	1、重载与重写之间区别
		重载：发生在同一个类中，方法名相同，方法返回值和访问修饰符不同
		重写：发生在父子类之间，返回值范围小于父类，抛出异常范围小于等于父类，访问修饰符范围大于等于父类
	2、==与equals区别
		==它的作用是判断两个对象的地址是不是相等（基本数据类型比较的是值，引用数据类型比较的内存地址）
		equals：类没有覆盖equals（）方法，则通过比较该类的两个对象时，等价于“==”比较两个对象
		如果已覆盖，来比较两个对象的内容是否相等
	3、hashCode与equals
		hashCode()的作用是获取哈希码，也称为散列码，它实际上是返回一个int整数，这个哈希码的作用是确定该对象在哈希表中的索引位置。
		hashCode()与equals()的相关规定
			1、两个对象相同，则hashcode一定相同
			2、两个对象相同，则调用equals方法返回true
			3、两个对象有相同的hashCode值，他们也不一定相等
			4、equals方法覆盖了，必须也要覆盖hashcode方法
	4、线程与进程区别
		线程是一个比进程更小的执行单位
	5、线程有哪些基本状态？
		启动，运行，等待，阻塞，终止销亡
	6、关于final关键字的总结
		从程序的角度分析（变量，方法，类）
####2.2、J2EE基础知识回顾
	1、Servlet总结：
		在Javaweb程序中，Servlet主要是负责接收用户请求HttpServletRequest，在doGet(),doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户
	2、Servlet接口有哪些方法及Servlet生命周期
		1、init，service，destory
		生命周期：Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init（）方法进行Servlet初始化，请求到达调用Servlet的Service（）方法，service（）方法会根据调用与请求对应的doGet或doPost方法。init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都是执行
	3、doGet()和doPost()区别
		1、基本的区别（参数情况，url的长度的大小，安全性等）
			get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是"%20"
		2、从计算机网络方面：
			1、Get和Post本质上是TCP链接，并无差别，但是由于HTTP的规定和浏览器/服务器的限制，导致它们在应用过程中体现出不一样
			2、GET产生一个TCP数据包；POST产生两个TCP数据包
	4、转发（Forward）和重定向（Redirect）
		转发是服务器的行为，重定向是客户端的行为
	5、Servlet与线程安全
		Servlet不是线程安全，多线程并发的读写会导致数据不一致
	6、JSP的9大内置对象、七大动作，三大指令
		1、request：封装客户端的请求，其中博阿含来自GET和POST请求的参数
		2、response：封装服务器对客户端的响应
		3、pageContext：通过该对象可以获取其他的对象
		4、session： 封装用户会话的对象
		5、application：封装服务器运行环境的对象
		6、out：输出服务器响应的输出流对象
		7、config：Web应用的配置对象
		8、page：JSP页面本身
		9、exception ：封装页面抛出异常的对象
	7、include指令与include的行为区别
		1、include指令是包含其他文件
		2、include动作：用来包含静态和动态文件
	8、JSP中四种作用域
		1、request
		2、session
		3、page
		4、application
	9、实现会话跟踪的技术
		1、使用cookie：向客户端发送Cookie
			优点：数据可以持久保存，不需要服务器资源，简单，基于文本的key-value
			缺点：大小受限制，用户可以限制Cookie功能，由于保存在本地，有一定的安全风险
		2、URL重写：可以将用户会话信息作为请求参数
			优点：在Cookie被禁用之后可以使用
			缺点：必须对网站的URL进行编码
		3、隐藏的表单域
			优点：Cookie被禁止之后也可以用
			缺点：所有页面必须是表单提交之后的结果
		4、HttpSession
			功能强大的服务端用户会话存储
	10、Cookie和Session的区别
		Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群，数据库，文件中
		Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式
####2.3、Collections和Arrays工具类常见方法
#####2.3.1、Collections
	1、排序操作
	2、查找、替换
	3、同步控制
#####2.3.2、Arrays
	1、排序：sort()
	2、查找：binarySearch()
	3、比较：equals()
	4、填充：fill（）
	5、转列表：asList()
	6、转字符串：toString（）
	7、复制：copyOf（）
####2.4、Java常见关键字总结
#####2.4.1、final关键字
		变量，方法，类
#####2.4.2、static关键字
		1、修饰成员变量和成员方法
		2、静态代码块
		3、静态内部类
		4、静态导包
#####2.4.3、this关键字
		表示的当前的实例
#####2.4.4、super关键字
	注意问题：
		1、在构造器中使用super（）调用父类中的其他构造器方法时，该语句必须处于构造器的首行，否则会报错，另外，this调用本类中其他构造方法时，也要放在首行
		2、this，super不能用在static方法中
###3、容器
####3.1、常见面试题
#####3.1.1、List、Set、Map区别
	1、List：有序可以重复 ，ArrayList，Vector，LinkedList
	2、Set：无序不可重复，HashSet，LinkedHashSet，TreeSet
	3、Map：键值对存储，key不可重复,HashMap，HashTable,TreeMap
#####3.1.2、ArrayList与LinkedList区别
	1、线程安全：两者线程都不安全
	2、底层数据结构：ArrayList是Object数组，LinkedList是双向链表
	3、插入和删除情况：
		ArrayList插入和删除受位置影响，时间复杂度是O（n），查询时间复杂度是O（1）
		LinkedList插入和删除是O（1），查询时间复杂度是O（n）
	4、是否支持快速随机访问：LinkedList不支持
	5、内存空间占用：LinkedList存放着前驱和后继的指针，ArrayList主要是结尾会预留一定的容量空间
#####3.1.3、ArrayList与Vector区别
	Vector是线程安全的，所有方法都加了同步锁
#####3.1.4、ArrayList的扩容机制
#####3.1.5、HashMap和Hashtable的区别
	1、线程安全：HashMap是非线程安全，Hashtable是线程安全
	2、效率： HashMap明显效率高
	3、对null key 和 null value 支持 ： HashMap支持null为主键，hashtable则不支持
	4、初始容量大小和每次扩容大小不同
		Hashtable : 初始容量是11，每次扩充，容量是原来的2n+1
		HashMap ： 初始容量是16，每次扩充为2的幂次方大小
	5、底层数据结构： HashMap在jdk1.8之后再解决哈希冲突时有了较大的变化，当链表长度大于（默认值8时），将链表转化为红黑树，以减少搜索时间
#####3.1.6、ConcurrentHashMap和Hashtable区别
	1、底层数据结构：ConcurrentHashMap类似于HashMap
	2、实现线程安全方式
		1、JDK1.7的时候，ConcurrentHashMap(分段锁)对整个桶数组进行分割分段（Segment），每一把锁只能锁容器其中一部分数据，多线程访问容器里不同的数据段的数据，就不会存在锁竞争，提高并发访问率
		2、JDK1.8的时候，是直接用Node数组+链表/红黑二叉树数据结构来实现，并发控制使用了synchronized和CAS操作
		3、Hashtable是同一把锁
#####3.17、HashMap和HashSet的区别
	HashSet底层是基于HashMap实现的
	PS：HashSet是通过hashCode先判断是否出现相同，再通过equals方法去比较
#####3.1.8、HashMap底层原理
	1、JDK1.8之前：底层是数组和链表结合的链表散列
		HashMap通过key的hasCode通过扰动函数（hash方法）处理后得到的hash值，
		之后，通过n-1 & hash值判断当前元素的存放位置（n指的是数组长度），
		如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，相同则覆盖，不相同就通过拉链法解决冲突
	JDK1.8之后：底层是数组和红黑树（当链表长度大于阀值8），以减少搜索时间
	2、HashMap的长度为什么是2的幂次方?
		为了能让HashMap存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，数组下标计算是n-1 & hash
	3、HashMap多线程操作导致死循环问题？
		并发下Rehash会造成元素之间会形成一个循环链表，多线程并发下建议使用ConcurrentHashMap
[多线程HashMap出现死循环](https://coolshell.cn/articles/9606.html)
[HashMap原理](https://zhuanlan.zhihu.com/p/21673805)

#####3.1.9、ConcurrentHashMap底层原理
![Alt text](./a.png)


![Alt text](./2.png)

	JDK1.7（上面有示意图）
	首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。

	JDK1.8 （上面有示意图）
	ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(long(N))）synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。
#####3.1.10、Comparable和Comparator的区别
	1、Comparable是comparable接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序
	2、Comparator：comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序

####3.2、源码学习
#####3.2.1、HashMap源码分析
#####3.2.2、ArrayList源码分析
#####3.2.3、LinkedList源码分析
###4、I/O
####4.1、IO流基础	
1、按操作方式分类
![Alt text](./1.png)

2、按操作对象分类
![Alt text](./QQ截图20190515142201.png)


	操作方式分类说明：
	一、输入字节流InputStream：
	1、ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据
	2、PipedInputStream 是从与其它线程共用的管道中读取数据。PipedInputStream的一个实例要和PipedOutputStream的一个实例共同使用，共同完成管道的读取写入操作。主要用于线程操作
	3、DataInputStream： 将基础数据类型读取出来
	4、ObjectInputStream 和所有 FilterInputStream 的子类都是装饰流（装饰器模式的主角）
	二、输出字节流OutputStream：
	1、ByteArrayOutputStream、FileOutputStream： 是两种基本的介质流，它们分别向- Byte 数组、和本地文件中写入数据
	2、PipedOutputStream 是向与其它线程共用的管道中写入数据
	3、DataOutputStream 将基础数据类型写入到文件中
	4、ObjectOutputStream 和所有 FilterOutputStream 的子类都是装饰流
	三、字符输入流Reader：
	1、FileReader、CharReader、StringReader 是三种基本的介质流，它们分在本地文件、Char 数组、String中读取数据
	2、PipedReader：是从与其它线程共用的管道中读取数据
	3、BufferedReader ：加缓冲功能，避免频繁读写硬盘
	4、InputStreamReader： 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流
	四、字符输出流Writer：
	1、StringWriter:向String 中写入数据
	2、CharArrayWriter：实现一个可用作字符输入流的字符缓冲区
	3、PipedWriter:是向与其它线程共用的管道中写入数据
	4、BufferedWriter ： 增加缓冲功能，避免频繁读写硬盘。
	5、PrintWriter 和PrintStream 将对象的格式表示打印到文本输出流。 极其类似，功能和使用也非常相似
	6、OutputStreamWriter： 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类（具体可以研究一SourceCode）。功能和使用和OutputStream 极其类似，后面会有它们的对应图


	操作对象分类说明：
	1、对文件进行操作（节点流）
		FileInputStream（字节输入流）
		FileOutputStream（字节输出流）
		FileReader（字符输入流）
		FileWriter（字符输出流）
	2、对管道进行操作（节点流）
		PipedInputStream（字节输入流）
		PipedOutStream（字节输出流）
		PipedReader（字符输入流）
		PipedWriter（字符输出流）
		PipedInputStream的一个实例要和PipedOutputStream的一个实例共同使用，共同完成管道的读取写入操作。主要用于线程操作
	3、字节/字符数组流（节点流）
		ByteArrayInputStream
		ByteArrayOutputStream
		CharArrayReader
		CharArrayWriter
		
	除了以上三种字节流之外，其他的都是处理流，需要跟节点流配合使用
	1、Buffered缓冲流（处理流）：带缓冲区的处理流，缓冲区的作用的主要目的是：避免每次和硬盘打交道，提高数据访问的效率。
		BufferedInputStream
		BufferedOutputStream
		BufferedReader
		BufferedWriter
	
	2、转化流（处理流）：
		InputStreamReader：把字节转化成字符
		OutputStreamWriter：把字节转化成字符
	
	3、基本类型数据流（处理流）：用于操作基本数据类型值
	因为平时若是我们输出一个8个字节的long类型或4个字节的float类型，那怎么办呢？可以一个字节一个字节输出，也可以把转换成字符串输出，但是这样转换费时间，若是直接输出该多好啊，因此这个数据流就解决了我们输出数据类型的困难。数据流可以直接输出float类型或long类型，提高了数据读写的效率。
		DataInputStream
		DataOutputStream

	4、打印流（处理流）：
		一般是打印到控制台，可以进行控制打印的地方。
		PrintStream
		PrintWriter
		
	5、对象流（处理流）：
		把封装的对象直接输出，而不是一个个在转换成字符串再输出。
		ObjectInputStream，对象反序列化
		ObjectOutputStream，对象序列化
	
	6、合并流（处理流）：
		SequenceInputStream：可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取
	
	其他类：File（已经被Java7的Path取代）
	File类是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法	
####4.2、Java NIO
#####1、介绍
	1、NIO
		N可以理解为Non-blocking，不单纯是New
	2、NIO的特性与IO区别
		1、IO面向的流，NIO是面向缓冲区的
		2、IO流是阻塞的，NIO是不阻塞
		3、NIO有选择器，而IO没有
	3、读数据和写数据方式
		1、从通道进行数据读取：创建一个缓冲区，然后请求通道读取数据
		2、从通道进行数据写入：创建一个缓冲区，填充数据，并请求通道写入数据
	4、NIO核心组件简单介绍
		1、Channels
		2、Buffers
		3、Selectors
#####2、Java NIO 之Buffer（缓冲区）
#####3、Java NIO 之 Channel（通道）
#####4、Java NIO之Selector（选择器）
####4.4、Java NIO/AIO/BIO区别
		
###5、并发
####5.1、Java并发基础
#####5.1.1、进程和线程区别
	1、进程是程序的一次执行过程，是系统运行程序的基本单位。
	2、线程是比进程更小的执行单位
#####5.1.2、并发与并行区别
	1、并发：同一个时间段，多个任务都在执行（单位时间内不一定同时执行）
	2、并行：单位时间内，多个任务同时执行	
#####5.1.3、多线程的生命周期和状态
	1、new
	2、runnable
	3、blocked
	4、waiting
	5、time_waiting
	6、terminated
#####5.1.4、什么是上下文切换
	当前任务在执行完CPU时间片切换到另一个任务之前会保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到在加载的过程就是一次上下文切换
#####5.1.5、什么是线程死锁
	线程A持有资源1，线程B持有资源2，它们同时都想申请对方的资源，所以就相互等待进入死锁状态
	产生死锁的四个条件：
		1、互斥条件：该资源任意一个时刻只能有一个线程占用
		2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
		3、不剥夺条件：线程已获得的资源在未使用完之前不能被其他强行剥夺，只有自己使用完毕后才释放资源
		4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系
#####5.1.6、sleep和notity区别
	sleep方法没有释放锁，wait方法释放锁
	wait通常用于线程间的交互/通信，sleep通常用于暂停执行
	
####5.2、Java并发进阶
#####5.2.1、Synchronized关键字
	1、对于synchronized关键字的了解？
		主要解决了多个线程之间访问资源同步性，synchronized关键字key保证被它修饰的方法或者代码块在任意时刻只有一个线程执行。
		另外在早期的Java版本，synchronized属于重量级锁，效率低下，而在Java6之后，Java官方对从JVM层面对synchronized较大优化，所以锁效率优化不错。引入了如自旋锁，适应性自选锁，锁消除，锁粗化，偏向锁，轻量级锁等技术来减少锁操作的开销
	2、怎么样使用synchronized关键字？
		主要是三种使用方法
		1、修饰实例方法：作用于当前对象实例加锁，进入同步代码之前要货期当前对象的锁
		2、修饰静态方法：给当前类加锁
		3、修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁
		总结：关键字加到static静态方法和（class）代码块都是给Class类上锁。加在实例方法上是给对象实例上锁
		ps：双重检验锁方式实现单例模式原理
			1、先判断对象是否实例过，没有实例化过才可进入加锁代码
			2、类对象加锁
	3、讲一下synchronized关键字的底层实现？
		1、对于加锁的同步代码块
			通过javap -csvl 命令查看class文件结构，可以发现
			通过monitorenter和monitorexit指令，来指定代码的同步开始及结束部分，当执行到monitorenter指令时，需要获取锁，即获取对象的监视器锁，（锁计数器为0，获取锁成功，计数器加1，释放锁时，计数器为0）
		2、对于加锁的同步方法
			通过acc_synchronized标识，该标识指明了该方法是一个同步方法，jvm通过此访问标识来辨别一个方法是否是同步方法
	4、说下jdk1.6之后，对锁的底层实现做了什么优化？
		1、对锁的实现引入大量的优化，如自旋锁，适应性自旋锁，锁消除，锁粗化，偏向锁，轻量级锁技术减少锁操作开销
		2、锁主要的四种状态：无锁状态，偏向锁，轻量级锁，重量级锁，锁只能向上升级，不可降级，从而提供获得和释放锁。
	5、synchronized和ReenTrantLock的区别？
		1、两者都是可以重入
		2、synchronized依赖的是JVM而ReeTrantLock（需要lock（）和unlock（）配合try/finally语句块完成）依赖的是API
		3、ReenTrantLock增加了些新特性（等待可中断，可实现公平锁，可实现选择性通知）
#####5.2.2、volatile关键字
	1、关于JMMjava内存模型的理解
		1、每个线程有自己独立的工作内存，每个线程有一份来自主内存的变量拷贝，线程优先在自己的工作内存进行数据的读取与写入，之后再跟主内存进行交互（多线程有可能导致数据不一致情况）
		2、通过添加volatile关键字修饰实例变量，保证了内存的可见性，其线程有对变量的改写，必须写入主内存，其他的线程必须从主内存中进行数据的重新读取从而保证数据一致性（禁止指令重排序）
		3、内存间的8个交互操作及规则
	2、synchronized关键字和volatile关键字的区别
		1、线程同步轻量级实现，性能上volatile肯定比synchronized好些
		2、volatile只能修饰变量，synchronized可以修饰方法，代码块
		3、volatile只能保证可见性，不能保证原子性，synchronized都是可以
		4、多线程下volatile不存在阻塞，synchronized会发生阻塞
#####5.2.3、ThreadLocal
![Alt text](./1560762129104.png)
![Alt text](./1560762144559.png)
![Alt text](./1560762168909.png)
![Alt text](./1560762183082.png)


#####5.2.4、线程池
	线程池提供了一种限制和管理资源（包括执行一个任务）。每个线程池还维护一些基本统计信息，例如已完成任务的数量
	1、使用线程池好处：
		1、降低资源消耗
		2、提高响应速度
		3、提高线程的可管理性
	2、实现Runnable接口和Callable接口的区别？
	3、执行execute（）方法和submit（）方法的区别？
	4、如何创建线程池？
		阿里开发手册强制线程池不允许使用Executor去创建，而是通过ThreadPoolExecutor的方式，规避资源耗尽
#####5.2.5、Atomic原子类
	1、介绍下Atomic原子类
			具有原子，原子操作特征的类
	2、介绍下JUC包中的原子类有几类
			1、基本类型
			2、数组类型
			3、引用类型
			4、对象的属性修改类型
	3、介绍下AtomicInteger类的常用方法和原理
		线程安全原理分析
		AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升
#####5.2.6、AQS
	AQS的全称是AbstractQueuedSynchronizer，这个类在JUC.locks包下
######1、AQS简单介绍
######2、AQS原理
######3、Semaphore（信号量）
######4、CountDownLatch(倒计时)
######5、CyclicBarrier(循环栏杆)
######6、ReentrantLock和ReentrantReadWriteLock
####5.3、Java并发容器
	1、ConcurrentHashMap:线程安全的HashMap
	2、CopyOnWriteArrayList：线程安全的List，在读多写少的场合性能非常好，远远好于Vector
	3、ConcurrentLinkedQueue：高效的并发队列，使用链表实现。可以看做是一个线程安全的LinkedList，这是一个非阻塞队列
	4、BlockingQueue：这个是一个接口，JDK内部通过链表，数组等方式实现这个接口。表示阻塞对垒，非常适合用于作为数据共享通道

#####5.3.1、ConcurrentHashMap
#####5.3.2、CopyOnWriteArrayList
#####5.3.3、ConcurrentLinkedQueue
#####5.3.4、BlockingQueue接口
		1、ArrayBlockingQueue
		2、LinkedBlockingQueue
		3、PriorityBlockingQueue
####5.4、悲观锁与乐观锁
#####5.4.1、悲观锁
	总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次都上锁，使用多写的。
	关系型数据库很多用到这种锁机制：行锁，表锁等，读锁，写锁等
	Java中Synchronized和ReentrantLock就是悲观锁体现
			 
#####5.4.2、乐观锁
	总是假设最好的情况，每次去拿数据没有人会修改数据，所以不会上锁。而是采用一种使用版本号机制和CAS算法实现，使用多读。
	Java中原子包，atomic下原子变量类
######1、乐观锁常见的两种实现方式
	1、版本号机制
	一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功
	2、CAS算法
	即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数
	需要读写的内存值 V
	进行比较的值 A
	拟写入的新值 B
	当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试
######2、乐观锁的缺点
	1、ABA问题
	2、循环时间长开销大
	3、只能保证一个共享变量的原子操作
	CAS与synchronized使用场景：
		1、CAS适用于读多写少
		2、synchronized适用于写多读少
###6、Java8

##二、计算机网络
####1、OSI与TCP/IP各层的结构与功能，都有什么协议
		几种对应的网络模型
		1、OSI7层模型（应用层，表示层，回话层，传输层，网络层，数据链路层，物理层）
		2、TCP/IP5层模型（应用层，传输层，网络层，数据链路层，物理层）
		3、TCP/IP4层模型（应用层，传输层，网络层，网络接口层）
		应用层协议：HTTP协议，支持电子邮件的SMTP协议
		传输层协议：TCP/UDP
			1、传输控制协议TCP：提供面向连接的，可靠的数据传输服务
			2、用户数据协议UDP：提供是无连接，尽最大的努力的数据传输服务，不保证可靠性
			TCP特点：
				1、面向连接
				2、一对一
				3、提供可靠的交付服务
				4、提供全双工通信
				5、面向字节流
			UDP特点：
				1、无连接
				2、不保证可靠交付
				3、面向报文
				4、没有阻塞
				5、支持一对一，一对多，等
				6、首部开销小
		网络层协议：IP协议
		数据链路层
		物理层
####2、TCP三次握手和四次挥手
		1、握手过程?
		2、为什么要三次握手？
		3、为什么要传回SYN？
		4、为什么要四次挥手？
		
		1、三次握手
			1、客户端发送SYN数据包到服务器
			2、服务器发送SYN/ACK数据包到客户端
			3、客户端再发送ACK数据包到服务器，从而握手成功，建立连接
		2、四次挥手
			1、客户端发送FIN，用于关闭客户端到服务器的连接
			2、服务端发送一个ACK，确认序号为收到序号加1
			3、服务端再发送一个FIN，用于关闭连接
			4、客户端回一个ACK
####3、TCP协议如何保证可靠传输
	1、应用数据被分割成 TCP 认为最适合发送的数据块。
	2、TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
	3、校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
	4、TCP 的接收端会丢弃重复的数据。
	5、流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
	6、拥塞控制： 当网络拥塞时，减少数据的发送。
	7、停止等待协议 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
	8、超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段
####4、在浏览器中输入url地址到显示主页
	1、宏观上讲
			1、域名解析
			2、建立tcp连接
			3、发送http请求
			4、服务器处理请求
			5、服务器返回一个html响应
			6、浏览器开始显示html
		2、偏宏观上讲
			1、域名解析
			2、建立tcp连接
			3、发送数据包，添加目的ip和源ip
####5、状态码
####6、HTTP长连接，短连接
	Connection：
##三、操作系统
####1、操作系统简介
####2、Linux系统
#####2.1、Linux文件系统
		一切都是文件，linux支持5种文件类型
		1、普通文件
		2、目录文件
		3、链接文件
		4、设备文件
		5、命名管道（FIFO）
#####2.2、Linux基本命令
		1、目录切换命令
		2、目录操作命令
		3、文件操作命令（增删改查）
			1、touch 文件名 ：文件创建
			2、cat/more/less/tail 文件名称  文件查看
			3、vim 文件
			4、rm -rf 删除文件
		4、压缩文件操作命令
			1、打包并压缩文件 打包文件一般是以.tar结尾，压缩命令一般是以.gz结尾
				tar -zcvf 打包压缩后的文件名 要打包压缩的文件
			2、解压缩
				tar -xvf 压缩文件
		5、linux的权限命令
		6、linux用户管理
		7、其他命令
			1、grep 要搜索的字符串 要搜索的文件 --color ： 搜索命令
			2、ps -ef/ps -aux 这两个命令都是查看当前系统正在运行的进程 
				查看特定的 ps aux | grep redis
			3、 kill -9
			4、网络通信命令
				1、查看当前系统的网卡信息 ： ifconfig
				2、查看与某台机器的链接情况	： ping
				3、查看当前系统的端口使用 ： netstat -an
