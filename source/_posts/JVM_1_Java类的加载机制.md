---
​---
title: JVM_虚拟机类加载机制(一)
abstract: 
url: 
date: 2018-11-18 15:01:55
category:Java基础
tags:JVM
​---

---

#### 一、*问题指引*

1、编译
	1、编译的概念？
	2、前端编译（java源码编译成class文件）和后端编译（class文件编译成机器码）？
	3、编译过程是什么？
2、类加载器
	1、什么是类加载器？
	2、类加载器分成几个部分，分别是什么，分别加载什么路径？
	3、什么是双亲委派加载机制？工作原理是什么？
	4、类加载的几个步骤/过程？
	

#### 二、*思维导图*

#### 三、*重点知识点*

##### 1、编译

###### 1.1、编译的概念

​	以通过javac命令将Java程序的源代码编译成Java字节码，即我们常说的class文件。
​	另外字节码并不是机器语言，要想让机器能够执行，还需要把字节码翻译成机器指令。这个过程是Java虚拟机做的，这个过程也叫编译，是更深层次的编译。
​	即反编译，则将class文件反编译成可以理解的java文件
​		提供的反编译的方式或工具如下
​			1、javap
​				javac xx.java
​				javap -c xx.class
​			2、jad
​				jad xx.class
​			3、cfr
​				java -jar cfr_0_125.jar xx.class --decodestringswitch false
​		

###### 1.2、编译的过程

![](https://i.imgur.com/XAstcVK.png)
![编译过程](https://i.imgur.com/rYO7vty.png)
过程分析

1）词法分析：读取源代码，一个字节一个字节的读进来，找出这些词法中我们定义的语言关键词如：if、else、while等，识别哪些if是合法的哪些是不合法的。这个步骤就是词法分析过程。

词法分析的结果：就是从源代码中找出了一些规范化的token流，就像人类语言中，给你一句话你要分辨出哪些是一个词语，哪些是标点符号，哪些是动词，哪些是名词。

2）语法分析：就是对词法分析中得到的token流进行语法分析，这一步就是检查这些关键词组合在一起是不是符合Java语言规范。如if的后面是不是紧跟着一个布尔型判断表达式。

语法分析的结果：就是形成一个符合Java语言规定的抽象语法树，抽象语法树是一个结构化的语法表达形式，它的作用是把语言的主要词法用一个结构化的形式组织在一起。这棵语法树可以被后面按照新的规则再重新组织。

3）语义分析：语法分析完成之后也就不存在语法问题了，语义分析的主要工作就是把一些难懂的，复杂的语法转化成更简单的语法。就如难懂的文言文转化为大家都懂的百话文，或者是注释一下一些不懂的成语。

语义分析结果：就是将复杂的语法转化为简单的语法，对应到Java就是将foreach转化为for循环，还有一些注释等。最后生成一棵抽象的语法树，这棵语法树也就更接近目标语言的语法规则。

4）字节码生成：将会根据经过注释的抽象语法树生成字节码，也就是将一个数据结构转化为另外一个数据结构。就像将所有的中文词语翻译成英文单词后按照英文语法组装文英文语句。代码生成器的结果就是生成符合java虚拟机规范的字节码

###### 1.3、Java源码编译机制

​	1、分析和输入到符号表
​	2、注解处理
​	3、语义分析和生成 class 文件
流程图：
![](https://i.imgur.com/wBe4y5u.png)

最后生成的 class 文件由以下部分组成：
1、结构信息：包括 class 文件格式版本号及各部分的数量与大小的信息。
2、元数据：对应于 Java 源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池。
3、方法信息：对应 Java 源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息

----------

##### 2、类加载器	

###### 2.1、类加载器概念

​		类加载器是一个用来加载类文件的类。Java源代码通过javac编译器编译成类文件,然后JVM来执行类文件中的字节码来执行程序,类加载器负责加载文件系统、网络或其他来源的类文件。

###### 2.2、类加载器

​		1、三种默认使用的类加载器：Bootstrap类加载器、Extension类加载器和System类加载器
​			1) Bootstrap类加载器 – JRE/lib/rt.jar
​			2) Extension类加载器 – JRE/lib/ext或者java.ext.dirs指向的目录
​			3) Application类加载器 – CLASSPATH环境变量, 由-classpath或-cp选项定义,或者是JAR中的Manifest的classpath属性定义.
![类加载器](https://i.imgur.com/inwxX1M.png)

​	2、工作过程
​		1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
​		2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
​		3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；
​		4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载
​		5、如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException

​	3、Java类加载器基于三个机制：委托、可见性和单一性
​		1、委托：双亲委派模型。简单来说：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。
​		2、可见性：子类加载器可以看到父类加载器加载的类，而反之则不行
​		3、单一性：根据这个机制，父加载器加载过的类不能被子加载器加载第二次。虽然重写违反委托和单一性机制的类加载器是可能的，但这样做并不可取。你写自己的类加载器的时候应该严格遵守这三条机制
​	特别说明：
​	类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载

###### 2.3、类加载详细过程	

​		1、类的生命周期：包括这几个部分，加载、连接、初始化、使用和卸载，其中前三部是类的加载的过程
![类加载详细过程](https://i.imgur.com/mc23Peh.png)
​		

分析：
	其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段
	1、加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象
	2、连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用
	3、初始化，为类的静态变量赋予正确的初始值
	4、使用，new出对象程序中使用
	5、卸载，执行垃圾回收

- 加载

- 
	查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：
	1、通过一个类的全限定名来获取其定义的二进制字节流。
	2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
	3、在Java堆中生成一个代表这个类的 java.lang.Class对象，作为对方法区中这些数据的访问入口。
	相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。
	加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。

- 连接

  1. 验证：确保被加载的类的正确性
  	验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：
  	1、文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
  	2、元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。
  	3、字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
  	4、符号引用验证：确保解析动作能正确执行。
  	验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

  2. 准备：为类的 静态变量分配内存，并将其初始化为默认值
  	准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：
  	1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
  	
  	2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
  		假设一个类变量的定义为： publicstaticintvalue=3；
  		那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的 publicstatic指令是在程序编译后，存放于类构造器 <clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。
  		这里还需要注意如下几点：
  		对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
  		对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
  		对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
  		如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。
  	
  	3、如果类字段的字段属性表中存在 ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。
  		假设上面的类变量value被定义为： publicstaticfinalintvalue=3；
  		编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据 ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中

  3. 解析：把类中的符号引用转换为直接引用
  	解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。
  	直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
  
- 初始化

  初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：
  1、声明类变量是指定初始值
  2、使用静态代码块为类变量指定初始值

  JVM初始化步骤：
  1、假如这个类还没有被加载和连接，则程序先加载并连接该类
  2、假如该类的直接父类还没有被初始化，则先初始化其直接父类
  3、假如类中有初始化语句，则系统依次执行这些初始化语句
  	类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：
  	1、创建类的实例，也就是new的方式
  	2、访问某个类或接口的静态变量，或者对该静态变量赋值
  	3、调用类的静态方法
  	4、反射（如 Class.forName(“com.shengsiyuan.Test”)）
  	5、初始化某个类的子类，则其父类也会被初始化
  	6、Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类
  
- 结束生命周期

  在如下几种情况下，Java虚拟机将结束生命周期

  1、执行了 System.exit()方法
  2、程序正常执行结束
  3、程序在执行过程中遇到了异常或错误而异常终止
  4、由于操作系统出现错误而导致Java虚拟机进程终止

  #### 四、*参考资料*

[http://www.hollischuang.com/archives/58](http://www.hollischuang.com/archives/58 "编译")

[https://blog.csdn.net/fuzhongmin05/article/details/54880257](https://blog.csdn.net/fuzhongmin05/article/details/54880257 )

[https://juejin.im/post/5b45ef49f265da0f5140489c](https://juejin.im/post/5b45ef49f265da0f5140489c "类加载器") 

[http://www.cnblogs.com/ityouknow/p/5603287.html](http://www.cnblogs.com/ityouknow/p/5603287.html "类加载器")

#### 五、*思维扩展*

#### 六、*存在疑问*

​	1、异常ClassNotFoundException？
​	2、tomcat存在多少个类加载器？
​	3、JIT 编译器