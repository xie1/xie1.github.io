---
title: JVM_垃圾收集机制(三)
date: 2018-11-18 16:02:55
tags:
categories: Java基础
---
####一、*关注点*
	1、对象存活判断
	2、GC算法
	3、垃圾回收器
####二、*总知识点*
##1、对象存活判断
	1、判断对象是否存活一般有两种方式：
		1、引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
		2、可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。
			在Java语言中，GC Roots包括：
				虚拟机栈中引用的对象。
				方法区中类静态属性实体引用的对象。
				方法区中常量引用的对象。
				本地方法栈中JNI引用的对象。


----------


##2、GC算法
###2.1、标记 -清除算法
	“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
	之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。
	它的主要缺点有两个：
		一个是效率问题，标记和清除过程的效率都不高；
		另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作
![标记-清除](https://i.imgur.com/ybhRjwN.png)
###2.2、复制算法
	“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
	这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低
![复制](https://i.imgur.com/6SuM1qV.png)
###2.3、标记-压缩算法
	复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。
	根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
![标记-压缩](https://i.imgur.com/9yntClz.png)
###2.4、分代收集算法
	GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。
	“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收

----------


##3、垃圾回收器
###3.1、相关概念介绍
		并行和并发
			并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
			并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。
		吞吐量（Throughput）
			吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即
			吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。
			假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。
		Minor GC 和 Full GC
			新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。具体原理见上一篇文章。
			老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。
###3.2、新生代收集器
####3.2.1、Serial收集器
####3.2.2、ParNew 收集器
####3.2.3、Parallel Scavenge 收集器
###3.3、老年代收集器
####3.3.1、Serial Old收集器
####3.3.2、ParNew 收集器
####3.3.3、Parallel Scavenge 收集器
###3.4、G1收集器
详情介绍链接：
[https://crowhawk.github.io/2017/08/15/jvm_3/](https://crowhawk.github.io/2017/08/15/jvm_3/ "垃圾收集器")

####三、*参考资料*
[http://www.cnblogs.com/ityouknow/p/5614961.html](http://www.cnblogs.com/ityouknow/p/5614961.html "GC算法及GC收集器")

[https://crowhawk.github.io/2017/08/15/jvm_3/](https://crowhawk.github.io/2017/08/15/jvm_3/ "垃圾收集器")
####四、*思维扩展*
####五、*存在疑问*