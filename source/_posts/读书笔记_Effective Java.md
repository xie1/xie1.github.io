---
title: 读书笔记_Effective java
date: 2019-04-05 23:01:41
tags:
categories: 读书笔记
---
#一、*思维导图*
#*总知识点*
##一、Java库
	1、java.lang
	2、java.util
	3、java.util.concurrent
	4、java.io
##二、创建和销毁对象
###1、考虑用静态工厂方法代替构造器
	优势：
	1、静态工厂方法与狗肇庆不同第一大优势，他们有名称
	2、不必再每次调用的时候都创建一个对象（类似于单例模式）
	3、他们可以返回类型的任何子类型的对象
	4、在创建参数化类型实例的时候，他们使代码变得更加简洁
	劣势：
	1、类如果不含有的或者受保护的构造器，就不能被子类化
	2、他们与静态方法实际上没有任何区别
###2、遇到多个构造器参数时要考虑用构建器
	Builder模式，不直接生成想要的对象，而让客户端利用所有必要的参数调用构造器或者静态工厂一个builder对象
	
###3、用私有构造器或者枚举类型强化Singleton属性
###4、通过私有构造器强化不可实例化能力
###5、避免创建不必要的对象
###6、消除过期的对象引用
	内存泄漏
	1、常见来源：只有当所要缓存想的生命周期是由该键的外部引用，而不是由值决定时，weakHashMap才有用处
	2、监听器和其他回调
###7、避免使用终结方法
	可以采用InputStream，outputStream,Connetiond的close方法   
##三、对于所有对象都通用方法
###8、覆盖equals时请遵守通用约定
	不覆盖equals方法
	1、类的每个实例本质上是唯一的
	2、不关心是否提供了逻辑相等的测试功能
	3、超类已覆盖的equal，从超类继承过来的行为对于子类也是合适的
	4、类是私有的或者是包级私有，可以确定它的equals方法永远不会被调用
	equals方法实现对等的关系
	1、自反性，x.equals(x)==>true
	2、对称性
	3、传递性、
	4、一致性
	5、对于任何非null引用值，x.equal(null)必须返回false
	实现高质量的equals方法：
	1、使用==操作符检查，参数是否为这个对象的引用
	2、使用instanceof操作检查参数是否是正确的类型
	3、把参数转换成正确的类型
	4、对于该类中的每一关键域，检查参数中的域是否与该对象中对应域相匹配
	注意：
	1、覆盖equals时总要覆盖hashcode
	2、不要企图让equals方法过于只能
	3、不要将equals声明中的object对象替换成其他类型
###9、覆盖equals时总是要覆盖hashcode
	如果不这么做的话，会违反Object、hashcode的通用约定，从而导致该类无法结合所有基于散列的集合一起工作，这样的集合都要包含hashmap，hashSet，HashTable
###10、始终要覆盖toString
###11、小心地覆盖clone
	Cloneable并没有任何方法，它决定了Object中所保护的clone方法的实现行为
###12、考虑实现Comparable接口
	compareTo方法并没有在Object中声明，相反它是Compareable接口中唯一的方法，实现Comparable接口，就表明了它具有内在排序关系
	如果一个域并没有实现Comparable接口，或者你需要使用一个非标准的排序关系，就可以使用显示Comparator代替

##四、类和接口
###13、使类和成员的可访问性最小
	除了公有静态final域的特殊情形之外，公有类都不应该包含公有域，属性，而且要确保公有静态域所引用的对象都是不可变的。
###14、在公有类中使用访问方法而非公有域
###15、使可变性最小化
	不可变类，String，基本类型的包装类，BigInteger,BigDecimal
###16、复合优于继承
	不可扩展现有的类，而是在新的类中增加了一个私有域，它引用现有类的一个实例，即复合
###17、要么为继承而设计，并提供文档说明，要么就禁止继承
###18、接口优于抽象类
	1、现有的类可以很容易被更新，以实现新的接口
	2、接口是定义mixin（混合类型）的理想选择
	3、接口允许我们构造非层次结构的类型框架
###19、接口只用于定义类型
	接口应该只被用来定义类型，他们不应该被用来导出常量
###20、类层次优于标签类
###21、用函数对象表示策略
	嵌套类有四种，
	1、静态类成员类
	2、非静态类成员类
	3、匿名类
	4、局部类


##五、泛型
###23、请不要在新代码中使用原生态类型
	1、Set<Object> 任何对象某个集合
	2、Set<?> 只包含某种接口的类型集合
	3、Set原生态，不安全

###24、消除非受控警告
###25、列表优于数组
	数组在运行时才知道并检查他们的元素类型约束
###26、优先考虑泛型
###27、优先考虑泛型方法
###28、使用有限制通配符来提升API的灵活性
	1、如果参数化类型表示一个生产者，就是使用<? extends T>;
	2、如果它表示T消费者，就使用<? super T> 所有的Comparable 和Comparator都是消费者
###29、优先考虑类型安全的异构容器

##六、枚举和注解
###30、用enum代替int常量
	java枚举本质上int值
###31、用实例域代替拿数
###32、用EnumSet代替位域
###33、用EnumMap代替序数索引
###34、用接口模拟可伸缩的枚举
###35、注解优先于命名模式
###36、坚持使用Override
###37、用标记接口定义类型


##七、方法
###38、检查参数有效性
###39、必要时进行保护性拷贝
	对于参数类型可以被不可信任子类化参数，请不要使用clone（）方法保护性拷贝
###40、谨慎设计签名
###41、慎用重载
###42、慎用可变参数
###43、返回零长度的数组或集合，而不是null
###44、为所有导出的API元素编写文档注解



##八、通用程序设计
###45、将局部变量的作用域最小化
###46、for-each循环优先于传统
	无法使用for-each循环
	过滤，转换，平行迭代
###47、了解和使用类库
###48、如果需要精确的答案，请避免使用float和double，用BigDecimal,int,long进行货币计算
###49、基本类型优于装箱基本类型
	1、对装箱基本类型运用==操作符几乎总是错误的
		集合，参数化类型，反射方法调用
###50、如果其他类型更适合，则尽量避免使用字符串
###51、当心字符串连接性能
	用StringBuilder代替String
###52、通过接口引用对象
###53、接口优于反射机制
###54、谨慎使用本地方法
###55、谨慎地进行优化
	1、性能解析器
	2、有效算法
###56、遵守普遍接受的命名惯例


##九、异常
###57、只针对异常的情况才使用异常
###58、对可恢复的情况使用受检查异常，对编程错误使用运行异常
	1、受检查异常
	2、运行时异常
	3、Error错误
###59、避免不必要的使用受检查异常
###60、优先使用标准异常
###61、抛出与抽象相对应的异常
###62、每个方法抛出的异常都要有文档
###63、在细节消息中包含能捕获失败的信息
###64、努力使失败保持原子性
###65、不要忽略异常


##十、并发
###66、同步访问共享的可变数据
###67、避免过度同步
###68、executor和task优先线程
###69、并发工具优先于wait和notity
	concurrent更高级工具
		1、Executor FrameWork
		2、并发集合
		3、同步器

###70、线程安全性的文档化
###71、慎用延迟初始化
###72、不要依赖线程调度器
###73、避免使用线程组


##十一、序列化
###74、慎用地实现Seriazable接口
###75、考虑使用自定义的序列化形式
###76、保护性编写readObject方法
###77、对于实例控制，枚举类型优先readResolve
###78、考虑用序列化代理代替序列化实例













